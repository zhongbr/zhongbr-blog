{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '浅谈JavaScript模块化'\ntags: ['前端工程化', '前端', 'NodeJS', 'CommonJs', 'ES Module', 'AMD']\nrecommend: 'frontend'\nicon: '😁'\ncover: 'https://i.328888.xyz/2023/01/02/tNist.png'","loc":{"start":{"line":1,"column":0},"end":{"line":7,"column":3}},"range":[0,180],"raw":"---\ntitle: '浅谈JavaScript模块化'\ntags: ['前端工程化', '前端', 'NodeJS', 'CommonJs', 'ES Module', 'AMD']\nrecommend: 'frontend'\nicon: '😁'\ncover: 'https://i.328888.xyz/2023/01/02/tNist.png'\n---","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"模块化规范","loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":7}},"range":[184,189],"raw":"模块化规范"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":7}},"range":[182,189],"raw":"# 模块化规范"},{"type":"Paragraph","children":[{"type":"Str","value":"JavaScript在最开始时是没有模块化的概念的，即使在浏览器中使用多个 script 标签加载的 js，仍然是共享的全局变量空间。","loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":67}},"range":[191,258],"raw":"JavaScript在最开始时是没有模块化的概念的，即使在浏览器中使用多个 script 标签加载的 js，仍然是共享的全局变量空间。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":67}},"range":[191,258],"raw":"JavaScript在最开始时是没有模块化的概念的，即使在浏览器中使用多个 script 标签加载的 js，仍然是共享的全局变量空间。"},{"type":"Paragraph","children":[{"type":"Strong","children":[{"type":"Str","value":"模块化规范","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":7}},"range":[262,267],"raw":"模块化规范"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":9}},"range":[260,269],"raw":"**模块化规范**"},{"type":"Str","value":"为 JavaScript 提供了模块编写、模块依赖和模块运行的方案。","loc":{"start":{"line":13,"column":9},"end":{"line":13,"column":43}},"range":[269,303],"raw":"为 JavaScript 提供了模块编写、模块依赖和模块运行的方案。"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":43}},"range":[260,303],"raw":"**模块化规范**为 JavaScript 提供了模块编写、模块依赖和模块运行的方案。"},{"type":"Paragraph","children":[{"type":"Str","value":"总体来说，目前 JavaScript 有两种模块化规范(esm 和 CommonJS)，","loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":44}},"range":[305,349],"raw":"总体来说，目前 JavaScript 有两种模块化规范(esm 和 CommonJS)，"},{"type":"Strong","children":[{"type":"Str","value":"并且这两种模块化规范并不完全兼容","loc":{"start":{"line":15,"column":46},"end":{"line":15,"column":62}},"range":[351,367],"raw":"并且这两种模块化规范并不完全兼容"}],"loc":{"start":{"line":15,"column":44},"end":{"line":15,"column":64}},"range":[349,369],"raw":"**并且这两种模块化规范并不完全兼容**"},{"type":"Str","value":"。","loc":{"start":{"line":15,"column":64},"end":{"line":15,"column":65}},"range":[369,370],"raw":"。"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":65}},"range":[305,370],"raw":"总体来说，目前 JavaScript 有两种模块化规范(esm 和 CommonJS)，**并且这两种模块化规范并不完全兼容**。"},{"type":"Paragraph","children":[{"type":"Str","value":"[模块化规范](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/模块化规范 0976128fbb0648a791aca022b8a2f01b.csv)","loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":108}},"range":[372,480],"raw":"[模块化规范](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/模块化规范 0976128fbb0648a791aca022b8a2f01b.csv)"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":108}},"range":[372,480],"raw":"[模块化规范](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/模块化规范 0976128fbb0648a791aca022b8a2f01b.csv)"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"CommonJS 和 ESM 横向比较","loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":21}},"range":[484,503],"raw":"CommonJS 和 ESM 横向比较"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":21}},"range":[482,503],"raw":"# CommonJS 和 ESM 横向比较"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"使用 esm 编写的模块，","loc":{"start":{"line":21,"column":3},"end":{"line":21,"column":16}},"range":[508,521],"raw":"使用 esm 编写的模块，"},{"type":"Strong","children":[{"type":"Str","value":"不能被 require","loc":{"start":{"line":21,"column":18},"end":{"line":21,"column":29}},"range":[523,534],"raw":"不能被 require"}],"loc":{"start":{"line":21,"column":16},"end":{"line":21,"column":31}},"range":[521,536],"raw":"**不能被 require**"},{"type":"Str","value":"，只能使用 import 关键字导入；","loc":{"start":{"line":21,"column":31},"end":{"line":21,"column":50}},"range":[536,555],"raw":"，只能使用 import 关键字导入；"}],"loc":{"start":{"line":21,"column":3},"end":{"line":21,"column":50}},"range":[508,555],"raw":"使用 esm 编写的模块，**不能被 require**，只能使用 import 关键字导入；"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。","loc":{"start":{"line":23,"column":6},"end":{"line":23,"column":47}},"range":[567,608],"raw":"这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。"}],"loc":{"start":{"line":23,"column":6},"end":{"line":23,"column":47}},"range":[567,608],"raw":"这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。"}],"loc":{"start":{"line":23,"column":4},"end":{"line":24,"column":6}},"range":[565,615],"raw":"> 这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。\n    > "}],"loc":{"start":{"line":21,"column":0},"end":{"line":24,"column":6}},"range":[505,615],"raw":"1. 使用 esm 编写的模块，**不能被 require**，只能使用 import 关键字导入；\n    \n    > 这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。\n    > "},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；","loc":{"start":{"line":25,"column":3},"end":{"line":25,"column":81}},"range":[619,697],"raw":"使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；"}],"loc":{"start":{"line":25,"column":3},"end":{"line":25,"column":81}},"range":[619,697],"raw":"使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"这是由于 cjs 编写的模块，其内部导出的内容是动态的，","loc":{"start":{"line":27,"column":6},"end":{"line":27,"column":34}},"range":[709,737],"raw":"这是由于 cjs 编写的模块，其内部导出的内容是动态的，"},{"type":"Strong","children":[{"type":"Str","value":"需要被导入的文件执行完成以后","loc":{"start":{"line":27,"column":36},"end":{"line":27,"column":50}},"range":[739,753],"raw":"需要被导入的文件执行完成以后"}],"loc":{"start":{"line":27,"column":34},"end":{"line":27,"column":52}},"range":[737,755],"raw":"**需要被导入的文件执行完成以后**"},{"type":"Str","value":"，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。","loc":{"start":{"line":27,"column":52},"end":{"line":27,"column":122}},"range":[755,825],"raw":"，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。"}],"loc":{"start":{"line":27,"column":6},"end":{"line":27,"column":122}},"range":[709,825],"raw":"这是由于 cjs 编写的模块，其内部导出的内容是动态的，**需要被导入的文件执行完成以后**，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。"}],"loc":{"start":{"line":27,"column":4},"end":{"line":28,"column":6}},"range":[707,832],"raw":"> 这是由于 cjs 编写的模块，其内部导出的内容是动态的，**需要被导入的文件执行完成以后**，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。\n    > "}],"loc":{"start":{"line":25,"column":0},"end":{"line":28,"column":6}},"range":[616,832],"raw":"2. 使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；\n    \n    > 这是由于 cjs 编写的模块，其内部导出的内容是动态的，**需要被导入的文件执行完成以后**，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。\n    > "},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；","loc":{"start":{"line":29,"column":3},"end":{"line":29,"column":55}},"range":[836,888],"raw":"使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；"}],"loc":{"start":{"line":29,"column":3},"end":{"line":29,"column":55}},"range":[836,888],"raw":"使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":55}},"range":[833,888],"raw":"3. 使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。","loc":{"start":{"line":30,"column":3},"end":{"line":30,"column":106}},"range":[892,995],"raw":"可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。"}],"loc":{"start":{"line":30,"column":3},"end":{"line":30,"column":106}},"range":[892,995],"raw":"可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。"}],"loc":{"start":{"line":30,"column":0},"end":{"line":30,"column":106}},"range":[889,995],"raw":"4. 可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以","loc":{"start":{"line":31,"column":3},"end":{"line":31,"column":55}},"range":[999,1051],"raw":"cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以"},{"type":"Strong","children":[{"type":"Str","value":"将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案","loc":{"start":{"line":31,"column":57},"end":{"line":31,"column":109}},"range":[1053,1105],"raw":"将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案"}],"loc":{"start":{"line":31,"column":55},"end":{"line":31,"column":111}},"range":[1051,1107],"raw":"**将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案**"},{"type":"Str","value":"，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。","loc":{"start":{"line":31,"column":111},"end":{"line":31,"column":144}},"range":[1107,1140],"raw":"，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。"}],"loc":{"start":{"line":31,"column":3},"end":{"line":31,"column":144}},"range":[999,1140],"raw":"cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以**将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案**，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":144}},"range":[996,1140],"raw":"5. cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以**将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案**，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。"}],"loc":{"start":{"line":21,"column":0},"end":{"line":31,"column":144}},"range":[505,1140],"raw":"1. 使用 esm 编写的模块，**不能被 require**，只能使用 import 关键字导入；\n    \n    > 这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。\n    > \n2. 使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；\n    \n    > 这是由于 cjs 编写的模块，其内部导出的内容是动态的，**需要被导入的文件执行完成以后**，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。\n    > \n3. 使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；\n4. 可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。\n5. cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以**将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案**，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"案例和坑","loc":{"start":{"line":33,"column":2},"end":{"line":33,"column":6}},"range":[1144,1148],"raw":"案例和坑"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":6}},"range":[1142,1148],"raw":"# 案例和坑"},{"type":"Paragraph","children":[{"type":"Str","value":"随便打开一个 React 项目的 node_modules ，不难发现，其实 React 只提供了 cjs 格式的包：","loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":59}},"range":[1150,1209],"raw":"随便打开一个 React 项目的 node_modules ，不难发现，其实 React 只提供了 cjs 格式的包："}],"loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":59}},"range":[1150,1209],"raw":"随便打开一个 React 项目的 node_modules ，不难发现，其实 React 只提供了 cjs 格式的包："},{"type":"Paragraph","children":[{"type":"Str","value":"![Untitled](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/Untitled.png)","loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":82}},"range":[1211,1293],"raw":"![Untitled](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/Untitled.png)"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":82}},"range":[1211,1293],"raw":"![Untitled](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/Untitled.png)"},{"type":"Paragraph","children":[{"type":"Str","value":"正常情况下，我们在代码里使用 React 的时候，应该按照下面的方式来引入：","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":38}},"range":[1295,1333],"raw":"正常情况下，我们在代码里使用 React 的时候，应该按照下面的方式来引入："}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":38}},"range":[1295,1333],"raw":"正常情况下，我们在代码里使用 React 的时候，应该按照下面的方式来引入："},{"type":"CodeBlock","lang":"jsx","meta":null,"value":"import React from 'react';\nconst { useEffect } = React;","loc":{"start":{"line":41,"column":0},"end":{"line":44,"column":3}},"range":[1335,1401],"raw":"```jsx\nimport React from 'react';\nconst { useEffect } = React;\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"但是在项目实际开发的时候，我们直接按照 esm 的方式来引入 React 更为常见，并且也不会报错，执行起来也是没问题的。","loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":61}},"range":[1403,1464],"raw":"但是在项目实际开发的时候，我们直接按照 esm 的方式来引入 React 更为常见，并且也不会报错，执行起来也是没问题的。"}],"loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":61}},"range":[1403,1464],"raw":"但是在项目实际开发的时候，我们直接按照 esm 的方式来引入 React 更为常见，并且也不会报错，执行起来也是没问题的。"},{"type":"CodeBlock","lang":"jsx","meta":null,"value":"import React, { useEffect } from 'react';","loc":{"start":{"line":48,"column":0},"end":{"line":50,"column":3}},"range":[1466,1518],"raw":"```jsx\nimport React, { useEffect } from 'react';\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"这是由于 babel、webpack 等会在编译的时候对 React 进行特殊处理，让其支持通过 esm 的方式来引入 npm 包。","loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":66}},"range":[1520,1586],"raw":"这是由于 babel、webpack 等会在编译的时候对 React 进行特殊处理，让其支持通过 esm 的方式来引入 npm 包。"}],"loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":66}},"range":[1520,1586],"raw":"这是由于 babel、webpack 等会在编译的时候对 React 进行特殊处理，让其支持通过 esm 的方式来引入 npm 包。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":53,"column":0}},"range":[0,1587],"raw":"---\ntitle: '浅谈JavaScript模块化'\ntags: ['前端工程化', '前端', 'NodeJS', 'CommonJs', 'ES Module', 'AMD']\nrecommend: 'frontend'\nicon: '😁'\ncover: 'https://i.328888.xyz/2023/01/02/tNist.png'\n---\n\n# 模块化规范\n\nJavaScript在最开始时是没有模块化的概念的，即使在浏览器中使用多个 script 标签加载的 js，仍然是共享的全局变量空间。\n\n**模块化规范**为 JavaScript 提供了模块编写、模块依赖和模块运行的方案。\n\n总体来说，目前 JavaScript 有两种模块化规范(esm 和 CommonJS)，**并且这两种模块化规范并不完全兼容**。\n\n[模块化规范](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/模块化规范 0976128fbb0648a791aca022b8a2f01b.csv)\n\n# CommonJS 和 ESM 横向比较\n\n1. 使用 esm 编写的模块，**不能被 require**，只能使用 import 关键字导入；\n    \n    > 这是由于 esm 模块内是支持顶层 await 的，但是 cjs 模块是不支持的。\n    > \n2. 使用 cjs 编写的模块，不能被 import 关键字导入（可以使用 default import 兼容，见第3条），只能使用 require 函数来导入；\n    \n    > 这是由于 cjs 编写的模块，其内部导出的内容是动态的，**需要被导入的文件执行完成以后**，才能确定有哪些内容被挂载到 module.exports 上，而 import 的关键字的解析是需要在编译时进行的，此时模块还没有被执行。\n    > \n3. 使用 cjs 编写的模块，可以被 default import ，但是不能被 named import；\n4. 可以在 esm 模块内使用 require 来导入 cjs 模块，即使该 cjs 模块使用的是 named export。但是这样的使用可能会在 webpack、rollup 等构建工具中带来不必要的麻烦。\n5. cjs 是默认的模块化方案，如果你想使用 esm ，可以将 js 的文件后缀名修改为 .mjs。或者可以**将 package.json 中的 type 设置为 module ，将 esm 设置为默认的模块化方案**，如果此时想使用 cjs ，需要将对应的文件后缀名改为 .mjs。\n\n# 案例和坑\n\n随便打开一个 React 项目的 node_modules ，不难发现，其实 React 只提供了 cjs 格式的包：\n\n![Untitled](posts/前端工程化/JS模块化/模块化规范 819d6c57d4154f94bdf0781db857fdb7/Untitled.png)\n\n正常情况下，我们在代码里使用 React 的时候，应该按照下面的方式来引入：\n\n```jsx\nimport React from 'react';\nconst { useEffect } = React;\n```\n\n但是在项目实际开发的时候，我们直接按照 esm 的方式来引入 React 更为常见，并且也不会报错，执行起来也是没问题的。\n\n```jsx\nimport React, { useEffect } from 'react';\n```\n\n这是由于 babel、webpack 等会在编译的时候对 React 进行特殊处理，让其支持通过 esm 的方式来引入 npm 包。\n"},"catalogue":{"title":"浅谈JavaScript模块化","json-path":"前端工程化/JS模块化/2023-01-03-模块化规范 819d6c57d4154f94bdf0781db857fdb7.json","mdate":"2023-01-03","cover":"https://i.328888.xyz/2023/01/02/tNist.png","icon":"😁","visible":true,"tags":["前端工程化","前端","NodeJS","CommonJs","ES Module","AMD"],"recommend":"frontend"}}