{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','树']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','树']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"树的应用：并查集","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":10}},"range":[30,38],"raw":"树的应用：并查集"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":10}},"range":[28,38],"raw":"# 树的应用：并查集"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"并查集的定义","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":9}},"range":[43,49],"raw":"并查集的定义"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":9}},"range":[40,49],"raw":"## 并查集的定义"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"并查集是一种简单的集合表示形式，通常使用","loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":22}},"range":[53,73],"raw":"并查集是一种简单的集合表示形式，通常使用"},{"type":"Strong","children":[{"type":"Str","value":"树的双亲表示法","loc":{"start":{"line":9,"column":24},"end":{"line":9,"column":31}},"range":[75,82],"raw":"树的双亲表示法"}],"loc":{"start":{"line":9,"column":22},"end":{"line":9,"column":33}},"range":[73,84],"raw":"**树的双亲表示法**"},{"type":"Str","value":"来作为并查集的存储结构","loc":{"start":{"line":9,"column":33},"end":{"line":9,"column":44}},"range":[84,95],"raw":"来作为并查集的存储结构"}],"loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":44}},"range":[53,95],"raw":"并查集是一种简单的集合表示形式，通常使用**树的双亲表示法**来作为并查集的存储结构"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称","loc":{"start":{"line":11,"column":4},"end":{"line":11,"column":38}},"range":[102,136],"raw":"通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称"}],"loc":{"start":{"line":11,"column":4},"end":{"line":11,"column":38}},"range":[102,136],"raw":"通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":38}},"range":[100,136],"raw":"- 通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数","loc":{"start":{"line":12,"column":4},"end":{"line":12,"column":38}},"range":[141,175],"raw":"根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数"}],"loc":{"start":{"line":12,"column":4},"end":{"line":12,"column":38}},"range":[141,175],"raw":"根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数"}],"loc":{"start":{"line":12,"column":2},"end":{"line":12,"column":38}},"range":[139,175],"raw":"- 根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数"}],"loc":{"start":{"line":11,"column":2},"end":{"line":12,"column":38}},"range":[100,175],"raw":"- 通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称\n> - 根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数"}],"loc":{"start":{"line":9,"column":0},"end":{"line":12,"column":38}},"range":[51,175],"raw":"> 并查集是一种简单的集合表示形式，通常使用**树的双亲表示法**来作为并查集的存储结构\n>\n> - 通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称\n> - 根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"并查集的基本操作","loc":{"start":{"line":14,"column":3},"end":{"line":14,"column":11}},"range":[180,188],"raw":"并查集的基本操作"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":11}},"range":[177,188],"raw":"## 并查集的基本操作"},{"type":"List","ordered":false,"start":null,"spread":true,"children":[{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;","loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":42}},"range":[192,232],"raw":"初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;"}],"loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":42}},"range":[192,232],"raw":"初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define SIZE 100\nint UFSets[SIZE];\n\nvoid Initial(int S[], int size){\n    for(int i=0; i<size; i++){\n        S[i]=-1;\n    }\n}","loc":{"start":{"line":18,"column":2},"end":{"line":27,"column":5}},"range":[236,385],"raw":"```c\n  #define SIZE 100\n  int UFSets[SIZE];\n\n  void Initial(int S[], int size){\n      for(int i=0; i<size; i++){\n          S[i]=-1;\n      }\n  }\n  ```"}],"loc":{"start":{"line":16,"column":0},"end":{"line":27,"column":5}},"range":[190,385],"raw":"- 初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;\n\n  ```c\n  #define SIZE 100\n  int UFSets[SIZE];\n\n  void Initial(int S[], int size){\n      for(int i=0; i<size; i++){\n          S[i]=-1;\n      }\n  }\n  ```"},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;","loc":{"start":{"line":29,"column":2},"end":{"line":29,"column":57}},"range":[389,444],"raw":"合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;"}],"loc":{"start":{"line":29,"column":2},"end":{"line":29,"column":57}},"range":[389,444],"raw":"合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void Union(int S[], int Root1, int Root2){\n    S[Root2] = Root1;\n}","loc":{"start":{"line":31,"column":2},"end":{"line":35,"column":5}},"range":[450,533],"raw":"```c\n  void Union(int S[], int Root1, int Root2){\n      S[Root2] = Root1;\n  }\n  ```"}],"loc":{"start":{"line":29,"column":0},"end":{"line":35,"column":5}},"range":[387,533],"raw":"- 合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;\n  \n  ```c\n  void Union(int S[], int Root1, int Root2){\n      S[Root2] = Root1;\n  }\n  ```"},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回","loc":{"start":{"line":37,"column":2},"end":{"line":37,"column":37}},"range":[537,572],"raw":"查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回"}],"loc":{"start":{"line":37,"column":2},"end":{"line":37,"column":37}},"range":[537,572],"raw":"查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int Find(int S[], int x){\n    while(S[x]>=0) x=S[x];\n    return x;\n}","loc":{"start":{"line":39,"column":2},"end":{"line":44,"column":5}},"range":[578,665],"raw":"```c\n  int Find(int S[], int x){\n      while(S[x]>=0) x=S[x];\n      return x;\n  }\n  ```"}],"loc":{"start":{"line":37,"column":0},"end":{"line":44,"column":5}},"range":[535,665],"raw":"- 查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回\n  \n  ```c\n  int Find(int S[], int x){\n      while(S[x]>=0) x=S[x];\n      return x;\n  }\n  ```"}],"loc":{"start":{"line":16,"column":0},"end":{"line":44,"column":5}},"range":[190,665],"raw":"- 初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;\n\n  ```c\n  #define SIZE 100\n  int UFSets[SIZE];\n\n  void Initial(int S[], int size){\n      for(int i=0; i<size; i++){\n          S[i]=-1;\n      }\n  }\n  ```\n\n- 合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;\n  \n  ```c\n  void Union(int S[], int Root1, int Root2){\n      S[Root2] = Root1;\n  }\n  ```\n\n- 查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回\n  \n  ```c\n  int Find(int S[], int x){\n      while(S[x]>=0) x=S[x];\n      return x;\n  }\n  ```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":45,"column":0}},"range":[0,666],"raw":"---\ntags: ['数据结构','树']\n---\n\n# 树的应用：并查集\n\n## 并查集的定义\n\n> 并查集是一种简单的集合表示形式，通常使用**树的双亲表示法**来作为并查集的存储结构\n>\n> - 通常规定使用数组的下表代表结点的名称，使用根结点的名称代表集合的名称\n> - 根结点的双亲结点为负数，用根结点的双亲结点的绝对值标识树中结点的个数\n\n## 并查集的基本操作\n\n- 初始化 Initial(s): 将集合s中的元素都初始化为只有一个元素的子集合;\n\n  ```c\n  #define SIZE 100\n  int UFSets[SIZE];\n\n  void Initial(int S[], int size){\n      for(int i=0; i<size; i++){\n          S[i]=-1;\n      }\n  }\n  ```\n\n- 合并 Union(s, root1, root2): 将集合中互不相交的子集合root2并入子集合root1;\n  \n  ```c\n  void Union(int S[], int Root1, int Root2){\n      S[Root2] = Root1;\n  }\n  ```\n\n- 查找 Find(s, x): 查找x在并查集中所处的子集合名称，并返回\n  \n  ```c\n  int Find(int S[], int x){\n      while(S[x]>=0) x=S[x];\n      return x;\n  }\n  ```\n"},"catalogue":{"title":"2020-07-28-树的应用：并查集","json-path":"2020-07-28-树的应用：并查集.json","mdate":"2022-09-03T11:27:43.562Z","tags":["数据结构","树"]}}