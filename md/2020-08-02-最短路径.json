{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','图']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','图']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"最短路径","loc":{"start":{"line":4,"column":2},"end":{"line":4,"column":6}},"range":[29,33],"raw":"最短路径"}],"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":6}},"range":[27,33],"raw":"# 最短路径"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Dijkstra算法（带权图单源最短路径）","loc":{"start":{"line":6,"column":3},"end":{"line":6,"column":24}},"range":[38,59],"raw":"Dijkstra算法（带权图单源最短路径）"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":24}},"range":[35,59],"raw":"## Dijkstra算法（带权图单源最短路径）"},{"type":"Paragraph","children":[{"type":"Str","value":"主要的思想也是","loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":7}},"range":[61,68],"raw":"主要的思想也是"},{"type":"Strong","children":[{"type":"Str","value":"贪心算法","loc":{"start":{"line":8,"column":9},"end":{"line":8,"column":13}},"range":[70,74],"raw":"贪心算法"}],"loc":{"start":{"line":8,"column":7},"end":{"line":8,"column":15}},"range":[68,76],"raw":"**贪心算法**"},{"type":"Str","value":"。","loc":{"start":{"line":8,"column":15},"end":{"line":8,"column":16}},"range":[76,77],"raw":"。"}],"loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":16}},"range":[61,77],"raw":"主要的思想也是**贪心算法**。"},{"type":"Paragraph","children":[{"type":"Str","value":"需要如下的三个辅助数组：","loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[79,91],"raw":"需要如下的三个辅助数组："}],"loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[79,91],"raw":"需要如下的三个辅助数组："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"s[]: 用于标记已经计算完成的顶点。\n数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1","loc":{"start":{"line":12,"column":2},"end":{"line":13,"column":34}},"range":[95,149],"raw":"s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1"}],"loc":{"start":{"line":12,"column":2},"end":{"line":13,"column":34}},"range":[95,149],"raw":"s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1"}],"loc":{"start":{"line":12,"column":0},"end":{"line":13,"column":34}},"range":[93,149],"raw":"- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$","loc":{"start":{"line":14,"column":2},"end":{"line":15,"column":46}},"range":[152,235],"raw":"dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$"}],"loc":{"start":{"line":14,"column":2},"end":{"line":15,"column":46}},"range":[152,235],"raw":"dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$"}],"loc":{"start":{"line":14,"column":0},"end":{"line":15,"column":46}},"range":[150,235],"raw":"- dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$","loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":56}},"range":[238,292],"raw":"path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$"}],"loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":56}},"range":[238,292],"raw":"path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":56}},"range":[236,292],"raw":"- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$"}],"loc":{"start":{"line":12,"column":0},"end":{"line":16,"column":56}},"range":[93,292],"raw":"- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1\n- dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$\n- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$"},{"type":"Paragraph","children":[{"type":"Str","value":"最短路径上$v_{i}$的前驱顶点。\n初始化：若源点$v_{0}$到该顶点$v_{i}$有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。","loc":{"start":{"line":17,"column":0},"end":{"line":18,"column":64}},"range":[293,376],"raw":"最短路径上$v_{i}$的前驱顶点。\n  初始化：若源点$v_{0}$到该顶点$v_{i}$有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。"}],"loc":{"start":{"line":17,"column":0},"end":{"line":18,"column":64}},"range":[293,376],"raw":"最短路径上$v_{i}$的前驱顶点。\n  初始化：若源点$v_{0}$到该顶点$v_{i}$有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。"},{"type":"Paragraph","children":[{"type":"Str","value":"算法步骤：","loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":5}},"range":[378,383],"raw":"算法步骤："}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":5}},"range":[378,383],"raw":"算法步骤："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始化数组，集合S初始化为{0};","loc":{"start":{"line":22,"column":3},"end":{"line":22,"column":20}},"range":[388,405],"raw":"初始化数组，集合S初始化为{0};"}],"loc":{"start":{"line":22,"column":3},"end":{"line":22,"column":20}},"range":[388,405],"raw":"初始化数组，集合S初始化为{0};"}],"loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":20}},"range":[385,405],"raw":"1. 初始化数组，集合S初始化为{0};"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min{dist[i] \\lvert v_{i} \\in V-S}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup {j}$;","loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":118}},"range":[409,524],"raw":"从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup \\{j\\}$;"}],"loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":118}},"range":[409,524],"raw":"从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup \\{j\\}$;"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":118}},"range":[406,524],"raw":"2. 从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup \\{j\\}$;"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。","loc":{"start":{"line":24,"column":3},"end":{"line":24,"column":123}},"range":[528,648],"raw":"修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。"}],"loc":{"start":{"line":24,"column":3},"end":{"line":24,"column":123}},"range":[528,648],"raw":"修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":123}},"range":[525,648],"raw":"3. 修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。"}],"loc":{"start":{"line":22,"column":0},"end":{"line":24,"column":123}},"range":[385,648],"raw":"1. 初始化数组，集合S初始化为{0};\n2. 从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup \\{j\\}$;\n3. 修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}","loc":{"start":{"line":26,"column":0},"end":{"line":58,"column":3}},"range":[650,1466],"raw":"```c\n#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是$O(\\lvert V \\rvert ^ {2})$。","loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":73}},"range":[1468,1541],"raw":"代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是$O(\\lvert V \\rvert ^ {2})$。"}],"loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":73}},"range":[1468,1541],"raw":"代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是$O(\\lvert V \\rvert ^ {2})$。"},{"type":"Paragraph","children":[{"type":"Str","value":"由于Dijkstra算法是每一步都选择路径最短的顶点，","loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":27}},"range":[1543,1570],"raw":"由于Dijkstra算法是每一步都选择路径最短的顶点，"},{"type":"Strong","children":[{"type":"Str","value":"只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）","loc":{"start":{"line":62,"column":29},"end":{"line":62,"column":66}},"range":[1572,1609],"raw":"只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）"}],"loc":{"start":{"line":62,"column":27},"end":{"line":62,"column":68}},"range":[1570,1611],"raw":"**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**"},{"type":"Str","value":"，如果图中含有权值为负值的边，则可能不适用此算法。","loc":{"start":{"line":62,"column":68},"end":{"line":62,"column":93}},"range":[1611,1636],"raw":"，如果图中含有权值为负值的边，则可能不适用此算法。"}],"loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":93}},"range":[1543,1636],"raw":"由于Dijkstra算法是每一步都选择路径最短的顶点，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**，如果图中含有权值为负值的边，则可能不适用此算法。"},{"type":"Paragraph","children":[{"type":"Str","value":"例如如下的图，$0 \\rightarrow 1 \\rightarrow 2$ 路径长度就比 $0 \\rightarrow 2$的路径短，但是第一步时算法就会选择$2$，根本无法得到路径 $0 \\rightarrow 1 \\rightarrow 2$：","loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":125}},"range":[1638,1763],"raw":"例如如下的图，$0 \\rightarrow 1 \\rightarrow 2$ 路径长度就比 $0 \\rightarrow 2$的路径短，但是第一步时算法就会选择$2$，根本无法得到路径 $0 \\rightarrow 1 \\rightarrow 2$："}],"loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":125}},"range":[1638,1763],"raw":"例如如下的图，$0 \\rightarrow 1 \\rightarrow 2$ 路径长度就比 $0 \\rightarrow 2$的路径短，但是第一步时算法就会选择$2$，根本无法得到路径 $0 \\rightarrow 1 \\rightarrow 2$："},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png","alt":"PNG图像.png","loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":63}},"range":[1765,1828],"raw":"![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png)"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":63}},"range":[1765,1828],"raw":"![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png)"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Floyd（各顶点之间的最短路径）","loc":{"start":{"line":68,"column":3},"end":{"line":68,"column":20}},"range":[1833,1850],"raw":"Floyd（各顶点之间的最短路径）"}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":20}},"range":[1830,1850],"raw":"## Floyd（各顶点之间的最短路径）"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想（动态规划）：","loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":11}},"range":[1852,1863],"raw":"算法思想（动态规划）："}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":11}},"range":[1852,1863],"raw":"算法思想（动态规划）："},{"type":"Paragraph","children":[{"type":"Str","value":"递推产生一个n阶方阵序列$A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $，","loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":65}},"range":[1865,1930],"raw":"递推产生一个n阶方阵序列$A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $，"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":65}},"range":[1865,1930],"raw":"递推产生一个n阶方阵序列$A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $，"},{"type":"Paragraph","children":[{"type":"Str","value":"$A^{(k)}[i][j]$: 顶点$v_{i}$到$v_{j}$的最短路径长度，且该路径经过的顶点编号不大于k。","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":58}},"range":[1932,1990],"raw":"$A^{(k)}[i][j]$: 顶点$v_{i}$到$v_{j}$的最短路径长度，且该路径经过的顶点编号不大于k。"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":58}},"range":[1932,1990],"raw":"$A^{(k)}[i][j]$: 顶点$v_{i}$到$v_{j}$的最短路径长度，且该路径经过的顶点编号不大于k。"},{"type":"Paragraph","children":[{"type":"Str","value":"递推公式：","loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":5}},"range":[1992,1997],"raw":"递推公式："}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":5}},"range":[1992,1997],"raw":"递推公式："},{"type":"Paragraph","children":[{"type":"Str","value":"初始化：$A^{(-1)}[i][j]=arcs[i][j]$","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":31}},"range":[1999,2030],"raw":"初始化：$A^{(-1)}[i][j]=arcs[i][j]$"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":31}},"range":[1999,2030],"raw":"初始化：$A^{(-1)}[i][j]=arcs[i][j]$"},{"type":"Paragraph","children":[{"type":"Str","value":"递推方法：$A^{(k)}[i][j]=min\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\}, k=0,1,...,n-1$，其中$A^{(k-1)}[i][k]$就是从起始顶点到顶点k的路径，$A^{(k-1)}[k][j]$就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。","loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":225}},"range":[2032,2257],"raw":"递推方法：$A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1$，其中$A^{(k-1)}[i][k]$就是从起始顶点到顶点k的路径，$A^{(k-1)}[k][j]$就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":225}},"range":[2032,2257],"raw":"递推方法：$A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1$，其中$A^{(k-1)}[i][k]$就是从起始顶点到顶点k的路径，$A^{(k-1)}[k][j]$就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}","loc":{"start":{"line":82,"column":0},"end":{"line":102,"column":3}},"range":[2259,2697],"raw":"```c\n#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"Floyd算法的时间复杂度是$O(\\lvert V \\rvert ^ {3})$，可以算出任意两个结点之间的最短路径，且可以包含负值。","loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":67}},"range":[2699,2766],"raw":"Floyd算法的时间复杂度是$O(\\lvert V \\rvert ^ {3})$，可以算出任意两个结点之间的最短路径，且可以包含负值。"}],"loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":67}},"range":[2699,2766],"raw":"Floyd算法的时间复杂度是$O(\\lvert V \\rvert ^ {3})$，可以算出任意两个结点之间的最短路径，且可以包含负值。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":105,"column":0}},"range":[0,2767],"raw":"---\ntags: ['数据结构','图']\n---\n# 最短路径\n\n## Dijkstra算法（带权图单源最短路径）\n\n主要的思想也是**贪心算法**。\n\n需要如下的三个辅助数组：\n\n- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1\n- dist[]: 记录从源点$v_{0}$到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即$dist[i]=arcs[0][i]$\n- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为$v \\rightarrow v_{i}$\n最短路径上$v_{i}$的前驱顶点。\n  初始化：若源点$v_{0}$到该顶点$v_{i}$有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。\n\n算法步骤：\n\n1. 初始化数组，集合S初始化为{0};\n2. 从未计算过的顶点集V-S中选出$V_{j}$满足：$dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$，$v_{j}$就是当前求得的最短路径的终点，使$S = S \\cup \\{j\\}$;\n3. 修改此时从$v_{0}$出发到集合V-S上各个顶点$v_{k}$最短路径的长度：若$dist[j]+arcs[j][k]<dist[k]$，则令$dist[k] = dist[j] + arcs[j][k]$; $path[k] = j$。\n\n```c\n#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}\n```\n\n代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是$O(\\lvert V \\rvert ^ {2})$。\n\n由于Dijkstra算法是每一步都选择路径最短的顶点，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**，如果图中含有权值为负值的边，则可能不适用此算法。\n\n例如如下的图，$0 \\rightarrow 1 \\rightarrow 2$ 路径长度就比 $0 \\rightarrow 2$的路径短，但是第一步时算法就会选择$2$，根本无法得到路径 $0 \\rightarrow 1 \\rightarrow 2$：\n\n![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png)\n\n## Floyd（各顶点之间的最短路径）\n\n算法思想（动态规划）：\n\n递推产生一个n阶方阵序列$A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $，\n\n$A^{(k)}[i][j]$: 顶点$v_{i}$到$v_{j}$的最短路径长度，且该路径经过的顶点编号不大于k。\n\n递推公式：\n\n初始化：$A^{(-1)}[i][j]=arcs[i][j]$\n\n递推方法：$A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1$，其中$A^{(k-1)}[i][k]$就是从起始顶点到顶点k的路径，$A^{(k-1)}[k][j]$就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。\n\n```c\n#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}\n```\n\nFloyd算法的时间复杂度是$O(\\lvert V \\rvert ^ {3})$，可以算出任意两个结点之间的最短路径，且可以包含负值。\n"},"catalogue":{"title":"2020-08-02-最短路径","json-path":"2020-08-02-最短路径.json","mdate":"2022-08-30T14:19:31.450Z","tags":["数据结构","图"]}}