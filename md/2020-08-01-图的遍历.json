{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','图']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','图']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"图的遍历","loc":{"start":{"line":4,"column":2},"end":{"line":4,"column":6}},"range":[29,33],"raw":"图的遍历"}],"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":6}},"range":[27,33],"raw":"# 图的遍历"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。","loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":43}},"range":[35,78],"raw":"从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":43}},"range":[35,78],"raw":"从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。"},{"type":"Paragraph","children":[{"type":"Str","value":"由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记$v_{i}$是否被访问过。","loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":86}},"range":[80,166],"raw":"由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记$v_{i}$是否被访问过。"}],"loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":86}},"range":[80,166],"raw":"由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记$v_{i}$是否被访问过。"},{"type":"Paragraph","children":[{"type":"Str","value":"对于有向图和无向图，都有","loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[168,180],"raw":"对于有向图和无向图，都有"},{"type":"Strong","children":[{"type":"Str","value":"深度优先搜索、广度优先搜索","loc":{"start":{"line":10,"column":14},"end":{"line":10,"column":27}},"range":[182,195],"raw":"深度优先搜索、广度优先搜索"}],"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":29}},"range":[180,197],"raw":"**深度优先搜索、广度优先搜索**"},{"type":"Str","value":"。","loc":{"start":{"line":10,"column":29},"end":{"line":10,"column":30}},"range":[197,198],"raw":"。"}],"loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":30}},"range":[168,198],"raw":"对于有向图和无向图，都有**深度优先搜索、广度优先搜索**。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"深度优先搜索","loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":9}},"range":[203,209],"raw":"深度优先搜索"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":9}},"range":[200,209],"raw":"## 深度优先搜索"},{"type":"Paragraph","children":[{"type":"Str","value":"类似于树的先根遍历，是树的先根遍历的推广。","loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":21}},"range":[211,232],"raw":"类似于树的先根遍历，是树的先根遍历的推广。"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":21}},"range":[211,232],"raw":"类似于树的先根遍历，是树的先根遍历的推广。"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。","loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":118}},"range":[234,352],"raw":"从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":118}},"range":[234,352],"raw":"从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}","loc":{"start":{"line":18,"column":0},"end":{"line":41,"column":3}},"range":[354,884],"raw":"```c\n#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。","loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":37}},"range":[886,923],"raw":"图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":37}},"range":[886,923],"raw":"图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。"},{"type":"Paragraph","children":[{"type":"Str","value":"对于n个顶点e条边的图：","loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":12}},"range":[925,937],"raw":"对于n个顶点e条边的图："}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":12}},"range":[925,937],"raw":"对于n个顶点e条边的图："},{"type":"Paragraph","children":[{"type":"Str","value":"使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n^{2})$","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":51}},"range":[939,990],"raw":"使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n^{2})$"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":51}},"range":[939,990],"raw":"使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n^{2})$"},{"type":"Paragraph","children":[{"type":"Str","value":"使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n)$","loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":40}},"range":[992,1032],"raw":"使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n)$"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":40}},"range":[992,1032],"raw":"使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n)$"},{"type":"Paragraph","children":[{"type":"Str","value":"当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。","loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":40}},"range":[1034,1074],"raw":"当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。"}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":40}},"range":[1034,1074],"raw":"当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"广度优先搜索","loc":{"start":{"line":53,"column":3},"end":{"line":53,"column":9}},"range":[1079,1085],"raw":"广度优先搜索"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":9}},"range":[1076,1085],"raw":"## 广度优先搜索"},{"type":"Paragraph","children":[{"type":"Str","value":"类似于树的按层次遍历的过程","loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":13}},"range":[1087,1100],"raw":"类似于树的按层次遍历的过程"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":13}},"range":[1087,1100],"raw":"类似于树的按层次遍历的过程"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。","loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":137}},"range":[1102,1239],"raw":"从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":137}},"range":[1102,1239],"raw":"从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}","loc":{"start":{"line":59,"column":0},"end":{"line":80,"column":3}},"range":[1241,1837],"raw":"```c\nvoid BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":60}},"range":[1839,1899],"raw":"实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":60}},"range":[1839,1899],"raw":"实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":83,"column":0}},"range":[0,1900],"raw":"---\ntags: ['数据结构','图']\n---\n# 图的遍历\n\n从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。\n\n由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记$v_{i}$是否被访问过。\n\n对于有向图和无向图，都有**深度优先搜索、广度优先搜索**。\n\n## 深度优先搜索\n\n类似于树的先根遍历，是树的先根遍历的推广。\n\n从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。\n\n```c\n#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}\n```\n\n图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。\n\n对于n个顶点e条边的图：\n\n使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n^{2})$\n\n使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为$O(n)$\n\n当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为$O(n+e)$。\n\n## 广度优先搜索\n\n类似于树的按层次遍历的过程\n\n从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。\n\n```c\nvoid BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}\n```\n\n实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。\n"},"catalogue":{"title":"2020-08-01-图的遍历","json-path":"2020-08-01-图的遍历.json","mdate":"2022-08-30T14:19:31.450Z","tags":["数据结构","图"]}}