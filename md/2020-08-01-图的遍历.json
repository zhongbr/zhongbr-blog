{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','图']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"﻿---\ntags: ['数据结构','图']\n--"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"图的遍历","loc":{"start":{"line":4,"column":2},"end":{"line":4,"column":6}},"range":[29,33],"raw":" 图的遍"}],"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":6}},"range":[27,33],"raw":"\n# 图的遍"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。","loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":43}},"range":[35,78],"raw":"\n从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":43}},"range":[35,78],"raw":"\n从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历"},{"type":"Paragraph","children":[{"type":"Str","value":"由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记 ","loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":73}},"range":[80,153],"raw":"\n由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记"},{"type":"InlineMath","value":"v_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{i}"}]},"loc":{"start":{"line":8,"column":73},"end":{"line":8,"column":80}},"range":[153,160],"raw":" $v_{i}"},{"type":"Str","value":" 是否被访问过。","loc":{"start":{"line":8,"column":80},"end":{"line":8,"column":88}},"range":[160,168],"raw":"$ 是否被访问过"}],"loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":88}},"range":[80,168],"raw":"\n由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记 $v_{i}$ 是否被访问过"},{"type":"Paragraph","children":[{"type":"Str","value":"对于有向图和无向图，都有","loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[170,182],"raw":"\n对于有向图和无向图，都"},{"type":"Strong","children":[{"type":"Str","value":"深度优先搜索、广度优先搜索","loc":{"start":{"line":10,"column":14},"end":{"line":10,"column":27}},"range":[184,197],"raw":"*深度优先搜索、广度优先搜"}],"loc":{"start":{"line":10,"column":12},"end":{"line":10,"column":29}},"range":[182,199],"raw":"有**深度优先搜索、广度优先搜索*"},{"type":"Str","value":"。","loc":{"start":{"line":10,"column":29},"end":{"line":10,"column":30}},"range":[199,200],"raw":"*"}],"loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":30}},"range":[170,200],"raw":"\n对于有向图和无向图，都有**深度优先搜索、广度优先搜索**"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"深度优先搜索","loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":9}},"range":[205,211],"raw":" 深度优先搜"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":9}},"range":[202,211],"raw":"\n## 深度优先搜"},{"type":"Paragraph","children":[{"type":"Str","value":"类似于树的先根遍历，是树的先根遍历的推广。","loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":21}},"range":[213,234],"raw":"\n类似于树的先根遍历，是树的先根遍历的推广"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":21}},"range":[213,234],"raw":"\n类似于树的先根遍历，是树的先根遍历的推广"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。","loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":118}},"range":[236,354],"raw":"\n从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":118}},"range":[236,354],"raw":"\n从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}","loc":{"start":{"line":18,"column":0},"end":{"line":41,"column":3}},"range":[356,886],"raw":"\n```c\n#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}\n``"},{"type":"Paragraph","children":[{"type":"Str","value":"图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。","loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":37}},"range":[888,925],"raw":"\n图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":37}},"range":[888,925],"raw":"\n图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关"},{"type":"Paragraph","children":[{"type":"Str","value":"对于n个顶点e条边的图：","loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":12}},"range":[927,939],"raw":"\n对于n个顶点e条边的图"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":12}},"range":[927,939],"raw":"\n对于n个顶点e条边的图"},{"type":"Paragraph","children":[{"type":"Str","value":"使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为 ","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":42}},"range":[941,983],"raw":"\n使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为"},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":47,"column":42},"end":{"line":47,"column":52}},"range":[983,993],"raw":" $O(n^{2})"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":53}},"range":[941,994],"raw":"\n使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为 $O(n^{2})$"},{"type":"Paragraph","children":[{"type":"Str","value":"使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为 ","loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":35}},"range":[996,1031],"raw":"\n使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为"},{"type":"InlineMath","value":"O(n)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n)"}]},"loc":{"start":{"line":49,"column":35},"end":{"line":49,"column":41}},"range":[1031,1037],"raw":" $O(n)"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":42}},"range":[996,1038],"raw":"\n使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为 $O(n)$"},{"type":"Paragraph","children":[{"type":"Str","value":"当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为 ","loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":32}},"range":[1040,1072],"raw":"\n当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为"},{"type":"InlineMath","value":"O(n+e)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n+e)"}]},"loc":{"start":{"line":51,"column":32},"end":{"line":51,"column":40}},"range":[1072,1080],"raw":" $O(n+e)"},{"type":"Str","value":" 。","loc":{"start":{"line":51,"column":40},"end":{"line":51,"column":42}},"range":[1080,1082],"raw":"$ "}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":42}},"range":[1040,1082],"raw":"\n当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为 $O(n+e)$ "},{"type":"Header","depth":2,"children":[{"type":"Str","value":"广度优先搜索","loc":{"start":{"line":53,"column":3},"end":{"line":53,"column":9}},"range":[1087,1093],"raw":" 广度优先搜"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":9}},"range":[1084,1093],"raw":"\n## 广度优先搜"},{"type":"Paragraph","children":[{"type":"Str","value":"类似于树的按层次遍历的过程","loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":13}},"range":[1095,1108],"raw":"\n类似于树的按层次遍历的过"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":13}},"range":[1095,1108],"raw":"\n类似于树的按层次遍历的过"},{"type":"Paragraph","children":[{"type":"Str","value":"从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。","loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":137}},"range":[1110,1247],"raw":"\n从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":137}},"range":[1110,1247],"raw":"\n从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}","loc":{"start":{"line":59,"column":0},"end":{"line":80,"column":3}},"range":[1249,1845],"raw":"\n```c\nvoid BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}\n``"},{"type":"Paragraph","children":[{"type":"Str","value":"实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":60}},"range":[1847,1907],"raw":"\n实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":60}},"range":[1847,1907],"raw":"\n实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同"}],"loc":{"start":{"line":1,"column":0},"end":{"line":83,"column":0}},"range":[0,1908],"raw":"﻿---\ntags: ['数据结构','图']\n---\n# 图的遍历\n\n从图的一个顶点出发，访问图中其余顶点，且每个顶点有且仅有访问一次，这一过程被成为遍历。\n\n由于图中存在环路，在遍历图的时候，为了避免一个顶点被访问多次，可以建立一个数组visited[0..n-1]，用visited[i]的真假来标记 $v_{i}$ 是否被访问过。\n\n对于有向图和无向图，都有**深度优先搜索、广度优先搜索**。\n\n## 深度优先搜索\n\n类似于树的先根遍历，是树的先根遍历的推广。\n\n从图的某个顶点v出发，访问此顶点，然后依次从v的未访问的邻接点出发，深度优先遍历图，直至图中所有和v相连通的顶点都被访问到。若此时图中仍有未访问到的顶点，则重新选取一个未曾访问的顶点作为起点，重复此过程，直至所有的顶点都被访问一次为止。\n\n```c\n#define true 1\n#define false 0\n#define MAX 100\n\ntypedef Boolean int;\n\nBoolean visited[MAX];\nStatus (*VisitCallback)(int v); // 访问顶点的回调\n\nvoid DFS(Graph g, int v){\n    visited[v] = true;\n    VisitCallback(v); // 访问顶点\n    for(int w = FirstAdjVex(g,v); w > 0; w = NextAdjVex(g,v,w)){\n        if(!visited[w]) DFS(g, w);\n    }\n}\n\nint DFSTraverse(Graph g, Status (*Callback)(int)){\n    VisitCallback = Callback;\n    for(int v = 0; v < g.vexnum; v++) visited = false; // 初始化辅助数组\n    for(int v = 0; v < g.vexnum; v++) DFS(g, v);\n}\n```\n\n图的遍历实质上是对每个顶点寻找其邻接点的过程，耗费的时间与其存储结构有关。\n\n对于n个顶点e条边的图：\n\n使用二维数组表示邻接矩阵作图表示图的存储结构时：查找每个顶点的邻接点的时间复杂度为 $O(n^{2})$ \n\n使用邻接链表表示作图的存储结构时：查找每个顶点的邻接点的时间复杂度为 $O(n)$ \n\n当以邻接表作为图的存储结构时，深度优先搜索遍历图的时间复杂度为 $O(n+e)$ 。\n\n## 广度优先搜索\n\n类似于树的按层次遍历的过程\n\n从图的某个顶点v出发，访问此顶点，然后一次访问v的未曾访问过的邻接点，然后依次从这些邻接点出发，访问他们的邻接点，直至所有的已被访问过的顶点的邻接点都被访问一次，如果此时图中仍有未曾被访问过的结点，从新选取一个顶点出发，重复上述过程，知道图中所有的顶点都被访问过一次后为止。\n\n```c\nvoid BFSTraverse (Graph g, Status(*VisitCallback)(int v)){\n    Queue Q;\n    for(int v=0;v<g.vexnum;v++) visited[i] = false;\n    InitQueue(&Q);\n    for(v=0;v<g.vexnum;v++){\n        if(visited[v]) continue;\n        visited[v] = true;\n        VisitCallback(v);\n        EnQueue(&Q, v);\n        while(!QueueEmpty(&Q)) {\n            DeQueue(&Q, &u);\n            for(w = FirstAdjVex(g, u); w > 0; w = NextAdjVex(g, u, w)){\n                if(visited[w]) continue;\n                visited[w] = true;\n                VisitCallback(w);\n                EnQueue(Q,W);\n            }\n        }\n    }\n}\n```\n\n实质上是通过边或弧，寻找顶点的邻接点的过程，时间复杂度与深度优先搜索相同，两种遍历方式的区别仅仅时在访问顶点的顺序不同。"},"catalogue":{"title":"图的遍历","json-path":"图的遍历.json","mdate":"2022-12-31T15:02:04.610Z","cover":"https://i.328888.xyz/2022/12/31/nd2oZ.jpeg","tags":["数据结构","图"]}}