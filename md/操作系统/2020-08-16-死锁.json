{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '死锁'\ntags: ['操作系统','死锁']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,39],"raw":"﻿---\ntitle: '死锁'\ntags: ['操作系统','死锁']\n--","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"死锁","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":4}},"range":[42,44],"raw":" 死"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":4}},"range":[40,44],"raw":"\n# 死"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"死锁、饥饿和死循环","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":12}},"range":[49,58],"raw":" 死锁、饥饿和死循"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":12}},"range":[46,58],"raw":"\n## 死锁、饥饿和死循"},{"type":"List","ordered":false,"start":null,"spread":true,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”。","loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":59}},"range":[62,119],"raw":" 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”"}],"loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":59}},"range":[62,119],"raw":" 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":59}},"range":[60,119],"raw":"\n- 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象。","loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":34}},"range":[123,155],"raw":" 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":34}},"range":[123,155],"raw":" 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":34}},"range":[121,155],"raw":"\n- 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的。","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":52}},"range":[159,209],"raw":" 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":52}},"range":[159,209],"raw":" 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":52}},"range":[157,209],"raw":"\n- 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的"}],"loc":{"start":{"line":9,"column":0},"end":{"line":13,"column":52}},"range":[60,209],"raw":"\n- 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”。\n\n- 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象。\n\n- 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的"},{"type":"Paragraph","children":[{"type":"Str","value":"共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。","loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":32}},"range":[211,243],"raw":"\n共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":32}},"range":[211,243],"raw":"\n共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）"},{"type":"Paragraph","children":[{"type":"Str","value":"差异：","loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":3}},"range":[245,248],"raw":"\n差异"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":3}},"range":[245,248],"raw":"\n差异"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"死锁：至少发生在两个或者两个以上的进程上，","loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":23}},"range":[252,273],"raw":" 死锁：至少发生在两个或者两个以上的进程上"},{"type":"Strong","children":[{"type":"Str","value":"发生死锁的进程一定处于阻塞态","loc":{"start":{"line":19,"column":25},"end":{"line":19,"column":39}},"range":[275,289],"raw":"*发生死锁的进程一定处于阻塞"}],"loc":{"start":{"line":19,"column":23},"end":{"line":19,"column":41}},"range":[273,291],"raw":"，**发生死锁的进程一定处于阻塞态*"},{"type":"Str","value":"。","loc":{"start":{"line":19,"column":41},"end":{"line":19,"column":42}},"range":[291,292],"raw":"*"}],"loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":42}},"range":[252,292],"raw":" 死锁：至少发生在两个或者两个以上的进程上，**发生死锁的进程一定处于阻塞态**"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":42}},"range":[250,292],"raw":"\n- 死锁：至少发生在两个或者两个以上的进程上，**发生死锁的进程一定处于阻塞态**"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机）","loc":{"start":{"line":20,"column":2},"end":{"line":20,"column":63}},"range":[295,356],"raw":" 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机"}],"loc":{"start":{"line":20,"column":2},"end":{"line":20,"column":63}},"range":[295,356],"raw":" 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机"}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":63}},"range":[293,356],"raw":"\n- 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而","loc":{"start":{"line":21,"column":2},"end":{"line":21,"column":71}},"range":[359,428],"raw":" 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，"},{"type":"Strong","children":[{"type":"Str","value":"死循环是由于代码的逻辑错误导致的","loc":{"start":{"line":21,"column":73},"end":{"line":21,"column":89}},"range":[430,446],"raw":"*死循环是由于代码的逻辑错误导致"}],"loc":{"start":{"line":21,"column":71},"end":{"line":21,"column":91}},"range":[428,448],"raw":"而**死循环是由于代码的逻辑错误导致的*"},{"type":"Str","value":"。","loc":{"start":{"line":21,"column":91},"end":{"line":21,"column":92}},"range":[448,449],"raw":"*"}],"loc":{"start":{"line":21,"column":2},"end":{"line":21,"column":92}},"range":[359,449],"raw":" 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而**死循环是由于代码的逻辑错误导致的**"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":92}},"range":[357,449],"raw":"\n- 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而**死循环是由于代码的逻辑错误导致的**"}],"loc":{"start":{"line":19,"column":0},"end":{"line":21,"column":92}},"range":[250,449],"raw":"\n- 死锁：至少发生在两个或者两个以上的进程上，**发生死锁的进程一定处于阻塞态**。\n- 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机）\n- 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而**死循环是由于代码的逻辑错误导致的**"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"死锁产生的条件","loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":10}},"range":[454,461],"raw":" 死锁产生的条"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":10}},"range":[451,461],"raw":"\n## 死锁产生的条"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死锁","loc":{"start":{"line":25,"column":3},"end":{"line":25,"column":33}},"range":[466,496],"raw":" 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死"}],"loc":{"start":{"line":25,"column":3},"end":{"line":25,"column":33}},"range":[466,496],"raw":" 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":33}},"range":[463,496],"raw":"\n1. 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释放","loc":{"start":{"line":26,"column":3},"end":{"line":26,"column":46}},"range":[500,543],"raw":" 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释"}],"loc":{"start":{"line":26,"column":3},"end":{"line":26,"column":46}},"range":[500,543],"raw":" 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释"}],"loc":{"start":{"line":26,"column":0},"end":{"line":26,"column":46}},"range":[497,543],"raw":"\n2. 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放。","loc":{"start":{"line":27,"column":3},"end":{"line":27,"column":74}},"range":[547,618],"raw":" 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放"}],"loc":{"start":{"line":27,"column":3},"end":{"line":27,"column":74}},"range":[547,618],"raw":" 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":74}},"range":[544,618],"raw":"\n3. 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求。","loc":{"start":{"line":28,"column":3},"end":{"line":28,"column":43}},"range":[622,662],"raw":" 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求"}],"loc":{"start":{"line":28,"column":3},"end":{"line":28,"column":43}},"range":[622,662],"raw":" 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求"}],"loc":{"start":{"line":28,"column":0},"end":{"line":28,"column":43}},"range":[619,662],"raw":"\n4. 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求"}],"loc":{"start":{"line":25,"column":0},"end":{"line":28,"column":43}},"range":[463,662],"raw":"\n1. 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死锁\n2. 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释放\n3. 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放。\n4. 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求"},{"type":"Paragraph","children":[{"type":"Str","value":"满足上面的四个条件不一定会发生死锁，但是发生死锁的时候一定会满足上面的四个条件，满足上面的四个条件是产生死锁的","loc":{"start":{"line":30,"column":0},"end":{"line":30,"column":55}},"range":[664,719],"raw":"\n满足上面的四个条件不一定会发生死锁，但是发生死锁的时候一定会满足上面的四个条件，满足上面的四个条件是产生死锁"},{"type":"Strong","children":[{"type":"Str","value":"必要不充分条件","loc":{"start":{"line":30,"column":57},"end":{"line":30,"column":64}},"range":[721,728],"raw":"*必要不充分条"}],"loc":{"start":{"line":30,"column":55},"end":{"line":30,"column":66}},"range":[719,730],"raw":"的**必要不充分条件*"},{"type":"Str","value":"。","loc":{"start":{"line":30,"column":66},"end":{"line":30,"column":67}},"range":[730,731],"raw":"*"}],"loc":{"start":{"line":30,"column":0},"end":{"line":30,"column":67}},"range":[664,731],"raw":"\n满足上面的四个条件不一定会发生死锁，但是发生死锁的时候一定会满足上面的四个条件，满足上面的四个条件是产生死锁的**必要不充分条件**"},{"type":"Paragraph","children":[{"type":"Str","value":"死锁发生在：","loc":{"start":{"line":32,"column":0},"end":{"line":32,"column":6}},"range":[733,739],"raw":"\n死锁发生在"}],"loc":{"start":{"line":32,"column":0},"end":{"line":32,"column":6}},"range":[733,739],"raw":"\n死锁发生在"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁。","loc":{"start":{"line":34,"column":3},"end":{"line":34,"column":52}},"range":[744,793],"raw":" 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁"}],"loc":{"start":{"line":34,"column":3},"end":{"line":34,"column":52}},"range":[744,793],"raw":" 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁"}],"loc":{"start":{"line":34,"column":0},"end":{"line":34,"column":52}},"range":[741,793],"raw":"\n1. 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁。","loc":{"start":{"line":35,"column":3},"end":{"line":35,"column":31}},"range":[797,825],"raw":" 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁"}],"loc":{"start":{"line":35,"column":3},"end":{"line":35,"column":31}},"range":[797,825],"raw":" 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁"}],"loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":31}},"range":[794,825],"raw":"\n2. 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"信号量使用不当：信号量使用不当的时候可能产生死锁","loc":{"start":{"line":36,"column":3},"end":{"line":36,"column":27}},"range":[829,853],"raw":" 信号量使用不当：信号量使用不当的时候可能产生死"}],"loc":{"start":{"line":36,"column":3},"end":{"line":36,"column":27}},"range":[829,853],"raw":" 信号量使用不当：信号量使用不当的时候可能产生死"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":27}},"range":[826,853],"raw":"\n3. 信号量使用不当：信号量使用不当的时候可能产生死"}],"loc":{"start":{"line":34,"column":0},"end":{"line":36,"column":27}},"range":[741,853],"raw":"\n1. 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁。\n2. 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁。\n3. 信号量使用不当：信号量使用不当的时候可能产生死"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"死锁的处理策略","loc":{"start":{"line":38,"column":3},"end":{"line":38,"column":10}},"range":[858,865],"raw":" 死锁的处理策"}],"loc":{"start":{"line":38,"column":0},"end":{"line":38,"column":10}},"range":[855,865],"raw":"\n## 死锁的处理策"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"预防死锁：破坏产生死锁的四个必要条件的一个或者几个","loc":{"start":{"line":40,"column":3},"end":{"line":40,"column":28}},"range":[870,895],"raw":" 预防死锁：破坏产生死锁的四个必要条件的一个或者几"}],"loc":{"start":{"line":40,"column":3},"end":{"line":40,"column":28}},"range":[870,895],"raw":" 预防死锁：破坏产生死锁的四个必要条件的一个或者几"}],"loc":{"start":{"line":40,"column":0},"end":{"line":40,"column":28}},"range":[867,895],"raw":"\n1. 预防死锁：破坏产生死锁的四个必要条件的一个或者几"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法）","loc":{"start":{"line":41,"column":3},"end":{"line":41,"column":39}},"range":[899,935],"raw":" 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法"}],"loc":{"start":{"line":41,"column":3},"end":{"line":41,"column":39}},"range":[899,935],"raw":" 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法"}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":39}},"range":[896,935],"raw":"\n2. 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁。","loc":{"start":{"line":42,"column":3},"end":{"line":42,"column":48}},"range":[939,984],"raw":" 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁"}],"loc":{"start":{"line":42,"column":3},"end":{"line":42,"column":48}},"range":[939,984],"raw":" 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁"}],"loc":{"start":{"line":42,"column":0},"end":{"line":42,"column":48}},"range":[936,984],"raw":"\n3. 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁"}],"loc":{"start":{"line":40,"column":0},"end":{"line":42,"column":48}},"range":[867,984],"raw":"\n1. 预防死锁：破坏产生死锁的四个必要条件的一个或者几个\n2. 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法）\n3. 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁"},{"type":"HorizontalRule","loc":{"start":{"line":44,"column":0},"end":{"line":44,"column":4}},"range":[986,990],"raw":"\n***"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"预防死锁","loc":{"start":{"line":46,"column":4},"end":{"line":46,"column":8}},"range":[996,1000],"raw":" 预防死"}],"loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":8}},"range":[992,1000],"raw":"\n### 预防死"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"破坏互斥条件","loc":{"start":{"line":48,"column":5},"end":{"line":48,"column":11}},"range":[1007,1013],"raw":" 破坏互斥条"}],"loc":{"start":{"line":48,"column":0},"end":{"line":48,"column":11}},"range":[1002,1013],"raw":"\n#### 破坏互斥条"},{"type":"Paragraph","children":[{"type":"Str","value":"把只能互斥使用的资源改造为允许共享使用的资源，系统就不会进入死锁状态，比如：SPOOLing技术","loc":{"start":{"line":50,"column":0},"end":{"line":50,"column":48}},"range":[1015,1063],"raw":"\n把只能互斥使用的资源改造为允许共享使用的资源，系统就不会进入死锁状态，比如：SPOOLing技"}],"loc":{"start":{"line":50,"column":0},"end":{"line":50,"column":48}},"range":[1015,1063],"raw":"\n把只能互斥使用的资源改造为允许共享使用的资源，系统就不会进入死锁状态，比如：SPOOLing技"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：不是所有得资源都可以改造为可共享使用得资源，并且可能为了系统安全，很多资源必须保护这种互斥性。","loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":50}},"range":[1065,1115],"raw":"\n缺点：不是所有得资源都可以改造为可共享使用得资源，并且可能为了系统安全，很多资源必须保护这种互斥性"},{"type":"Strong","children":[{"type":"Str","value":"很多时候都无法破会互斥条件","loc":{"start":{"line":52,"column":52},"end":{"line":52,"column":65}},"range":[1117,1130],"raw":"*很多时候都无法破会互斥条"}],"loc":{"start":{"line":52,"column":50},"end":{"line":52,"column":67}},"range":[1115,1132],"raw":"。**很多时候都无法破会互斥条件*"},{"type":"Str","value":"。","loc":{"start":{"line":52,"column":67},"end":{"line":52,"column":68}},"range":[1132,1133],"raw":"*"}],"loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":68}},"range":[1065,1133],"raw":"\n缺点：不是所有得资源都可以改造为可共享使用得资源，并且可能为了系统安全，很多资源必须保护这种互斥性。**很多时候都无法破会互斥条件**"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"破坏不可剥夺条件","loc":{"start":{"line":54,"column":5},"end":{"line":54,"column":13}},"range":[1140,1148],"raw":" 破坏不可剥夺条"}],"loc":{"start":{"line":54,"column":0},"end":{"line":54,"column":13}},"range":[1135,1148],"raw":"\n#### 破坏不可剥夺条"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条件","loc":{"start":{"line":56,"column":2},"end":{"line":56,"column":86}},"range":[1152,1236],"raw":" 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条"}],"loc":{"start":{"line":56,"column":2},"end":{"line":56,"column":86}},"range":[1152,1236],"raw":" 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":86}},"range":[1150,1236],"raw":"\n- 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级。","loc":{"start":{"line":57,"column":2},"end":{"line":57,"column":61}},"range":[1239,1298],"raw":" 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级"}],"loc":{"start":{"line":57,"column":2},"end":{"line":57,"column":61}},"range":[1239,1298],"raw":" 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":61}},"range":[1237,1298],"raw":"\n- 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级"}],"loc":{"start":{"line":56,"column":0},"end":{"line":57,"column":61}},"range":[1150,1298],"raw":"\n- 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条件\n- 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：","loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":3}},"range":[1300,1303],"raw":"\n缺点"}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":3}},"range":[1300,1303],"raw":"\n缺点"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"实现复杂","loc":{"start":{"line":61,"column":3},"end":{"line":61,"column":7}},"range":[1308,1312],"raw":" 实现复"}],"loc":{"start":{"line":61,"column":3},"end":{"line":61,"column":7}},"range":[1308,1312],"raw":" 实现复"}],"loc":{"start":{"line":61,"column":0},"end":{"line":61,"column":7}},"range":[1305,1312],"raw":"\n1. 实现复"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU。","loc":{"start":{"line":62,"column":3},"end":{"line":62,"column":47}},"range":[1316,1360],"raw":" 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU"}],"loc":{"start":{"line":62,"column":3},"end":{"line":62,"column":47}},"range":[1316,1360],"raw":" 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU"}],"loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":47}},"range":[1313,1360],"raw":"\n2. 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"反复申请资源会导致系统开销增大，降低系统的吞吐量","loc":{"start":{"line":63,"column":3},"end":{"line":63,"column":27}},"range":[1364,1388],"raw":" 反复申请资源会导致系统开销增大，降低系统的吞吐"}],"loc":{"start":{"line":63,"column":3},"end":{"line":63,"column":27}},"range":[1364,1388],"raw":" 反复申请资源会导致系统开销增大，降低系统的吞吐"}],"loc":{"start":{"line":63,"column":0},"end":{"line":63,"column":27}},"range":[1361,1388],"raw":"\n3. 反复申请资源会导致系统开销增大，降低系统的吞吐"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿。","loc":{"start":{"line":64,"column":3},"end":{"line":64,"column":66}},"range":[1392,1455],"raw":" 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿"}],"loc":{"start":{"line":64,"column":3},"end":{"line":64,"column":66}},"range":[1392,1455],"raw":" 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿"}],"loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":66}},"range":[1389,1455],"raw":"\n4. 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿"}],"loc":{"start":{"line":61,"column":0},"end":{"line":64,"column":66}},"range":[1305,1455],"raw":"\n1. 实现复杂\n2. 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU。\n3. 反复申请资源会导致系统开销增大，降低系统的吞吐量\n4. 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"破坏请求和保持条件","loc":{"start":{"line":66,"column":5},"end":{"line":66,"column":14}},"range":[1462,1471],"raw":" 破坏请求和保持条"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":14}},"range":[1457,1471],"raw":"\n#### 破坏请求和保持条"},{"type":"Paragraph","children":[{"type":"Str","value":"采用","loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":2}},"range":[1473,1475],"raw":"\n采"},{"type":"Strong","children":[{"type":"Str","value":"静态分配的方法","loc":{"start":{"line":68,"column":4},"end":{"line":68,"column":11}},"range":[1477,1484],"raw":"*静态分配的方"}],"loc":{"start":{"line":68,"column":2},"end":{"line":68,"column":13}},"range":[1475,1486],"raw":"用**静态分配的方法*"},{"type":"Str","value":"，在进程运行前就分配给它所有需要的资源，在资源未得到满足之前，进程不会投入运行，进程一旦投入运行，这些资源就归它所有，直到进程运行结束，该进程在运行过程中不会请求别的任何资源。","loc":{"start":{"line":68,"column":13},"end":{"line":68,"column":101}},"range":[1486,1574],"raw":"*，在进程运行前就分配给它所有需要的资源，在资源未得到满足之前，进程不会投入运行，进程一旦投入运行，这些资源就归它所有，直到进程运行结束，该进程在运行过程中不会请求别的任何资源"}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":101}},"range":[1473,1574],"raw":"\n采用**静态分配的方法**，在进程运行前就分配给它所有需要的资源，在资源未得到满足之前，进程不会投入运行，进程一旦投入运行，这些资源就归它所有，直到进程运行结束，该进程在运行过程中不会请求别的任何资源"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：实现简单","loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":7}},"range":[1576,1583],"raw":"\n优点：实现简"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":7}},"range":[1576,1583],"raw":"\n优点：实现简"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：有些资源，进程可能只会使用很短的时间，如果进程整个运行期间都保持着所有的资源，会造成艳照那个的资源浪费，资源利用率极低，导致其他的进程饥饿。","loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":73}},"range":[1585,1658],"raw":"\n缺点：有些资源，进程可能只会使用很短的时间，如果进程整个运行期间都保持着所有的资源，会造成艳照那个的资源浪费，资源利用率极低，导致其他的进程饥饿"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":73}},"range":[1585,1658],"raw":"\n缺点：有些资源，进程可能只会使用很短的时间，如果进程整个运行期间都保持着所有的资源，会造成艳照那个的资源浪费，资源利用率极低，导致其他的进程饥饿"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"破坏循环等待条件","loc":{"start":{"line":74,"column":5},"end":{"line":74,"column":13}},"range":[1665,1673],"raw":" 破坏循环等待条"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":13}},"range":[1660,1673],"raw":"\n#### 破坏循环等待条"},{"type":"Paragraph","children":[{"type":"Str","value":"采用顺序资源分配，给系统中所有的资源编号，每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）依次申请完。","loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":60}},"range":[1675,1735],"raw":"\n采用顺序资源分配，给系统中所有的资源编号，每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）依次申请完"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":60}},"range":[1675,1735],"raw":"\n采用顺序资源分配，给系统中所有的资源编号，每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）依次申请完"},{"type":"Paragraph","children":[{"type":"Str","value":"原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":84}},"range":[1737,1821],"raw":"\n原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":84}},"range":[1737,1821],"raw":"\n原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：","loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":3}},"range":[1823,1826],"raw":"\n缺点"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":3}},"range":[1823,1826],"raw":"\n缺点"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"不方便添加新的资源，可能需要重新分配所有的编号","loc":{"start":{"line":82,"column":3},"end":{"line":82,"column":26}},"range":[1831,1854],"raw":" 不方便添加新的资源，可能需要重新分配所有的编"}],"loc":{"start":{"line":82,"column":3},"end":{"line":82,"column":26}},"range":[1831,1854],"raw":" 不方便添加新的资源，可能需要重新分配所有的编"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":26}},"range":[1828,1854],"raw":"\n1. 不方便添加新的资源，可能需要重新分配所有的编"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪费","loc":{"start":{"line":83,"column":3},"end":{"line":83,"column":36}},"range":[1858,1891],"raw":" 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪"}],"loc":{"start":{"line":83,"column":3},"end":{"line":83,"column":36}},"range":[1858,1891],"raw":" 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪"}],"loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":36}},"range":[1855,1891],"raw":"\n2. 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"必须按照次序申请资源，编程麻烦","loc":{"start":{"line":84,"column":3},"end":{"line":84,"column":18}},"range":[1895,1910],"raw":" 必须按照次序申请资源，编程麻"}],"loc":{"start":{"line":84,"column":3},"end":{"line":84,"column":18}},"range":[1895,1910],"raw":" 必须按照次序申请资源，编程麻"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":18}},"range":[1892,1910],"raw":"\n3. 必须按照次序申请资源，编程麻"}],"loc":{"start":{"line":82,"column":0},"end":{"line":84,"column":18}},"range":[1828,1910],"raw":"\n1. 不方便添加新的资源，可能需要重新分配所有的编号\n2. 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪费\n3. 必须按照次序申请资源，编程麻"},{"type":"HorizontalRule","loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":4}},"range":[1912,1916],"raw":"\n***"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"避免死锁","loc":{"start":{"line":88,"column":4},"end":{"line":88,"column":8}},"range":[1922,1926],"raw":" 避免死"}],"loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":8}},"range":[1918,1926],"raw":"\n### 避免死"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"安全序列","loc":{"start":{"line":92,"column":5},"end":{"line":92,"column":9}},"range":[1935,1939],"raw":" 安全序"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":9}},"range":[1930,1939],"raw":"\n#### 安全序"},{"type":"Paragraph","children":[{"type":"Str","value":"如果系统按照某种序列分配资源，则每个进程都可以顺利完成，只要能找出一个安全序列，系统就是安全状态，安全序列可能会有多个。","loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":60}},"range":[1941,2001],"raw":"\n如果系统按照某种序列分配资源，则每个进程都可以顺利完成，只要能找出一个安全序列，系统就是安全状态，安全序列可能会有多个"}],"loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":60}},"range":[1941,2001],"raw":"\n如果系统按照某种序列分配资源，则每个进程都可以顺利完成，只要能找出一个安全序列，系统就是安全状态，安全序列可能会有多个"},{"type":"Paragraph","children":[{"type":"Str","value":"如果系统处于安全状态，就一定不会发生死锁，如果系统中找不到一个安全序列，而进入不安全状态，则","loc":{"start":{"line":96,"column":0},"end":{"line":96,"column":46}},"range":[2003,2049],"raw":"\n如果系统处于安全状态，就一定不会发生死锁，如果系统中找不到一个安全序列，而进入不安全状态，"},{"type":"Strong","children":[{"type":"Str","value":"有可能会发生死锁","loc":{"start":{"line":96,"column":48},"end":{"line":96,"column":56}},"range":[2051,2059],"raw":"*有可能会发生死"}],"loc":{"start":{"line":96,"column":46},"end":{"line":96,"column":58}},"range":[2049,2061],"raw":"则**有可能会发生死锁*"},{"type":"Str","value":"。","loc":{"start":{"line":96,"column":58},"end":{"line":96,"column":59}},"range":[2061,2062],"raw":"*"}],"loc":{"start":{"line":96,"column":0},"end":{"line":96,"column":59}},"range":[2003,2062],"raw":"\n如果系统处于安全状态，就一定不会发生死锁，如果系统中找不到一个安全序列，而进入不安全状态，则**有可能会发生死锁**"},{"type":"Paragraph","children":[{"type":"Strong","children":[{"type":"Str","value":"系统处于不安全状态是发生死锁的必要不充分条件","loc":{"start":{"line":98,"column":2},"end":{"line":98,"column":24}},"range":[2066,2088],"raw":"*系统处于不安全状态是发生死锁的必要不充分条"}],"loc":{"start":{"line":98,"column":0},"end":{"line":98,"column":26}},"range":[2064,2090],"raw":"\n**系统处于不安全状态是发生死锁的必要不充分条件*"},{"type":"Str","value":"。","loc":{"start":{"line":98,"column":26},"end":{"line":98,"column":27}},"range":[2090,2091],"raw":"*"}],"loc":{"start":{"line":98,"column":0},"end":{"line":98,"column":27}},"range":[2064,2091],"raw":"\n**系统处于不安全状态是发生死锁的必要不充分条件**"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"银行家算法","loc":{"start":{"line":102,"column":5},"end":{"line":102,"column":10}},"range":[2100,2105],"raw":" 银行家算"}],"loc":{"start":{"line":102,"column":0},"end":{"line":102,"column":10}},"range":[2095,2105],"raw":"\n#### 银行家算"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想：分配资源之前，预先判断是否会导致系统进入不安全状态，决定是否答应资源分配请求","loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":43}},"range":[2107,2150],"raw":"\n算法思想：分配资源之前，预先判断是否会导致系统进入不安全状态，决定是否答应资源分配请"}],"loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":43}},"range":[2107,2150],"raw":"\n算法思想：分配资源之前，预先判断是否会导致系统进入不安全状态，决定是否答应资源分配请"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int max[n][m]; // 各个进程资源最大需求量\nint allocation[n][m]; // 各个进程已经获得的资源量\nint need[n][m]; // 各个进程还需要的资源量\nint avaliable[m]; // 系统中剩余的资源的量\n\nbool request(int pid, int resource[m]){\n    int i,j;\n    for(i=0;i<m;i++) if(resources[i]>need[pid][i]) return false; // 申请的资源超过进程此前声明的最大需求，不分配\n    for(i=0;i<m;i++) if(resources[i]>avaliable[i]) return false; // 系统中剩余资源不够，不能分配\n    // 尝试把资源分配给这个进程，然后判断分配之后系统是否安全\n    for(i=0;i<m;i++){\n        avaliable[m] -= resource[m];\n        allocation[pid][m] += resource[m];\n        need[pid][m] -= resource[m];\n    }\n    // 检查系统当前是否安全\n    bool safe = false;\n    bool flags[n];\n    for(i=0;i<n;i++) flags[i] = false;\n    while(true){\n        all_not_enough = true;\n      \tfor(i=0;i<n;i++){\n        \tbool enough = true;\n        \tfor(j=0;i<m;j++){\n            \tif(need[j][j] > avaliable[j]){\n                \tenough = false;\n                \tbreak;\n            \t}\n        \t}\n        \tif(!enough) continue; // 系统中的资源满足不了这个进程，跳过\n        \t// 系统中的资源可以满足这个进程，如果把资源分配给这个进程，让其运行完成\n        \tflags[i] = true;\n            all_not_enough = true;\n            // 模拟这个进程运行结束把持有的资源还给系统\n            for(j=0;j<m;j++) avaliable[j] += allocation[i][j];\n    \t}\n        bool all_enough = true;\n        for(i=0;i<n;i++) all_enough = all_enough && flags[i];\n        if(all_enough || all_not_enough){\n            safe = all_enough;\n            break;\n        }\n    }\n    // 如果不安全，不分配资源，并把数据恢复\n    if(!safe)\n        for(i=0;i<m;i++){\n            avaliable[m] += resource[m];\n        \tallocation[pid][m] -= resource[m];\n        \tneed[pid][m] += resource[m];\n        }\n    return safe;\n}","loc":{"start":{"line":106,"column":0},"end":{"line":159,"column":3}},"range":[2152,3740],"raw":"\n```c\nint max[n][m]; // 各个进程资源最大需求量\nint allocation[n][m]; // 各个进程已经获得的资源量\nint need[n][m]; // 各个进程还需要的资源量\nint avaliable[m]; // 系统中剩余的资源的量\n\nbool request(int pid, int resource[m]){\n    int i,j;\n    for(i=0;i<m;i++) if(resources[i]>need[pid][i]) return false; // 申请的资源超过进程此前声明的最大需求，不分配\n    for(i=0;i<m;i++) if(resources[i]>avaliable[i]) return false; // 系统中剩余资源不够，不能分配\n    // 尝试把资源分配给这个进程，然后判断分配之后系统是否安全\n    for(i=0;i<m;i++){\n        avaliable[m] -= resource[m];\n        allocation[pid][m] += resource[m];\n        need[pid][m] -= resource[m];\n    }\n    // 检查系统当前是否安全\n    bool safe = false;\n    bool flags[n];\n    for(i=0;i<n;i++) flags[i] = false;\n    while(true){\n        all_not_enough = true;\n      \tfor(i=0;i<n;i++){\n        \tbool enough = true;\n        \tfor(j=0;i<m;j++){\n            \tif(need[j][j] > avaliable[j]){\n                \tenough = false;\n                \tbreak;\n            \t}\n        \t}\n        \tif(!enough) continue; // 系统中的资源满足不了这个进程，跳过\n        \t// 系统中的资源可以满足这个进程，如果把资源分配给这个进程，让其运行完成\n        \tflags[i] = true;\n            all_not_enough = true;\n            // 模拟这个进程运行结束把持有的资源还给系统\n            for(j=0;j<m;j++) avaliable[j] += allocation[i][j];\n    \t}\n        bool all_enough = true;\n        for(i=0;i<n;i++) all_enough = all_enough && flags[i];\n        if(all_enough || all_not_enough){\n            safe = all_enough;\n            break;\n        }\n    }\n    // 如果不安全，不分配资源，并把数据恢复\n    if(!safe)\n        for(i=0;i<m;i++){\n            avaliable[m] += resource[m];\n        \tallocation[pid][m] -= resource[m];\n        \tneed[pid][m] += resource[m];\n        }\n    return safe;\n}\n``"},{"type":"HorizontalRule","loc":{"start":{"line":163,"column":0},"end":{"line":163,"column":5}},"range":[3744,3749],"raw":"\n****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"死锁的检测和解除","loc":{"start":{"line":165,"column":4},"end":{"line":165,"column":12}},"range":[3755,3763],"raw":" 死锁的检测和解"}],"loc":{"start":{"line":165,"column":0},"end":{"line":165,"column":12}},"range":[3751,3763],"raw":"\n### 死锁的检测和解"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"死锁的检测","loc":{"start":{"line":167,"column":5},"end":{"line":167,"column":10}},"range":[3770,3775],"raw":" 死锁的检"}],"loc":{"start":{"line":167,"column":0},"end":{"line":167,"column":10}},"range":[3765,3775],"raw":"\n#### 死锁的检"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"用某种数据结构来保存资源的请求和分配信息","loc":{"start":{"line":169,"column":3},"end":{"line":169,"column":23}},"range":[3780,3800],"raw":" 用某种数据结构来保存资源的请求和分配信"}],"loc":{"start":{"line":169,"column":3},"end":{"line":169,"column":23}},"range":[3780,3800],"raw":" 用某种数据结构来保存资源的请求和分配信"}],"loc":{"start":{"line":169,"column":0},"end":{"line":169,"column":23}},"range":[3777,3800],"raw":"\n1. 用某种数据结构来保存资源的请求和分配信"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"提供一种，利用上述信息来检测系统是否已经进入死锁状态","loc":{"start":{"line":170,"column":3},"end":{"line":170,"column":29}},"range":[3804,3830],"raw":" 提供一种，利用上述信息来检测系统是否已经进入死锁状"}],"loc":{"start":{"line":170,"column":3},"end":{"line":170,"column":29}},"range":[3804,3830],"raw":" 提供一种，利用上述信息来检测系统是否已经进入死锁状"}],"loc":{"start":{"line":170,"column":0},"end":{"line":170,"column":29}},"range":[3801,3830],"raw":"\n2. 提供一种，利用上述信息来检测系统是否已经进入死锁状"}],"loc":{"start":{"line":169,"column":0},"end":{"line":170,"column":29}},"range":[3777,3830],"raw":"\n1. 用某种数据结构来保存资源的请求和分配信息\n2. 提供一种，利用上述信息来检测系统是否已经进入死锁状"},{"type":"Paragraph","children":[{"type":"Str","value":"检测死锁的算法:","loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":8}},"range":[3832,3840],"raw":"\n检测死锁的算法"}],"loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":8}},"range":[3832,3840],"raw":"\n检测死锁的算法"},{"type":"Paragraph","children":[{"type":"Emphasis","children":[{"type":"Strong","children":[{"type":"Str","value":"依次消除与不阻塞进程相连的边，直到无边可消。","loc":{"start":{"line":174,"column":3},"end":{"line":174,"column":25}},"range":[3845,3867],"raw":"*依次消除与不阻塞进程相连的边，直到无边可消"}],"loc":{"start":{"line":174,"column":1},"end":{"line":174,"column":27}},"range":[3843,3869],"raw":"***依次消除与不阻塞进程相连的边，直到无边可消。*"}],"loc":{"start":{"line":174,"column":0},"end":{"line":174,"column":28}},"range":[3842,3870],"raw":"\n***依次消除与不阻塞进程相连的边，直到无边可消。**"}],"loc":{"start":{"line":174,"column":0},"end":{"line":174,"column":28}},"range":[3842,3870],"raw":"\n***依次消除与不阻塞进程相连的边，直到无边可消。**"},{"type":"List","ordered":true,"start":1,"spread":true,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。","loc":{"start":{"line":176,"column":3},"end":{"line":176,"column":71}},"range":[3875,3943],"raw":" 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量"}],"loc":{"start":{"line":176,"column":3},"end":{"line":176,"column":71}},"range":[3875,3943],"raw":" 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量"}],"loc":{"start":{"line":176,"column":0},"end":{"line":176,"column":71}},"range":[3872,3943],"raw":"\n1) 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程。","loc":{"start":{"line":178,"column":3},"end":{"line":178,"column":51}},"range":[3948,3996],"raw":" 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程"}],"loc":{"start":{"line":178,"column":3},"end":{"line":178,"column":51}},"range":[3948,3996],"raw":" 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程"}],"loc":{"start":{"line":178,"column":0},"end":{"line":178,"column":51}},"range":[3945,3996],"raw":"\n2) 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程"}],"loc":{"start":{"line":176,"column":0},"end":{"line":178,"column":51}},"range":[3872,3996],"raw":"\n1) 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。\n\n2) 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程"},{"type":"Paragraph","children":[{"type":"Str","value":"死锁定理：如果某时刻不可以将系统资源分配图的所有边都消除（资源分配图","loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":34}},"range":[3998,4032],"raw":"\n死锁定理：如果某时刻不可以将系统资源分配图的所有边都消除（资源分配"},{"type":"Strong","children":[{"type":"Str","value":"不可完全简化","loc":{"start":{"line":180,"column":36},"end":{"line":180,"column":42}},"range":[4034,4040],"raw":"*不可完全简"}],"loc":{"start":{"line":180,"column":34},"end":{"line":180,"column":44}},"range":[4032,4042],"raw":"图**不可完全简化*"},{"type":"Str","value":"），此时系统","loc":{"start":{"line":180,"column":44},"end":{"line":180,"column":50}},"range":[4042,4048],"raw":"*），此时系"},{"type":"Strong","children":[{"type":"Str","value":"死锁","loc":{"start":{"line":180,"column":52},"end":{"line":180,"column":54}},"range":[4050,4052],"raw":"*死"}],"loc":{"start":{"line":180,"column":50},"end":{"line":180,"column":56}},"range":[4048,4054],"raw":"统**死锁*"},{"type":"Str","value":"。","loc":{"start":{"line":180,"column":56},"end":{"line":180,"column":57}},"range":[4054,4055],"raw":"*"}],"loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":57}},"range":[3998,4055],"raw":"\n死锁定理：如果某时刻不可以将系统资源分配图的所有边都消除（资源分配图**不可完全简化**），此时系统**死锁**"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"解除死锁","loc":{"start":{"line":182,"column":5},"end":{"line":182,"column":9}},"range":[4062,4066],"raw":" 解除死"}],"loc":{"start":{"line":182,"column":0},"end":{"line":182,"column":9}},"range":[4057,4066],"raw":"\n#### 解除死"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿。","loc":{"start":{"line":184,"column":3},"end":{"line":184,"column":67}},"range":[4071,4135],"raw":" 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿"}],"loc":{"start":{"line":184,"column":3},"end":{"line":184,"column":67}},"range":[4071,4135],"raw":" 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿"}],"loc":{"start":{"line":184,"column":0},"end":{"line":184,"column":67}},"range":[4068,4135],"raw":"\n1. 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑。","loc":{"start":{"line":185,"column":3},"end":{"line":185,"column":84}},"range":[4139,4220],"raw":" 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑"}],"loc":{"start":{"line":185,"column":3},"end":{"line":185,"column":84}},"range":[4139,4220],"raw":" 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑"}],"loc":{"start":{"line":185,"column":0},"end":{"line":185,"column":84}},"range":[4136,4220],"raw":"\n2. 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点。","loc":{"start":{"line":186,"column":3},"end":{"line":186,"column":54}},"range":[4224,4275],"raw":" 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点"}],"loc":{"start":{"line":186,"column":3},"end":{"line":186,"column":54}},"range":[4224,4275],"raw":" 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点"}],"loc":{"start":{"line":186,"column":0},"end":{"line":186,"column":54}},"range":[4221,4275],"raw":"\n3. 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点"}],"loc":{"start":{"line":184,"column":0},"end":{"line":186,"column":54}},"range":[4068,4275],"raw":"\n1. 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿。\n2. 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑。\n3. 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点"},{"type":"Paragraph","children":[{"type":"Str","value":"可以根据：进程优先级、已经执行的时间、还有多久可以完成、进程使用的资源数量、进程的形式等因素决定剥夺那些进程的资源。","loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":58}},"range":[4277,4335],"raw":"\n可以根据：进程优先级、已经执行的时间、还有多久可以完成、进程使用的资源数量、进程的形式等因素决定剥夺那些进程的资源"}],"loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":58}},"range":[4277,4335],"raw":"\n可以根据：进程优先级、已经执行的时间、还有多久可以完成、进程使用的资源数量、进程的形式等因素决定剥夺那些进程的资源"}],"loc":{"start":{"line":1,"column":0},"end":{"line":188,"column":58}},"range":[0,4335],"raw":"﻿---\ntitle: '死锁'\ntags: ['操作系统','死锁']\n---\n# 死锁\n\n## 死锁、饥饿和死循环\n\n- 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”。\n\n- 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象。\n\n- 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的。\n\n共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。\n\n差异：\n\n- 死锁：至少发生在两个或者两个以上的进程上，**发生死锁的进程一定处于阻塞态**。\n- 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机）\n- 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而**死循环是由于代码的逻辑错误导致的**。\n\n## 死锁产生的条件\n\n1. 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死锁\n2. 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释放\n3. 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放。\n4. 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求。\n\n满足上面的四个条件不一定会发生死锁，但是发生死锁的时候一定会满足上面的四个条件，满足上面的四个条件是产生死锁的**必要不充分条件**。\n\n死锁发生在：\n\n1. 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁。\n2. 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁。\n3. 信号量使用不当：信号量使用不当的时候可能产生死锁\n\n## 死锁的处理策略\n\n1. 预防死锁：破坏产生死锁的四个必要条件的一个或者几个\n2. 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法）\n3. 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁。\n\n****\n\n### 预防死锁\n\n#### 破坏互斥条件\n\n把只能互斥使用的资源改造为允许共享使用的资源，系统就不会进入死锁状态，比如：SPOOLing技术\n\n缺点：不是所有得资源都可以改造为可共享使用得资源，并且可能为了系统安全，很多资源必须保护这种互斥性。**很多时候都无法破会互斥条件**。\n\n#### 破坏不可剥夺条件\n\n- 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条件\n- 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级。\n\n缺点：\n\n1. 实现复杂\n2. 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU。\n3. 反复申请资源会导致系统开销增大，降低系统的吞吐量\n4. 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿。\n\n#### 破坏请求和保持条件\n\n采用**静态分配的方法**，在进程运行前就分配给它所有需要的资源，在资源未得到满足之前，进程不会投入运行，进程一旦投入运行，这些资源就归它所有，直到进程运行结束，该进程在运行过程中不会请求别的任何资源。\n\n优点：实现简单\n\n缺点：有些资源，进程可能只会使用很短的时间，如果进程整个运行期间都保持着所有的资源，会造成艳照那个的资源浪费，资源利用率极低，导致其他的进程饥饿。\n\n#### 破坏循环等待条件\n\n采用顺序资源分配，给系统中所有的资源编号，每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）依次申请完。\n\n原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。\n\n缺点：\n\n1. 不方便添加新的资源，可能需要重新分配所有的编号\n2. 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪费\n3. 必须按照次序申请资源，编程麻烦\n\n****\n\n### 避免死锁\n\n\n\n#### 安全序列\n\n如果系统按照某种序列分配资源，则每个进程都可以顺利完成，只要能找出一个安全序列，系统就是安全状态，安全序列可能会有多个。\n\n如果系统处于安全状态，就一定不会发生死锁，如果系统中找不到一个安全序列，而进入不安全状态，则**有可能会发生死锁**。\n\n**系统处于不安全状态是发生死锁的必要不充分条件**。\n\n\n\n#### 银行家算法\n\n算法思想：分配资源之前，预先判断是否会导致系统进入不安全状态，决定是否答应资源分配请求\n\n```c\nint max[n][m]; // 各个进程资源最大需求量\nint allocation[n][m]; // 各个进程已经获得的资源量\nint need[n][m]; // 各个进程还需要的资源量\nint avaliable[m]; // 系统中剩余的资源的量\n\nbool request(int pid, int resource[m]){\n    int i,j;\n    for(i=0;i<m;i++) if(resources[i]>need[pid][i]) return false; // 申请的资源超过进程此前声明的最大需求，不分配\n    for(i=0;i<m;i++) if(resources[i]>avaliable[i]) return false; // 系统中剩余资源不够，不能分配\n    // 尝试把资源分配给这个进程，然后判断分配之后系统是否安全\n    for(i=0;i<m;i++){\n        avaliable[m] -= resource[m];\n        allocation[pid][m] += resource[m];\n        need[pid][m] -= resource[m];\n    }\n    // 检查系统当前是否安全\n    bool safe = false;\n    bool flags[n];\n    for(i=0;i<n;i++) flags[i] = false;\n    while(true){\n        all_not_enough = true;\n      \tfor(i=0;i<n;i++){\n        \tbool enough = true;\n        \tfor(j=0;i<m;j++){\n            \tif(need[j][j] > avaliable[j]){\n                \tenough = false;\n                \tbreak;\n            \t}\n        \t}\n        \tif(!enough) continue; // 系统中的资源满足不了这个进程，跳过\n        \t// 系统中的资源可以满足这个进程，如果把资源分配给这个进程，让其运行完成\n        \tflags[i] = true;\n            all_not_enough = true;\n            // 模拟这个进程运行结束把持有的资源还给系统\n            for(j=0;j<m;j++) avaliable[j] += allocation[i][j];\n    \t}\n        bool all_enough = true;\n        for(i=0;i<n;i++) all_enough = all_enough && flags[i];\n        if(all_enough || all_not_enough){\n            safe = all_enough;\n            break;\n        }\n    }\n    // 如果不安全，不分配资源，并把数据恢复\n    if(!safe)\n        for(i=0;i<m;i++){\n            avaliable[m] += resource[m];\n        \tallocation[pid][m] -= resource[m];\n        \tneed[pid][m] += resource[m];\n        }\n    return safe;\n}\n```\n\n\n\n*****\n\n### 死锁的检测和解除\n\n#### 死锁的检测\n\n1. 用某种数据结构来保存资源的请求和分配信息\n2. 提供一种，利用上述信息来检测系统是否已经进入死锁状态\n\n检测死锁的算法:\n\n***依次消除与不阻塞进程相连的边，直到无边可消。***\n\n1) 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。\n\n2) 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程。\n\n死锁定理：如果某时刻不可以将系统资源分配图的所有边都消除（资源分配图**不可完全简化**），此时系统**死锁**。\n\n#### 解除死锁\n\n1. 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿。\n2. 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑。\n3. 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点。\n\n可以根据：进程优先级、已经执行的时间、还有多久可以完成、进程使用的资源数量、进程的形式等因素决定剥夺那些进程的资源"},"catalogue":{"title":"死锁","json-path":"操作系统/2020-08-16-死锁.json","mdate":"2020-08-16","cover":"https://i.328888.xyz/2023/01/01/tZqwU.jpeg","icon":"🍀","visible":true,"tags":["操作系统","死锁"]}}