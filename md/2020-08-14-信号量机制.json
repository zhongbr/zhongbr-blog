{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '信号量机制'\ntags: ['操作系统','信号量']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,43],"raw":"---\ntitle: '信号量机制'\ntags: ['操作系统','信号量']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"信号量机制","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":7}},"range":[46,51],"raw":"信号量机制"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":7}},"range":[44,51],"raw":"# 信号量机制"},{"type":"Paragraph","children":[{"type":"Str","value":"进程互斥的四种软件实现方式（单标志法、双标志法、双标志后检查法、Peterson算法）和三种硬件实现方式（中断屏蔽、TSL指令和SWAP指令）。","loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":72}},"range":[53,125],"raw":"进程互斥的四种软件实现方式（单标志法、双标志法、双标志后检查法、Peterson算法）和三种硬件实现方式（中断屏蔽、TSL指令和SWAP指令）。"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":72}},"range":[53,125],"raw":"进程互斥的四种软件实现方式（单标志法、双标志法、双标志后检查法、Peterson算法）和三种硬件实现方式（中断屏蔽、TSL指令和SWAP指令）。"},{"type":"Paragraph","children":[{"type":"Str","value":"以上的所有方式都没有遵循“让权等待”原则，在无法进入临界区时，也不会把CPU资源让给其他进程。","loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":47}},"range":[127,174],"raw":"以上的所有方式都没有遵循“让权等待”原则，在无法进入临界区时，也不会把CPU资源让给其他进程。"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":47}},"range":[127,174],"raw":"以上的所有方式都没有遵循“让权等待”原则，在无法进入临界区时，也不会把CPU资源让给其他进程。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"信号量机制：用户进程可以通过","loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":16}},"range":[178,192],"raw":"信号量机制：用户进程可以通过"},{"type":"Strong","children":[{"type":"Str","value":"操作系统提供的一对原语","loc":{"start":{"line":11,"column":18},"end":{"line":11,"column":29}},"range":[194,205],"raw":"操作系统提供的一对原语"}],"loc":{"start":{"line":11,"column":16},"end":{"line":11,"column":31}},"range":[192,207],"raw":"**操作系统提供的一对原语**"},{"type":"Str","value":"，来对信号量进行操作，方便地实现了进程之间地互斥和同步。","loc":{"start":{"line":11,"column":31},"end":{"line":11,"column":59}},"range":[207,235],"raw":"，来对信号量进行操作，方便地实现了进程之间地互斥和同步。"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":59}},"range":[178,235],"raw":"信号量机制：用户进程可以通过**操作系统提供的一对原语**，来对信号量进行操作，方便地实现了进程之间地互斥和同步。"},{"type":"Paragraph","children":[{"type":"Str","value":"信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":59}},"range":[239,296],"raw":"信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":59}},"range":[239,296],"raw":"信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":13,"column":59}},"range":[176,296],"raw":"- 信号量机制：用户进程可以通过**操作系统提供的一对原语**，来对信号量进行操作，方便地实现了进程之间地互斥和同步。\n\n  信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":13,"column":59}},"range":[176,296],"raw":"- 信号量机制：用户进程可以通过**操作系统提供的一对原语**，来对信号量进行操作，方便地实现了进程之间地互斥和同步。\n\n  信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。"},{"type":"Paragraph","children":[{"type":"Str","value":"wait(S)原语和signal(S)原语，两个操作可以分别写为P(S)和V(s)。","loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":42}},"range":[298,340],"raw":"wait(S)原语和signal(S)原语，两个操作可以分别写为P(S)和V(s)。"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":42}},"range":[298,340],"raw":"wait(S)原语和signal(S)原语，两个操作可以分别写为P(S)和V(s)。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"整型信号量","loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":8}},"range":[345,350],"raw":"整型信号量"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":8}},"range":[342,350],"raw":"## 整型信号量"},{"type":"Paragraph","children":[{"type":"Str","value":"用一个整数来表示系统某种资源的数量。","loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":18}},"range":[352,370],"raw":"用一个整数来表示系统某种资源的数量。"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":18}},"range":[352,370],"raw":"用一个整数来表示系统某种资源的数量。"},{"type":"Paragraph","children":[{"type":"Str","value":"与普通的整型变量相比，整型信号量只能进行初始化、P操作和V操作。","loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":32}},"range":[372,404],"raw":"与普通的整型变量相比，整型信号量只能进行初始化、P操作和V操作。"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":32}},"range":[372,404],"raw":"与普通的整型变量相比，整型信号量只能进行初始化、P操作和V操作。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int S=1; // 系统中某种资源数\n\n// wait原语的逻辑\nvoid wait(int S){\n    while(S<=0);\n    S--;\n}\n// signal原语的逻辑\nvoid signal(int S){\n    S++;\n}\n\n// 使用信号量的逻辑\n// 进程P0\nwait(S); // 进入区\n// 临界区代码\nsignal(S); // 退出区","loc":{"start":{"line":23,"column":0},"end":{"line":41,"column":3}},"range":[406,605],"raw":"```c\nint S=1; // 系统中某种资源数\n\n// wait原语的逻辑\nvoid wait(int S){\n    while(S<=0);\n    S--;\n}\n// signal原语的逻辑\nvoid signal(int S){\n    S++;\n}\n\n// 使用信号量的逻辑\n// 进程P0\nwait(S); // 进入区\n// 临界区代码\nsignal(S); // 退出区\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：不满足“让权等待”原则","loc":{"start":{"line":43,"column":1},"end":{"line":43,"column":15}},"range":[608,622],"raw":"缺点：不满足“让权等待”原则"}],"loc":{"start":{"line":43,"column":1},"end":{"line":43,"column":15}},"range":[608,622],"raw":"缺点：不满足“让权等待”原则"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"记录型信号量","loc":{"start":{"line":45,"column":3},"end":{"line":45,"column":9}},"range":[627,633],"raw":"记录型信号量"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":9}},"range":[624,633],"raw":"## 记录型信号量"},{"type":"Paragraph","children":[{"type":"Str","value":"用记录型数据解雇表示信号量，可以解决整型信号量存在的“忙等”的问题。","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":34}},"range":[635,669],"raw":"用记录型数据解雇表示信号量，可以解决整型信号量存在的“忙等”的问题。"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":34}},"range":[635,669],"raw":"用记录型数据解雇表示信号量，可以解决整型信号量存在的“忙等”的问题。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"//记录型信号量\ntypedef struct {\n    int value;\t// 剩余资源数\n    struct process *L; // 等待的资源\n} semphore;\n// wait原语\nvoid wait(semaphore S){\n    S.value --;\n    if(S.value < 0) block(S.L); // 剩余的资源数不够，使用block原语把当前的进程阻塞\n}\nvoid signal(semaphore S){\n    s.value++;\n    if(S.value <= 0) wakeup(S.L); // 说明在释放资源之前，还有进程在等待使用这个资源\n}","loc":{"start":{"line":49,"column":0},"end":{"line":64,"column":3}},"range":[671,991],"raw":"```c\n//记录型信号量\ntypedef struct {\n    int value;\t// 剩余资源数\n    struct process *L; // 等待的资源\n} semphore;\n// wait原语\nvoid wait(semaphore S){\n    S.value --;\n    if(S.value < 0) block(S.L); // 剩余的资源数不够，使用block原语把当前的进程阻塞\n}\nvoid signal(semaphore S){\n    s.value++;\n    if(S.value <= 0) wakeup(S.L); // 说明在释放资源之前，还有进程在等待使用这个资源\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：遵循了“让权等待”原则","loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":14}},"range":[993,1007],"raw":"优点：遵循了“让权等待”原则"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":14}},"range":[993,1007],"raw":"优点：遵循了“让权等待”原则"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"信号量进制实现进程互斥","loc":{"start":{"line":68,"column":3},"end":{"line":68,"column":14}},"range":[1012,1023],"raw":"信号量进制实现进程互斥"}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":14}},"range":[1009,1023],"raw":"## 信号量进制实现进程互斥"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"分析并发进程的关键活动、划定临界区","loc":{"start":{"line":70,"column":3},"end":{"line":70,"column":20}},"range":[1028,1045],"raw":"分析并发进程的关键活动、划定临界区"}],"loc":{"start":{"line":70,"column":3},"end":{"line":70,"column":20}},"range":[1028,1045],"raw":"分析并发进程的关键活动、划定临界区"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":20}},"range":[1025,1045],"raw":"1. 分析并发进程的关键活动、划定临界区"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"设置互斥信号量mutex，初始值为1","loc":{"start":{"line":71,"column":3},"end":{"line":71,"column":21}},"range":[1049,1067],"raw":"设置互斥信号量mutex，初始值为1"}],"loc":{"start":{"line":71,"column":3},"end":{"line":71,"column":21}},"range":[1049,1067],"raw":"设置互斥信号量mutex，初始值为1"}],"loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":21}},"range":[1046,1067],"raw":"2. 设置互斥信号量mutex，初始值为1"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在临界区之前对信号量mutex执行P操作","loc":{"start":{"line":72,"column":3},"end":{"line":72,"column":23}},"range":[1071,1091],"raw":"在临界区之前对信号量mutex执行P操作"}],"loc":{"start":{"line":72,"column":3},"end":{"line":72,"column":23}},"range":[1071,1091],"raw":"在临界区之前对信号量mutex执行P操作"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":23}},"range":[1068,1091],"raw":"3. 在临界区之前对信号量mutex执行P操作"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在临界区之后对信号量mutex执行V操作","loc":{"start":{"line":73,"column":3},"end":{"line":73,"column":23}},"range":[1095,1115],"raw":"在临界区之后对信号量mutex执行V操作"}],"loc":{"start":{"line":73,"column":3},"end":{"line":73,"column":23}},"range":[1095,1115],"raw":"在临界区之后对信号量mutex执行V操作"}],"loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":23}},"range":[1092,1115],"raw":"4. 在临界区之后对信号量mutex执行V操作"}],"loc":{"start":{"line":70,"column":0},"end":{"line":73,"column":23}},"range":[1025,1115],"raw":"1. 分析并发进程的关键活动、划定临界区\n2. 设置互斥信号量mutex，初始值为1\n3. 在临界区之前对信号量mutex执行P操作\n4. 在临界区之后对信号量mutex执行V操作"},{"type":"Paragraph","children":[{"type":"Str","value":"对于不同的临界资源，需要设置","loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":14}},"range":[1117,1131],"raw":"对于不同的临界资源，需要设置"},{"type":"Strong","children":[{"type":"Str","value":"不同的互斥信号量","loc":{"start":{"line":75,"column":16},"end":{"line":75,"column":24}},"range":[1133,1141],"raw":"不同的互斥信号量"}],"loc":{"start":{"line":75,"column":14},"end":{"line":75,"column":26}},"range":[1131,1143],"raw":"**不同的互斥信号量**"}],"loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":26}},"range":[1117,1143],"raw":"对于不同的临界资源，需要设置**不同的互斥信号量**"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"信号量机制实现进程同步","loc":{"start":{"line":77,"column":3},"end":{"line":77,"column":14}},"range":[1148,1159],"raw":"信号量机制实现进程同步"}],"loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":14}},"range":[1145,1159],"raw":"## 信号量机制实现进程同步"},{"type":"Paragraph","children":[{"type":"Str","value":"进程同步：让各个进程有序地推进","loc":{"start":{"line":79,"column":0},"end":{"line":79,"column":15}},"range":[1161,1176],"raw":"进程同步：让各个进程有序地推进"}],"loc":{"start":{"line":79,"column":0},"end":{"line":79,"column":15}},"range":[1161,1176],"raw":"进程同步：让各个进程有序地推进"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"分析需要实现同步关系的位置","loc":{"start":{"line":81,"column":3},"end":{"line":81,"column":16}},"range":[1181,1194],"raw":"分析需要实现同步关系的位置"}],"loc":{"start":{"line":81,"column":3},"end":{"line":81,"column":16}},"range":[1181,1194],"raw":"分析需要实现同步关系的位置"}],"loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":16}},"range":[1178,1194],"raw":"1. 分析需要实现同步关系的位置"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"设置同步信号量S，初始值为0","loc":{"start":{"line":82,"column":3},"end":{"line":82,"column":17}},"range":[1198,1212],"raw":"设置同步信号量S，初始值为0"}],"loc":{"start":{"line":82,"column":3},"end":{"line":82,"column":17}},"range":[1198,1212],"raw":"设置同步信号量S，初始值为0"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":17}},"range":[1195,1212],"raw":"2. 设置同步信号量S，初始值为0"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）","loc":{"start":{"line":83,"column":3},"end":{"line":83,"column":31}},"range":[1216,1244],"raw":"在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）"}],"loc":{"start":{"line":83,"column":3},"end":{"line":83,"column":31}},"range":[1216,1244],"raw":"在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）"}],"loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":31}},"range":[1213,1244],"raw":"3. 在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）","loc":{"start":{"line":84,"column":3},"end":{"line":84,"column":33}},"range":[1248,1278],"raw":"在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）"}],"loc":{"start":{"line":84,"column":3},"end":{"line":84,"column":33}},"range":[1248,1278],"raw":"在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":33}},"range":[1245,1278],"raw":"4. 在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）"}],"loc":{"start":{"line":81,"column":0},"end":{"line":84,"column":33}},"range":[1178,1278],"raw":"1. 分析需要实现同步关系的位置\n2. 设置同步信号量S，初始值为0\n3. 在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）\n4. 在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore S=0;\n\n// 前操作\nP1(){\n    // 前操作代码\n    V(S); // signal原语，唤醒后操作进程\n    // 剩余代码\n}\n\n// 后操作\nP2(){\n    P(S); // wait原语，检查前操作是否完成了\n    // 后操作代码\n   \t// 剩余代码\n}","loc":{"start":{"line":86,"column":0},"end":{"line":102,"column":3}},"range":[1280,1446],"raw":"```c\nsemaphore S=0;\n\n// 前操作\nP1(){\n    // 前操作代码\n    V(S); // signal原语，唤醒后操作进程\n    // 剩余代码\n}\n\n// 后操作\nP2(){\n    P(S); // wait原语，检查前操作是否完成了\n    // 后操作代码\n   \t// 剩余代码\n}\n```"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"信号量机制实现进程的前驱关系","loc":{"start":{"line":104,"column":3},"end":{"line":104,"column":17}},"range":[1451,1465],"raw":"信号量机制实现进程的前驱关系"}],"loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":17}},"range":[1448,1465],"raw":"## 信号量机制实现进程的前驱关系"},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/14/61DyjLnH9xqXtP2.png","alt":"quicker_283a6535-3b5b-4f96-a2ae-42da1a3153bd.png","loc":{"start":{"line":106,"column":0},"end":{"line":106,"column":102}},"range":[1467,1569],"raw":"![quicker_283a6535-3b5b-4f96-a2ae-42da1a3153bd.png](https://i.loli.net/2020/08/14/61DyjLnH9xqXtP2.png)"}],"loc":{"start":{"line":106,"column":0},"end":{"line":106,"column":102}},"range":[1467,1569],"raw":"![quicker_283a6535-3b5b-4f96-a2ae-42da1a3153bd.png](https://i.loli.net/2020/08/14/61DyjLnH9xqXtP2.png)"},{"type":"Paragraph","children":[{"type":"Str","value":"各个进程要按照如上图所示的顺序来执行。其中每一对前驱关系都是一种进程同步关系，所以：","loc":{"start":{"line":108,"column":0},"end":{"line":108,"column":42}},"range":[1571,1613],"raw":"各个进程要按照如上图所示的顺序来执行。其中每一对前驱关系都是一种进程同步关系，所以："}],"loc":{"start":{"line":108,"column":0},"end":{"line":108,"column":42}},"range":[1571,1613],"raw":"各个进程要按照如上图所示的顺序来执行。其中每一对前驱关系都是一种进程同步关系，所以："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"为每一对前驱关系各设置一个同步信号量","loc":{"start":{"line":110,"column":3},"end":{"line":110,"column":21}},"range":[1618,1636],"raw":"为每一对前驱关系各设置一个同步信号量"}],"loc":{"start":{"line":110,"column":3},"end":{"line":110,"column":21}},"range":[1618,1636],"raw":"为每一对前驱关系各设置一个同步信号量"}],"loc":{"start":{"line":110,"column":0},"end":{"line":110,"column":21}},"range":[1615,1636],"raw":"1. 为每一对前驱关系各设置一个同步信号量"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在“前操作”之后对相应的同步信号量执行V操作","loc":{"start":{"line":111,"column":3},"end":{"line":111,"column":25}},"range":[1640,1662],"raw":"在“前操作”之后对相应的同步信号量执行V操作"}],"loc":{"start":{"line":111,"column":3},"end":{"line":111,"column":25}},"range":[1640,1662],"raw":"在“前操作”之后对相应的同步信号量执行V操作"}],"loc":{"start":{"line":111,"column":0},"end":{"line":111,"column":25}},"range":[1637,1662],"raw":"2. 在“前操作”之后对相应的同步信号量执行V操作"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在“后操作”之前对相应的同步信号量执行P操作","loc":{"start":{"line":112,"column":3},"end":{"line":112,"column":25}},"range":[1666,1688],"raw":"在“后操作”之前对相应的同步信号量执行P操作"}],"loc":{"start":{"line":112,"column":3},"end":{"line":112,"column":25}},"range":[1666,1688],"raw":"在“后操作”之前对相应的同步信号量执行P操作"}],"loc":{"start":{"line":112,"column":0},"end":{"line":112,"column":25}},"range":[1663,1688],"raw":"3. 在“后操作”之前对相应的同步信号量执行P操作"}],"loc":{"start":{"line":110,"column":0},"end":{"line":112,"column":25}},"range":[1615,1688],"raw":"1. 为每一对前驱关系各设置一个同步信号量\n2. 在“前操作”之后对相应的同步信号量执行V操作\n3. 在“后操作”之前对相应的同步信号量执行P操作"},{"type":"CodeBlock","lang":"c","meta":null,"value":"// 定义信号量\nsemaphore s1s2 = 0;\nsemaphore s1s3 = 0;\nsemaphore s2s4 = 0;\nsemaphore s2s5 = 0;\nsemaphore s3s6 = 0;\nsemaphore s4s6 = 0;\nsemaphore s5s6 = 0;\n\nP1(){\n    S1;\n    V(s1s2);\n    V(s1s3);\n}\nP2(){\n    P(s1s2);\n    S2;\n    V(s2s4);\n    V(s2s5);\n}\nP3(){\n    P(s1s3);\n    S3;\n    V(s3s6);\n}\nP4(){\n    P(s2s4);\n    S4;\n    V(s4s6);\n}\nP5(){\n    P(s2s5);\n    S5;\n    V(s5s6);\n}\nP6(){\n    P(s5s6);\n    P(s3s6);\n    P(s4s6);\n    S6;\n}","loc":{"start":{"line":114,"column":0},"end":{"line":156,"column":3}},"range":[1690,2126],"raw":"```c\n// 定义信号量\nsemaphore s1s2 = 0;\nsemaphore s1s3 = 0;\nsemaphore s2s4 = 0;\nsemaphore s2s5 = 0;\nsemaphore s3s6 = 0;\nsemaphore s4s6 = 0;\nsemaphore s5s6 = 0;\n\nP1(){\n    S1;\n    V(s1s2);\n    V(s1s3);\n}\nP2(){\n    P(s1s2);\n    S2;\n    V(s2s4);\n    V(s2s5);\n}\nP3(){\n    P(s1s3);\n    S3;\n    V(s3s6);\n}\nP4(){\n    P(s2s4);\n    S4;\n    V(s4s6);\n}\nP5(){\n    P(s2s5);\n    S5;\n    V(s5s6);\n}\nP6(){\n    P(s5s6);\n    P(s3s6);\n    P(s4s6);\n    S6;\n}\n```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":158,"column":0}},"range":[0,2128],"raw":"---\ntitle: '信号量机制'\ntags: ['操作系统','信号量']\n---\n# 信号量机制\n\n进程互斥的四种软件实现方式（单标志法、双标志法、双标志后检查法、Peterson算法）和三种硬件实现方式（中断屏蔽、TSL指令和SWAP指令）。\n\n以上的所有方式都没有遵循“让权等待”原则，在无法进入临界区时，也不会把CPU资源让给其他进程。\n\n- 信号量机制：用户进程可以通过**操作系统提供的一对原语**，来对信号量进行操作，方便地实现了进程之间地互斥和同步。\n\n  信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。\n\nwait(S)原语和signal(S)原语，两个操作可以分别写为P(S)和V(s)。\n\n## 整型信号量\n\n用一个整数来表示系统某种资源的数量。\n\n与普通的整型变量相比，整型信号量只能进行初始化、P操作和V操作。\n\n```c\nint S=1; // 系统中某种资源数\n\n// wait原语的逻辑\nvoid wait(int S){\n    while(S<=0);\n    S--;\n}\n// signal原语的逻辑\nvoid signal(int S){\n    S++;\n}\n\n// 使用信号量的逻辑\n// 进程P0\nwait(S); // 进入区\n// 临界区代码\nsignal(S); // 退出区\n```\n\n 缺点：不满足“让权等待”原则\n\n## 记录型信号量\n\n用记录型数据解雇表示信号量，可以解决整型信号量存在的“忙等”的问题。\n\n```c\n//记录型信号量\ntypedef struct {\n    int value;\t// 剩余资源数\n    struct process *L; // 等待的资源\n} semphore;\n// wait原语\nvoid wait(semaphore S){\n    S.value --;\n    if(S.value < 0) block(S.L); // 剩余的资源数不够，使用block原语把当前的进程阻塞\n}\nvoid signal(semaphore S){\n    s.value++;\n    if(S.value <= 0) wakeup(S.L); // 说明在释放资源之前，还有进程在等待使用这个资源\n}\n```\n\n优点：遵循了“让权等待”原则\n\n## 信号量进制实现进程互斥\n\n1. 分析并发进程的关键活动、划定临界区\n2. 设置互斥信号量mutex，初始值为1\n3. 在临界区之前对信号量mutex执行P操作\n4. 在临界区之后对信号量mutex执行V操作\n\n对于不同的临界资源，需要设置**不同的互斥信号量**\n\n## 信号量机制实现进程同步\n\n进程同步：让各个进程有序地推进\n\n1. 分析需要实现同步关系的位置\n2. 设置同步信号量S，初始值为0\n3. 在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）\n4. 在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）\n\n```c\nsemaphore S=0;\n\n// 前操作\nP1(){\n    // 前操作代码\n    V(S); // signal原语，唤醒后操作进程\n    // 剩余代码\n}\n\n// 后操作\nP2(){\n    P(S); // wait原语，检查前操作是否完成了\n    // 后操作代码\n   \t// 剩余代码\n}\n```\n\n## 信号量机制实现进程的前驱关系\n\n![quicker_283a6535-3b5b-4f96-a2ae-42da1a3153bd.png](https://i.loli.net/2020/08/14/61DyjLnH9xqXtP2.png)\n\n各个进程要按照如上图所示的顺序来执行。其中每一对前驱关系都是一种进程同步关系，所以：\n\n1. 为每一对前驱关系各设置一个同步信号量\n2. 在“前操作”之后对相应的同步信号量执行V操作\n3. 在“后操作”之前对相应的同步信号量执行P操作\n\n```c\n// 定义信号量\nsemaphore s1s2 = 0;\nsemaphore s1s3 = 0;\nsemaphore s2s4 = 0;\nsemaphore s2s5 = 0;\nsemaphore s3s6 = 0;\nsemaphore s4s6 = 0;\nsemaphore s5s6 = 0;\n\nP1(){\n    S1;\n    V(s1s2);\n    V(s1s3);\n}\nP2(){\n    P(s1s2);\n    S2;\n    V(s2s4);\n    V(s2s5);\n}\nP3(){\n    P(s1s3);\n    S3;\n    V(s3s6);\n}\nP4(){\n    P(s2s4);\n    S4;\n    V(s4s6);\n}\nP5(){\n    P(s2s5);\n    S5;\n    V(s5s6);\n}\nP6(){\n    P(s5s6);\n    P(s3s6);\n    P(s4s6);\n    S6;\n}\n```\n\n"},"catalogue":{"title":"信号量机制","json-path":"2020-08-14-信号量机制.json","mdate":"2022-08-30T16:38:35.774Z","tags":["操作系统","信号量"]}}