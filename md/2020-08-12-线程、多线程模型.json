{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '线程、多线程模型'\ntags: ['操作系统','线程']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,45],"raw":"---\ntitle: '线程、多线程模型'\ntags: ['操作系统','线程']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"线程、多线程模型","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":10}},"range":[48,56],"raw":"线程、多线程模型"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":10}},"range":[46,56],"raw":"# 线程、多线程模型"},{"type":"Paragraph","children":[{"type":"Str","value":"引入线程之前，进程是程序流执行的最小单位","loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":20}},"range":[58,78],"raw":"引入线程之前，进程是程序流执行的最小单位"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":20}},"range":[58,78],"raw":"引入线程之前，进程是程序流执行的最小单位"},{"type":"Paragraph","children":[{"type":"Str","value":"引入线程之后，进程中的线程就成为了操作系统程序执行流的最小单位","loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":31}},"range":[80,111],"raw":"引入线程之后，进程中的线程就成为了操作系统程序执行流的最小单位"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":31}},"range":[80,111],"raw":"引入线程之后，进程中的线程就成为了操作系统程序执行流的最小单位"},{"type":"Paragraph","children":[{"type":"Str","value":"线程可以理解为“轻量级的进程”。线程是基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，不仅是进程之间可以并发，进程内的各个线程也可以并发，提高了系统的并发度，使得","loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":87}},"range":[113,200],"raw":"线程可以理解为“轻量级的进程”。线程是基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，不仅是进程之间可以并发，进程内的各个线程也可以并发，提高了系统的并发度，使得"},{"type":"Strong","children":[{"type":"Str","value":"每一个进程内也能并发处理各种任务","loc":{"start":{"line":11,"column":89},"end":{"line":11,"column":105}},"range":[202,218],"raw":"每一个进程内也能并发处理各种任务"}],"loc":{"start":{"line":11,"column":87},"end":{"line":11,"column":107}},"range":[200,220],"raw":"**每一个进程内也能并发处理各种任务**"},{"type":"Str","value":"。","loc":{"start":{"line":11,"column":107},"end":{"line":11,"column":108}},"range":[220,221],"raw":"。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":108}},"range":[113,221],"raw":"线程可以理解为“轻量级的进程”。线程是基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，不仅是进程之间可以并发，进程内的各个线程也可以并发，提高了系统的并发度，使得**每一个进程内也能并发处理各种任务**。"},{"type":"Paragraph","children":[{"type":"Str","value":"引入线程后，进程只作为除了CPU之外的系统资源的分配单元（如打印机、内存地址空间等是分配给进程的）。","loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":50}},"range":[223,273],"raw":"引入线程后，进程只作为除了CPU之外的系统资源的分配单元（如打印机、内存地址空间等是分配给进程的）。"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":50}},"range":[223,273],"raw":"引入线程后，进程只作为除了CPU之外的系统资源的分配单元（如打印机、内存地址空间等是分配给进程的）。"},{"type":"HorizontalRule","loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":5}},"range":[275,280],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"引入线程带来的变化","loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":12}},"range":[285,294],"raw":"引入线程带来的变化"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":12}},"range":[282,294],"raw":"## 引入线程带来的变化"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"资源分配、调度","loc":{"start":{"line":19,"column":4},"end":{"line":19,"column":11}},"range":[300,307],"raw":"资源分配、调度"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":11}},"range":[296,307],"raw":"### 资源分配、调度"},{"type":"Paragraph","children":[{"type":"Str","value":"在传统的进程机制中，进程是资源分配、调度的基本单位\n引入线程后，进程是资源分配的基本单位，线程是调度的基本的单位","loc":{"start":{"line":21,"column":0},"end":{"line":22,"column":30}},"range":[309,365],"raw":"在传统的进程机制中，进程是资源分配、调度的基本单位\n引入线程后，进程是资源分配的基本单位，线程是调度的基本的单位"}],"loc":{"start":{"line":21,"column":0},"end":{"line":22,"column":30}},"range":[309,365],"raw":"在传统的进程机制中，进程是资源分配、调度的基本单位\n引入线程后，进程是资源分配的基本单位，线程是调度的基本的单位"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"并发性","loc":{"start":{"line":24,"column":4},"end":{"line":24,"column":7}},"range":[371,374],"raw":"并发性"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":7}},"range":[367,374],"raw":"### 并发性"},{"type":"Paragraph","children":[{"type":"Str","value":"传统的进程机制中，只能在进程间并发\n引入线程后，各线程之间也可以并发，提高了并发度","loc":{"start":{"line":26,"column":0},"end":{"line":27,"column":23}},"range":[376,417],"raw":"传统的进程机制中，只能在进程间并发\n引入线程后，各线程之间也可以并发，提高了并发度"}],"loc":{"start":{"line":26,"column":0},"end":{"line":27,"column":23}},"range":[376,417],"raw":"传统的进程机制中，只能在进程间并发\n引入线程后，各线程之间也可以并发，提高了并发度"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"系统开销","loc":{"start":{"line":29,"column":4},"end":{"line":29,"column":8}},"range":[423,427],"raw":"系统开销"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":8}},"range":[419,427],"raw":"### 系统开销"},{"type":"Paragraph","children":[{"type":"Str","value":"传统进程机制中，切换进程需要切换进程的运行环境，系统的开销是比较大的\n引入线程之后，如果是同一进程的线程之间切换，不需要切换进程的环境，系统的开销比较小，所以引入线程之后，系统并发所带来的系统开销比较小。","loc":{"start":{"line":31,"column":0},"end":{"line":32,"column":67}},"range":[429,531],"raw":"传统进程机制中，切换进程需要切换进程的运行环境，系统的开销是比较大的\n引入线程之后，如果是同一进程的线程之间切换，不需要切换进程的环境，系统的开销比较小，所以引入线程之后，系统并发所带来的系统开销比较小。"}],"loc":{"start":{"line":31,"column":0},"end":{"line":32,"column":67}},"range":[429,531],"raw":"传统进程机制中，切换进程需要切换进程的运行环境，系统的开销是比较大的\n引入线程之后，如果是同一进程的线程之间切换，不需要切换进程的环境，系统的开销比较小，所以引入线程之后，系统并发所带来的系统开销比较小。"},{"type":"HorizontalRule","loc":{"start":{"line":34,"column":0},"end":{"line":34,"column":5}},"range":[533,538],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"线程的属性","loc":{"start":{"line":36,"column":3},"end":{"line":36,"column":8}},"range":[543,548],"raw":"线程的属性"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":8}},"range":[540,548],"raw":"## 线程的属性"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"线程是处理机调度的基本单位","loc":{"start":{"line":38,"column":2},"end":{"line":38,"column":15}},"range":[552,565],"raw":"线程是处理机调度的基本单位"}],"loc":{"start":{"line":38,"column":2},"end":{"line":38,"column":15}},"range":[552,565],"raw":"线程是处理机调度的基本单位"}],"loc":{"start":{"line":38,"column":0},"end":{"line":38,"column":15}},"range":[550,565],"raw":"- 线程是处理机调度的基本单位"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"多CPU计算机中，各个线程可以占用不同的CPU","loc":{"start":{"line":39,"column":2},"end":{"line":39,"column":25}},"range":[568,591],"raw":"多CPU计算机中，各个线程可以占用不同的CPU"}],"loc":{"start":{"line":39,"column":2},"end":{"line":39,"column":25}},"range":[568,591],"raw":"多CPU计算机中，各个线程可以占用不同的CPU"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":25}},"range":[566,591],"raw":"- 多CPU计算机中，各个线程可以占用不同的CPU"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）","loc":{"start":{"line":40,"column":2},"end":{"line":40,"column":46}},"range":[594,638],"raw":"每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）"}],"loc":{"start":{"line":40,"column":2},"end":{"line":40,"column":46}},"range":[594,638],"raw":"每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）"}],"loc":{"start":{"line":40,"column":0},"end":{"line":40,"column":46}},"range":[592,638],"raw":"- 每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"线程也有就绪、阻塞和运行三种状态","loc":{"start":{"line":41,"column":2},"end":{"line":41,"column":18}},"range":[641,657],"raw":"线程也有就绪、阻塞和运行三种状态"}],"loc":{"start":{"line":41,"column":2},"end":{"line":41,"column":18}},"range":[641,657],"raw":"线程也有就绪、阻塞和运行三种状态"}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":18}},"range":[639,657],"raw":"- 线程也有就绪、阻塞和运行三种状态"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"线程几乎不拥有系统资源","loc":{"start":{"line":42,"column":2},"end":{"line":42,"column":13}},"range":[660,671],"raw":"线程几乎不拥有系统资源"}],"loc":{"start":{"line":42,"column":2},"end":{"line":42,"column":13}},"range":[660,671],"raw":"线程几乎不拥有系统资源"}],"loc":{"start":{"line":42,"column":0},"end":{"line":42,"column":13}},"range":[658,671],"raw":"- 线程几乎不拥有系统资源"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"同一进程的不同线程共享进程的资源","loc":{"start":{"line":43,"column":2},"end":{"line":43,"column":18}},"range":[674,690],"raw":"同一进程的不同线程共享进程的资源"}],"loc":{"start":{"line":43,"column":2},"end":{"line":43,"column":18}},"range":[674,690],"raw":"同一进程的不同线程共享进程的资源"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":18}},"range":[672,690],"raw":"- 同一进程的不同线程共享进程的资源"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"同一进程的不同线程之间通信无需系统干预","loc":{"start":{"line":44,"column":2},"end":{"line":44,"column":21}},"range":[693,712],"raw":"同一进程的不同线程之间通信无需系统干预"}],"loc":{"start":{"line":44,"column":2},"end":{"line":44,"column":21}},"range":[693,712],"raw":"同一进程的不同线程之间通信无需系统干预"}],"loc":{"start":{"line":44,"column":0},"end":{"line":44,"column":21}},"range":[691,712],"raw":"- 同一进程的不同线程之间通信无需系统干预"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"同一进程的线程切换不会引起进程的切换","loc":{"start":{"line":45,"column":2},"end":{"line":45,"column":20}},"range":[715,733],"raw":"同一进程的线程切换不会引起进程的切换"}],"loc":{"start":{"line":45,"column":2},"end":{"line":45,"column":20}},"range":[715,733],"raw":"同一进程的线程切换不会引起进程的切换"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":20}},"range":[713,733],"raw":"- 同一进程的线程切换不会引起进程的切换"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"不同进程的线程切换会引起进程的切换","loc":{"start":{"line":46,"column":2},"end":{"line":46,"column":19}},"range":[736,753],"raw":"不同进程的线程切换会引起进程的切换"}],"loc":{"start":{"line":46,"column":2},"end":{"line":46,"column":19}},"range":[736,753],"raw":"不同进程的线程切换会引起进程的切换"}],"loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":19}},"range":[734,753],"raw":"- 不同进程的线程切换会引起进程的切换"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"切换同进程内的线程，系统开销很小","loc":{"start":{"line":47,"column":2},"end":{"line":47,"column":18}},"range":[756,772],"raw":"切换同进程内的线程，系统开销很小"}],"loc":{"start":{"line":47,"column":2},"end":{"line":47,"column":18}},"range":[756,772],"raw":"切换同进程内的线程，系统开销很小"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":18}},"range":[754,772],"raw":"- 切换同进程内的线程，系统开销很小"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"切换进程，系统的开销较大","loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":14}},"range":[775,787],"raw":"切换进程，系统的开销较大"}],"loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":14}},"range":[775,787],"raw":"切换进程，系统的开销较大"}],"loc":{"start":{"line":48,"column":0},"end":{"line":48,"column":14}},"range":[773,787],"raw":"- 切换进程，系统的开销较大"}],"loc":{"start":{"line":38,"column":0},"end":{"line":48,"column":14}},"range":[550,787],"raw":"- 线程是处理机调度的基本单位\n- 多CPU计算机中，各个线程可以占用不同的CPU\n- 每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）\n- 线程也有就绪、阻塞和运行三种状态\n- 线程几乎不拥有系统资源\n- 同一进程的不同线程共享进程的资源\n- 同一进程的不同线程之间通信无需系统干预\n- 同一进程的线程切换不会引起进程的切换\n- 不同进程的线程切换会引起进程的切换\n- 切换同进程内的线程，系统开销很小\n- 切换进程，系统的开销较大"},{"type":"HorizontalRule","loc":{"start":{"line":50,"column":0},"end":{"line":50,"column":5}},"range":[789,794],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"线程的实现方式","loc":{"start":{"line":52,"column":3},"end":{"line":52,"column":10}},"range":[799,806],"raw":"线程的实现方式"}],"loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":10}},"range":[796,806],"raw":"## 线程的实现方式"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"用户级线程(User-Level Thread)","loc":{"start":{"line":54,"column":4},"end":{"line":54,"column":28}},"range":[812,836],"raw":"用户级线程(User-Level Thread)"}],"loc":{"start":{"line":54,"column":0},"end":{"line":54,"column":28}},"range":[808,836],"raw":"### 用户级线程(User-Level Thread)"},{"type":"Paragraph","children":[{"type":"Str","value":"用户级线程通过线程库实现，所有的线程管理工作都由应用程序来实现（包括线程切换）。","loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":40}},"range":[838,878],"raw":"用户级线程通过线程库实现，所有的线程管理工作都由应用程序来实现（包括线程切换）。"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":40}},"range":[838,878],"raw":"用户级线程通过线程库实现，所有的线程管理工作都由应用程序来实现（包括线程切换）。"},{"type":"Paragraph","children":[{"type":"Str","value":"用户级线程中，线程的切换可以在用户态下直接完成，不需要操作系统的干预。在用户看来是有多个线程在运行，但是在操作系统看来，并不能意识到线程的存在，只能看到一整个进程。（对用户不透明，对操作系统透明）","loc":{"start":{"line":58,"column":0},"end":{"line":58,"column":98}},"range":[880,978],"raw":"用户级线程中，线程的切换可以在用户态下直接完成，不需要操作系统的干预。在用户看来是有多个线程在运行，但是在操作系统看来，并不能意识到线程的存在，只能看到一整个进程。（对用户不透明，对操作系统透明）"}],"loc":{"start":{"line":58,"column":0},"end":{"line":58,"column":98}},"range":[880,978],"raw":"用户级线程中，线程的切换可以在用户态下直接完成，不需要操作系统的干预。在用户看来是有多个线程在运行，但是在操作系统看来，并不能意识到线程的存在，只能看到一整个进程。（对用户不透明，对操作系统透明）"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"内核级进程(Kernal-Level Thread)","loc":{"start":{"line":60,"column":4},"end":{"line":60,"column":30}},"range":[984,1010],"raw":"内核级进程(Kernal-Level Thread)"}],"loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":30}},"range":[980,1010],"raw":"### 内核级进程(Kernal-Level Thread)"},{"type":"Paragraph","children":[{"type":"Str","value":"内核级线程的管理工作是由操作系统完成的，线程的调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成。","loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":60}},"range":[1012,1072],"raw":"内核级线程的管理工作是由操作系统完成的，线程的调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成。"}],"loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":60}},"range":[1012,1072],"raw":"内核级线程的管理工作是由操作系统完成的，线程的调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成。"},{"type":"Paragraph","children":[{"type":"Str","value":"内核级线程是从操作系统的视角能看到的线程。","loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":21}},"range":[1074,1095],"raw":"内核级线程是从操作系统的视角能看到的线程。"}],"loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":21}},"range":[1074,1095],"raw":"内核级线程是从操作系统的视角能看到的线程。"},{"type":"Paragraph","children":[{"type":"Str","value":"操作系统只能看到内核级线程，因此","loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":16}},"range":[1097,1113],"raw":"操作系统只能看到内核级线程，因此"},{"type":"Html","value":"<font color=\"red\">","loc":{"start":{"line":66,"column":16},"end":{"line":66,"column":34}},"range":[1113,1131],"raw":"<font color=\"red\">"},{"type":"Str","value":"只有内核级线程才是处理机分配的单位","loc":{"start":{"line":66,"column":34},"end":{"line":66,"column":51}},"range":[1131,1148],"raw":"只有内核级线程才是处理机分配的单位"},{"type":"Html","value":"</font>","loc":{"start":{"line":66,"column":51},"end":{"line":66,"column":58}},"range":[1148,1155],"raw":"</font>"},{"type":"Str","value":"！","loc":{"start":{"line":66,"column":58},"end":{"line":66,"column":59}},"range":[1155,1156],"raw":"！"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":59}},"range":[1097,1156],"raw":"操作系统只能看到内核级线程，因此<font color=\"red\">只有内核级线程才是处理机分配的单位</font>！"},{"type":"HorizontalRule","loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":5}},"range":[1158,1163],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"多线程模型","loc":{"start":{"line":70,"column":3},"end":{"line":70,"column":8}},"range":[1168,1173],"raw":"多线程模型"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":8}},"range":[1165,1173],"raw":"## 多线程模型"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"多对一模型","loc":{"start":{"line":72,"column":4},"end":{"line":72,"column":9}},"range":[1179,1184],"raw":"多对一模型"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":9}},"range":[1175,1184],"raw":"### 多对一模型"},{"type":"Paragraph","children":[{"type":"Str","value":"多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":34}},"range":[1186,1220],"raw":"多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":34}},"range":[1186,1220],"raw":"多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，线程管理的开销小，效率高。","loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":45}},"range":[1222,1267],"raw":"优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，线程管理的开销小，效率高。"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":45}},"range":[1222,1267],"raw":"优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，线程管理的开销小，效率高。"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。而且多个线程不能在多个核心上并行运行。","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":51}},"range":[1269,1320],"raw":"缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。而且多个线程不能在多个核心上并行运行。"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":51}},"range":[1269,1320],"raw":"缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。而且多个线程不能在多个核心上并行运行。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"一对一模型","loc":{"start":{"line":80,"column":4},"end":{"line":80,"column":9}},"range":[1326,1331],"raw":"一对一模型"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":9}},"range":[1322,1331],"raw":"### 一对一模型"},{"type":"Paragraph","children":[{"type":"Str","value":"一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同的内核级线程数量。","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":42}},"range":[1333,1375],"raw":"一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同的内核级线程数量。"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":42}},"range":[1333,1375],"raw":"一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同的内核级线程数量。"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多个核心上并发执行。","loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":46}},"range":[1377,1423],"raw":"优点：一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多个核心上并发执行。"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":46}},"range":[1377,1423],"raw":"优点：一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多个核心上并发执行。"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：一个用户进程会占用多个内核级进程，线程的切换由操作系统内核完成，需要切换到核心态才可以完成，线程管理的成本较高，开销较大。","loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":64}},"range":[1425,1489],"raw":"缺点：一个用户进程会占用多个内核级进程，线程的切换由操作系统内核完成，需要切换到核心态才可以完成，线程管理的成本较高，开销较大。"}],"loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":64}},"range":[1425,1489],"raw":"缺点：一个用户进程会占用多个内核级进程，线程的切换由操作系统内核完成，需要切换到核心态才可以完成，线程管理的成本较高，开销较大。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"多对多模型","loc":{"start":{"line":88,"column":4},"end":{"line":88,"column":9}},"range":[1495,1500],"raw":"多对多模型"}],"loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":9}},"range":[1491,1500],"raw":"### 多对多模型"},{"type":"Paragraph","children":[{"type":"Str","value":"n个用户级线程映射到m个内核级线程（$n \\geq m$）。每个用户进程对应了m个内核级线程。","loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":47}},"range":[1502,1549],"raw":"n个用户级线程映射到m个内核级线程（$n \\geq m$）。每个用户进程对应了m个内核级线程。"}],"loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":47}},"range":[1502,1549],"raw":"n个用户级线程映射到m个内核级线程（$n \\geq m$）。每个用户进程对应了m个内核级线程。"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：克服了一对一模型的并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点。","loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":54}},"range":[1551,1605],"raw":"优点：克服了一对一模型的并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点。"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":54}},"range":[1551,1605],"raw":"优点：克服了一对一模型的并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":93,"column":0}},"range":[0,1606],"raw":"---\ntitle: '线程、多线程模型'\ntags: ['操作系统','线程']\n---\n# 线程、多线程模型\n\n引入线程之前，进程是程序流执行的最小单位\n\n引入线程之后，进程中的线程就成为了操作系统程序执行流的最小单位\n\n线程可以理解为“轻量级的进程”。线程是基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，不仅是进程之间可以并发，进程内的各个线程也可以并发，提高了系统的并发度，使得**每一个进程内也能并发处理各种任务**。\n\n引入线程后，进程只作为除了CPU之外的系统资源的分配单元（如打印机、内存地址空间等是分配给进程的）。\n\n*****\n\n## 引入线程带来的变化\n\n### 资源分配、调度\n\n在传统的进程机制中，进程是资源分配、调度的基本单位\n引入线程后，进程是资源分配的基本单位，线程是调度的基本的单位\n\n### 并发性\n\n传统的进程机制中，只能在进程间并发\n引入线程后，各线程之间也可以并发，提高了并发度\n\n### 系统开销\n\n传统进程机制中，切换进程需要切换进程的运行环境，系统的开销是比较大的\n引入线程之后，如果是同一进程的线程之间切换，不需要切换进程的环境，系统的开销比较小，所以引入线程之后，系统并发所带来的系统开销比较小。\n\n*****\n\n## 线程的属性\n\n- 线程是处理机调度的基本单位\n- 多CPU计算机中，各个线程可以占用不同的CPU\n- 每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）\n- 线程也有就绪、阻塞和运行三种状态\n- 线程几乎不拥有系统资源\n- 同一进程的不同线程共享进程的资源\n- 同一进程的不同线程之间通信无需系统干预\n- 同一进程的线程切换不会引起进程的切换\n- 不同进程的线程切换会引起进程的切换\n- 切换同进程内的线程，系统开销很小\n- 切换进程，系统的开销较大\n\n*****\n\n## 线程的实现方式\n\n### 用户级线程(User-Level Thread)\n\n用户级线程通过线程库实现，所有的线程管理工作都由应用程序来实现（包括线程切换）。\n\n用户级线程中，线程的切换可以在用户态下直接完成，不需要操作系统的干预。在用户看来是有多个线程在运行，但是在操作系统看来，并不能意识到线程的存在，只能看到一整个进程。（对用户不透明，对操作系统透明）\n\n### 内核级进程(Kernal-Level Thread)\n\n内核级线程的管理工作是由操作系统完成的，线程的调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成。\n\n内核级线程是从操作系统的视角能看到的线程。\n\n操作系统只能看到内核级线程，因此<font color=\"red\">只有内核级线程才是处理机分配的单位</font>！\n\n*****\n\n## 多线程模型\n\n### 多对一模型\n\n多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程\n\n优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，线程管理的开销小，效率高。\n\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。而且多个线程不能在多个核心上并行运行。\n\n### 一对一模型\n\n一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同的内核级线程数量。\n\n优点：一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多个核心上并发执行。\n\n缺点：一个用户进程会占用多个内核级进程，线程的切换由操作系统内核完成，需要切换到核心态才可以完成，线程管理的成本较高，开销较大。\n\n### 多对多模型\n\nn个用户级线程映射到m个内核级线程（$n \\geq m$）。每个用户进程对应了m个内核级线程。\n\n优点：克服了一对一模型的并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点。\n"},"catalogue":{"title":"线程、多线程模型","json-path":"2020-08-12-线程、多线程模型.json","mdate":"2022-08-30T16:45:41.954Z","tags":["操作系统","线程"]}}