{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','图']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"﻿---\ntags: ['数据结构','图']\n--","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"最短路径","loc":{"start":{"line":4,"column":2},"end":{"line":4,"column":6}},"range":[29,33],"raw":" 最短路"}],"loc":{"start":{"line":4,"column":0},"end":{"line":4,"column":6}},"range":[27,33],"raw":"\n# 最短路"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Dijkstra算法（带权图单源最短路径）","loc":{"start":{"line":6,"column":3},"end":{"line":6,"column":24}},"range":[38,59],"raw":" Dijkstra算法（带权图单源最短路径"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":24}},"range":[35,59],"raw":"\n## Dijkstra算法（带权图单源最短路径"},{"type":"Paragraph","children":[{"type":"Str","value":"主要的思想也是","loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":7}},"range":[61,68],"raw":"\n主要的思想也"},{"type":"Strong","children":[{"type":"Str","value":"贪心算法","loc":{"start":{"line":8,"column":9},"end":{"line":8,"column":13}},"range":[70,74],"raw":"*贪心算"}],"loc":{"start":{"line":8,"column":7},"end":{"line":8,"column":15}},"range":[68,76],"raw":"是**贪心算法*"},{"type":"Str","value":"。","loc":{"start":{"line":8,"column":15},"end":{"line":8,"column":16}},"range":[76,77],"raw":"*"}],"loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":16}},"range":[61,77],"raw":"\n主要的思想也是**贪心算法**"},{"type":"Paragraph","children":[{"type":"Str","value":"需要如下的三个辅助数组：","loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[79,91],"raw":"\n需要如下的三个辅助数组"}],"loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":12}},"range":[79,91],"raw":"\n需要如下的三个辅助数组"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"s[]: 用于标记已经计算完成的顶点。\n数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1","loc":{"start":{"line":12,"column":2},"end":{"line":13,"column":34}},"range":[95,149],"raw":" s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为"}],"loc":{"start":{"line":12,"column":2},"end":{"line":13,"column":34}},"range":[95,149],"raw":" s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为"}],"loc":{"start":{"line":12,"column":0},"end":{"line":13,"column":34}},"range":[93,149],"raw":"\n- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"dist[]: 记录从源点  ","loc":{"start":{"line":14,"column":2},"end":{"line":14,"column":17}},"range":[152,167],"raw":" dist[]: 记录从源点 "},{"type":"InlineMath","value":"v_{0}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{0}"}]},"loc":{"start":{"line":14,"column":17},"end":{"line":14,"column":24}},"range":[167,174],"raw":" $v_{0}"},{"type":"Str","value":"  到其他各个顶点的最短路径的长度。\n数组中的值全部初始化为源点到各个顶点边的权值，即 ","loc":{"start":{"line":14,"column":24},"end":{"line":15,"column":27}},"range":[174,220],"raw":"$  到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即"},{"type":"InlineMath","value":"dist[i]=arcs[0][i]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"dist[i]=arcs[0][i]"}]},"loc":{"start":{"line":15,"column":27},"end":{"line":15,"column":47}},"range":[220,240],"raw":" $dist[i]=arcs[0][i]"}],"loc":{"start":{"line":14,"column":2},"end":{"line":15,"column":48}},"range":[152,241],"raw":" dist[]: 记录从源点  $v_{0}$  到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即 $dist[i]=arcs[0][i]$"}],"loc":{"start":{"line":14,"column":0},"end":{"line":15,"column":48}},"range":[150,241],"raw":"\n- dist[]: 记录从源点  $v_{0}$  到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即 $dist[i]=arcs[0][i]$"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 ","loc":{"start":{"line":16,"column":2},"end":{"line":16,"column":36}},"range":[244,278],"raw":" path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为"},{"type":"InlineMath","value":"v \\rightarrow v_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v \\rightarrow v_{i}"}]},"loc":{"start":{"line":16,"column":36},"end":{"line":16,"column":57}},"range":[278,299],"raw":" $v \\rightarrow v_{i}"},{"type":"Str","value":"\n最短路径上 ","loc":{"start":{"line":16,"column":58},"end":{"line":17,"column":6}},"range":[300,307],"raw":" \n最短路径上"},{"type":"InlineMath","value":"v_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{i}"}]},"loc":{"start":{"line":17,"column":6},"end":{"line":17,"column":13}},"range":[307,314],"raw":" $v_{i}"},{"type":"Str","value":" 的前驱顶点。\n初始化：若源点 ","loc":{"start":{"line":17,"column":13},"end":{"line":18,"column":10}},"range":[314,332],"raw":"$ 的前驱顶点。\n  初始化：若源点"},{"type":"InlineMath","value":"v_{0}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{0}"}]},"loc":{"start":{"line":18,"column":10},"end":{"line":18,"column":17}},"range":[332,339],"raw":" $v_{0}"},{"type":"Str","value":" 到该顶点 ","loc":{"start":{"line":18,"column":17},"end":{"line":18,"column":23}},"range":[339,345],"raw":"$ 到该顶点"},{"type":"InlineMath","value":"v_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{i}"}]},"loc":{"start":{"line":18,"column":23},"end":{"line":18,"column":30}},"range":[345,352],"raw":" $v_{i}"},{"type":"Str","value":" 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。","loc":{"start":{"line":18,"column":30},"end":{"line":18,"column":68}},"range":[352,390],"raw":"$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1"}],"loc":{"start":{"line":16,"column":2},"end":{"line":18,"column":68}},"range":[244,390],"raw":" path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 $v \\rightarrow v_{i}$ \n最短路径上 $v_{i}$ 的前驱顶点。\n  初始化：若源点 $v_{0}$ 到该顶点 $v_{i}$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1"}],"loc":{"start":{"line":16,"column":0},"end":{"line":18,"column":68}},"range":[242,390],"raw":"\n- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 $v \\rightarrow v_{i}$ \n最短路径上 $v_{i}$ 的前驱顶点。\n  初始化：若源点 $v_{0}$ 到该顶点 $v_{i}$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1"}],"loc":{"start":{"line":12,"column":0},"end":{"line":18,"column":68}},"range":[93,390],"raw":"\n- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1\n- dist[]: 记录从源点  $v_{0}$  到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即 $dist[i]=arcs[0][i]$ \n- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 $v \\rightarrow v_{i}$ \n最短路径上 $v_{i}$ 的前驱顶点。\n  初始化：若源点 $v_{0}$ 到该顶点 $v_{i}$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1"},{"type":"Paragraph","children":[{"type":"Str","value":"算法步骤：","loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":5}},"range":[392,397],"raw":"\n算法步骤"}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":5}},"range":[392,397],"raw":"\n算法步骤"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始化数组，集合S初始化为{0};","loc":{"start":{"line":22,"column":3},"end":{"line":22,"column":20}},"range":[402,419],"raw":" 初始化数组，集合S初始化为{0}"}],"loc":{"start":{"line":22,"column":3},"end":{"line":22,"column":20}},"range":[402,419],"raw":" 初始化数组，集合S初始化为{0}"}],"loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":20}},"range":[399,419],"raw":"\n1. 初始化数组，集合S初始化为{0}"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"从未计算过的顶点集V-S中选出 ","loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":19}},"range":[423,439],"raw":" 从未计算过的顶点集V-S中选出"},{"type":"InlineMath","value":"V_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"V_{j}"}]},"loc":{"start":{"line":23,"column":19},"end":{"line":23,"column":26}},"range":[439,446],"raw":" $V_{j}"},{"type":"Str","value":" 满足： ","loc":{"start":{"line":23,"column":26},"end":{"line":23,"column":31}},"range":[446,451],"raw":"$ 满足："},{"type":"InlineMath","value":"dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}"}]},"loc":{"start":{"line":23,"column":31},"end":{"line":23,"column":78}},"range":[451,498],"raw":" $dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}"},{"type":"Str","value":" ， ","loc":{"start":{"line":23,"column":78},"end":{"line":23,"column":81}},"range":[498,501],"raw":"$ ，"},{"type":"InlineMath","value":"v_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{j}"}]},"loc":{"start":{"line":23,"column":81},"end":{"line":23,"column":88}},"range":[501,508],"raw":" $v_{j}"},{"type":"Str","value":" 就是当前求得的最短路径的终点，使 ","loc":{"start":{"line":23,"column":88},"end":{"line":23,"column":106}},"range":[508,526],"raw":"$ 就是当前求得的最短路径的终点，使"},{"type":"InlineMath","value":"S = S \\cup \\{j\\}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"S = S \\cup \\{j\\}"}]},"loc":{"start":{"line":23,"column":106},"end":{"line":23,"column":124}},"range":[526,544],"raw":" $S = S \\cup \\{j\\}"},{"type":"Str","value":" ;","loc":{"start":{"line":23,"column":124},"end":{"line":23,"column":126}},"range":[544,546],"raw":"$ "}],"loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":126}},"range":[423,546],"raw":" 从未计算过的顶点集V-S中选出 $V_{j}$ 满足： $dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$ ， $v_{j}$ 就是当前求得的最短路径的终点，使 $S = S \\cup \\{j\\}$ "}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":126}},"range":[420,546],"raw":"\n2. 从未计算过的顶点集V-S中选出 $V_{j}$ 满足： $dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$ ， $v_{j}$ 就是当前求得的最短路径的终点，使 $S = S \\cup \\{j\\}$ "},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"修改此时从 ","loc":{"start":{"line":24,"column":3},"end":{"line":24,"column":9}},"range":[550,556],"raw":" 修改此时从"},{"type":"InlineMath","value":"v_{0}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{0}"}]},"loc":{"start":{"line":24,"column":9},"end":{"line":24,"column":16}},"range":[556,563],"raw":" $v_{0}"},{"type":"Str","value":" 出发到集合V-S上各个顶点 ","loc":{"start":{"line":24,"column":16},"end":{"line":24,"column":31}},"range":[563,578],"raw":"$ 出发到集合V-S上各个顶点"},{"type":"InlineMath","value":"v_{k}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{k}"}]},"loc":{"start":{"line":24,"column":31},"end":{"line":24,"column":38}},"range":[578,585],"raw":" $v_{k}"},{"type":"Str","value":" 最短路径的长度：若 ","loc":{"start":{"line":24,"column":38},"end":{"line":24,"column":49}},"range":[585,596],"raw":"$ 最短路径的长度：若"},{"type":"InlineMath","value":"dist[j]+arcs[j][k]<dist[k]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"dist[j]+arcs[j][k]<dist[k]"}]},"loc":{"start":{"line":24,"column":49},"end":{"line":24,"column":77}},"range":[596,624],"raw":" $dist[j]+arcs[j][k]<dist[k]"},{"type":"Str","value":" ，则令 ","loc":{"start":{"line":24,"column":77},"end":{"line":24,"column":82}},"range":[624,629],"raw":"$ ，则令"},{"type":"InlineMath","value":"dist[k] = dist[j] + arcs[j][k]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"dist[k] = dist[j] + arcs[j][k]"}]},"loc":{"start":{"line":24,"column":82},"end":{"line":24,"column":114}},"range":[629,661],"raw":" $dist[k] = dist[j] + arcs[j][k]"},{"type":"Str","value":" ;  ","loc":{"start":{"line":24,"column":114},"end":{"line":24,"column":118}},"range":[661,665],"raw":"$ ; "},{"type":"InlineMath","value":"path[k] = j","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"path[k] = j"}]},"loc":{"start":{"line":24,"column":118},"end":{"line":24,"column":131}},"range":[665,678],"raw":" $path[k] = j"},{"type":"Str","value":" 。","loc":{"start":{"line":24,"column":131},"end":{"line":24,"column":133}},"range":[678,680],"raw":"$ "}],"loc":{"start":{"line":24,"column":3},"end":{"line":24,"column":133}},"range":[550,680],"raw":" 修改此时从 $v_{0}$ 出发到集合V-S上各个顶点 $v_{k}$ 最短路径的长度：若 $dist[j]+arcs[j][k]<dist[k]$ ，则令 $dist[k] = dist[j] + arcs[j][k]$ ;  $path[k] = j$ "}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":133}},"range":[547,680],"raw":"\n3. 修改此时从 $v_{0}$ 出发到集合V-S上各个顶点 $v_{k}$ 最短路径的长度：若 $dist[j]+arcs[j][k]<dist[k]$ ，则令 $dist[k] = dist[j] + arcs[j][k]$ ;  $path[k] = j$ "}],"loc":{"start":{"line":22,"column":0},"end":{"line":24,"column":133}},"range":[399,680],"raw":"\n1. 初始化数组，集合S初始化为{0};\n2. 从未计算过的顶点集V-S中选出 $V_{j}$ 满足： $dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$ ， $v_{j}$ 就是当前求得的最短路径的终点，使 $S = S \\cup \\{j\\}$ ;\n3. 修改此时从 $v_{0}$ 出发到集合V-S上各个顶点 $v_{k}$ 最短路径的长度：若 $dist[j]+arcs[j][k]<dist[k]$ ，则令 $dist[k] = dist[j] + arcs[j][k]$ ;  $path[k] = j$ "},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}","loc":{"start":{"line":26,"column":0},"end":{"line":58,"column":3}},"range":[682,1498],"raw":"\n```c\n#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}\n``"},{"type":"Paragraph","children":[{"type":"Str","value":"代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是 ","loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":47}},"range":[1500,1547],"raw":"\n代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是"},{"type":"InlineMath","value":"O(\\lvert V \\rvert ^ {2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(\\lvert V \\rvert ^ {2})"}]},"loc":{"start":{"line":60,"column":47},"end":{"line":60,"column":73}},"range":[1547,1573],"raw":" $O(\\lvert V \\rvert ^ {2})"},{"type":"Str","value":" 。","loc":{"start":{"line":60,"column":73},"end":{"line":60,"column":75}},"range":[1573,1575],"raw":"$ "}],"loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":75}},"range":[1500,1575],"raw":"\n代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是 $O(\\lvert V \\rvert ^ {2})$ "},{"type":"Paragraph","children":[{"type":"Str","value":"由于Dijkstra算法是每一步都选择路径最短的顶点，","loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":27}},"range":[1577,1604],"raw":"\n由于Dijkstra算法是每一步都选择路径最短的顶点"},{"type":"Strong","children":[{"type":"Str","value":"只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）","loc":{"start":{"line":62,"column":29},"end":{"line":62,"column":66}},"range":[1606,1643],"raw":"*只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值"}],"loc":{"start":{"line":62,"column":27},"end":{"line":62,"column":68}},"range":[1604,1645],"raw":"，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）*"},{"type":"Str","value":"，如果图中含有权值为负值的边，则可能不适用此算法。","loc":{"start":{"line":62,"column":68},"end":{"line":62,"column":93}},"range":[1645,1670],"raw":"*，如果图中含有权值为负值的边，则可能不适用此算法"}],"loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":93}},"range":[1577,1670],"raw":"\n由于Dijkstra算法是每一步都选择路径最短的顶点，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**，如果图中含有权值为负值的边，则可能不适用此算法"},{"type":"Paragraph","children":[{"type":"Str","value":"例如如下的图， ","loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":8}},"range":[1672,1680],"raw":"\n例如如下的图，"},{"type":"InlineMath","value":"0 \\rightarrow 1 \\rightarrow 2","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"0 \\rightarrow 1 \\rightarrow 2"}]},"loc":{"start":{"line":64,"column":8},"end":{"line":64,"column":39}},"range":[1680,1711],"raw":" $0 \\rightarrow 1 \\rightarrow 2"},{"type":"Str","value":"  路径长度就比  ","loc":{"start":{"line":64,"column":39},"end":{"line":64,"column":49}},"range":[1711,1721],"raw":"$  路径长度就比 "},{"type":"InlineMath","value":"0 \\rightarrow 2","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"0 \\rightarrow 2"}]},"loc":{"start":{"line":64,"column":49},"end":{"line":64,"column":66}},"range":[1721,1738],"raw":" $0 \\rightarrow 2"},{"type":"Str","value":" 的路径短，但是第一步时算法就会选择 ","loc":{"start":{"line":64,"column":66},"end":{"line":64,"column":85}},"range":[1738,1757],"raw":"$ 的路径短，但是第一步时算法就会选择"},{"type":"InlineMath","value":"2","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"2"}]},"loc":{"start":{"line":64,"column":85},"end":{"line":64,"column":88}},"range":[1757,1760],"raw":" $2"},{"type":"Str","value":" ，根本无法得到路径  ","loc":{"start":{"line":64,"column":88},"end":{"line":64,"column":100}},"range":[1760,1772],"raw":"$ ，根本无法得到路径 "},{"type":"InlineMath","value":"0 \\rightarrow 1 \\rightarrow 2","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"0 \\rightarrow 1 \\rightarrow 2"}]},"loc":{"start":{"line":64,"column":100},"end":{"line":64,"column":131}},"range":[1772,1803],"raw":" $0 \\rightarrow 1 \\rightarrow 2"},{"type":"Str","value":" ：","loc":{"start":{"line":64,"column":131},"end":{"line":64,"column":133}},"range":[1803,1805],"raw":"$ "}],"loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":133}},"range":[1672,1805],"raw":"\n例如如下的图， $0 \\rightarrow 1 \\rightarrow 2$  路径长度就比  $0 \\rightarrow 2$ 的路径短，但是第一步时算法就会选择 $2$ ，根本无法得到路径  $0 \\rightarrow 1 \\rightarrow 2$ "},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png","alt":"PNG图像.png","loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":63}},"range":[1807,1870],"raw":"\n![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":63}},"range":[1807,1870],"raw":"\n![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Floyd（各顶点之间的最短路径）","loc":{"start":{"line":68,"column":3},"end":{"line":68,"column":20}},"range":[1875,1892],"raw":" Floyd（各顶点之间的最短路径"}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":20}},"range":[1872,1892],"raw":"\n## Floyd（各顶点之间的最短路径"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想（动态规划）：","loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":11}},"range":[1894,1905],"raw":"\n算法思想（动态规划）"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":11}},"range":[1894,1905],"raw":"\n算法思想（动态规划）"},{"type":"Paragraph","children":[{"type":"Str","value":"递推产生一个n阶方阵序列 ","loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":13}},"range":[1907,1920],"raw":"\n递推产生一个n阶方阵序列"},{"type":"InlineMath","value":"A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} ","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} "}]},"loc":{"start":{"line":72,"column":13},"end":{"line":72,"column":65}},"range":[1920,1972],"raw":" $A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} "},{"type":"Str","value":" ，","loc":{"start":{"line":72,"column":65},"end":{"line":72,"column":67}},"range":[1972,1974],"raw":"$ "}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":67}},"range":[1907,1974],"raw":"\n递推产生一个n阶方阵序列 $A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $ "},{"type":"Paragraph","children":[{"type":"InlineMath","value":"A^{(k)}[i][j]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(k)}[i][j]"}]},"loc":{"start":{"line":74,"column":1},"end":{"line":74,"column":16}},"range":[1977,1992],"raw":" $A^{(k)}[i][j]"},{"type":"Str","value":" : 顶点 ","loc":{"start":{"line":74,"column":16},"end":{"line":74,"column":22}},"range":[1992,1998],"raw":"$ : 顶点"},{"type":"InlineMath","value":"v_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{i}"}]},"loc":{"start":{"line":74,"column":22},"end":{"line":74,"column":29}},"range":[1998,2005],"raw":" $v_{i}"},{"type":"Str","value":" 到 ","loc":{"start":{"line":74,"column":29},"end":{"line":74,"column":32}},"range":[2005,2008],"raw":"$ 到"},{"type":"InlineMath","value":"v_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"v_{j}"}]},"loc":{"start":{"line":74,"column":32},"end":{"line":74,"column":39}},"range":[2008,2015],"raw":" $v_{j}"},{"type":"Str","value":" 的最短路径长度，且该路径经过的顶点编号不大于k。","loc":{"start":{"line":74,"column":39},"end":{"line":74,"column":64}},"range":[2015,2040],"raw":"$ 的最短路径长度，且该路径经过的顶点编号不大于k"}],"loc":{"start":{"line":74,"column":1},"end":{"line":74,"column":64}},"range":[1977,2040],"raw":" $A^{(k)}[i][j]$ : 顶点 $v_{i}$ 到 $v_{j}$ 的最短路径长度，且该路径经过的顶点编号不大于k"},{"type":"Paragraph","children":[{"type":"Str","value":"递推公式：","loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":5}},"range":[2042,2047],"raw":"\n递推公式"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":5}},"range":[2042,2047],"raw":"\n递推公式"},{"type":"Paragraph","children":[{"type":"Str","value":"初始化： ","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":5}},"range":[2049,2054],"raw":"\n初始化："},{"type":"InlineMath","value":"A^{(-1)}[i][j]=arcs[i][j]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(-1)}[i][j]=arcs[i][j]"}]},"loc":{"start":{"line":78,"column":5},"end":{"line":78,"column":32}},"range":[2054,2081],"raw":" $A^{(-1)}[i][j]=arcs[i][j]"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":33}},"range":[2049,2082],"raw":"\n初始化： $A^{(-1)}[i][j]=arcs[i][j]$"},{"type":"Paragraph","children":[{"type":"Str","value":"递推方法： ","loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":6}},"range":[2084,2090],"raw":"\n递推方法："},{"type":"InlineMath","value":"A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1"}]},"loc":{"start":{"line":80,"column":6},"end":{"line":80,"column":94}},"range":[2090,2178],"raw":" $A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1"},{"type":"Str","value":" ，其中 ","loc":{"start":{"line":80,"column":94},"end":{"line":80,"column":99}},"range":[2178,2183],"raw":"$ ，其中"},{"type":"InlineMath","value":"A^{(k-1)}[i][k]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(k-1)}[i][k]"}]},"loc":{"start":{"line":80,"column":99},"end":{"line":80,"column":116}},"range":[2183,2200],"raw":" $A^{(k-1)}[i][k]"},{"type":"Str","value":" 就是从起始顶点到顶点k的路径， ","loc":{"start":{"line":80,"column":116},"end":{"line":80,"column":133}},"range":[2200,2217],"raw":"$ 就是从起始顶点到顶点k的路径，"},{"type":"InlineMath","value":"A^{(k-1)}[k][j]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"A^{(k-1)}[k][j]"}]},"loc":{"start":{"line":80,"column":133},"end":{"line":80,"column":150}},"range":[2217,2234],"raw":" $A^{(k-1)}[k][j]"},{"type":"Str","value":" 就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。","loc":{"start":{"line":80,"column":150},"end":{"line":80,"column":231}},"range":[2234,2315],"raw":"$ 就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":231}},"range":[2084,2315],"raw":"\n递推方法： $A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1$ ，其中 $A^{(k-1)}[i][k]$ 就是从起始顶点到顶点k的路径， $A^{(k-1)}[k][j]$ 就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}","loc":{"start":{"line":82,"column":0},"end":{"line":102,"column":3}},"range":[2317,2755],"raw":"\n```c\n#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}\n``"},{"type":"Paragraph","children":[{"type":"Str","value":"Floyd算法的时间复杂度是 ","loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":15}},"range":[2757,2772],"raw":"\nFloyd算法的时间复杂度是"},{"type":"InlineMath","value":"O(\\lvert V \\rvert ^ {3})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(\\lvert V \\rvert ^ {3})"}]},"loc":{"start":{"line":104,"column":15},"end":{"line":104,"column":41}},"range":[2772,2798],"raw":" $O(\\lvert V \\rvert ^ {3})"},{"type":"Str","value":" ，可以算出任意两个结点之间的最短路径，且可以包含负值。","loc":{"start":{"line":104,"column":41},"end":{"line":104,"column":69}},"range":[2798,2826],"raw":"$ ，可以算出任意两个结点之间的最短路径，且可以包含负值"}],"loc":{"start":{"line":104,"column":0},"end":{"line":104,"column":69}},"range":[2757,2826],"raw":"\nFloyd算法的时间复杂度是 $O(\\lvert V \\rvert ^ {3})$ ，可以算出任意两个结点之间的最短路径，且可以包含负值"}],"loc":{"start":{"line":1,"column":0},"end":{"line":105,"column":0}},"range":[0,2827],"raw":"﻿---\ntags: ['数据结构','图']\n---\n# 最短路径\n\n## Dijkstra算法（带权图单源最短路径）\n\n主要的思想也是**贪心算法**。\n\n需要如下的三个辅助数组：\n\n- s[]: 用于标记已经计算完成的顶点。\n  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1\n- dist[]: 记录从源点  $v_{0}$  到其他各个顶点的最短路径的长度。\n  数组中的值全部初始化为源点到各个顶点边的权值，即 $dist[i]=arcs[0][i]$ \n- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 $v \\rightarrow v_{i}$ \n最短路径上 $v_{i}$ 的前驱顶点。\n  初始化：若源点 $v_{0}$ 到该顶点 $v_{i}$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。\n\n算法步骤：\n\n1. 初始化数组，集合S初始化为{0};\n2. 从未计算过的顶点集V-S中选出 $V_{j}$ 满足： $dist[j] = Min\\{dist[i] \\lvert v_{i} \\in V-S\\}$ ， $v_{j}$ 就是当前求得的最短路径的终点，使 $S = S \\cup \\{j\\}$ ;\n3. 修改此时从 $v_{0}$ 出发到集合V-S上各个顶点 $v_{k}$ 最短路径的长度：若 $dist[j]+arcs[j][k]<dist[k]$ ，则令 $dist[k] = dist[j] + arcs[j][k]$ ;  $path[k] = j$ 。\n\n```c\n#define MAX 999999 // MAX代表无穷大\n\nvoid Dijkstra(Graph G, int v){\n    // 初始化辅助数组\n    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];\n    for(int i=0; i<G.vexnum; i++){\n        s[i] = 0;\n        dist[i] = G.Edge[v][i];\n        path[i] = G.Edge[v][i] < MAX ? v : -1;\n    }\n    s[v] = 1;\n    path[v] = -1;\n    // 在未计算过的顶点中寻找路径最短的顶点\n    for(int i=0; i<G.vexnum; i++){\n        int min = MAX, u;\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0 && dist[j] < min){\n                min = dist[j];\n                u = j;\n            }\n        }\n        s[u] = 1; // 标记未已经计算过的顶点\n        // 修改从源点到其他各个顶点的路径长度\n        for(int j=0; j<G.vexnum; j++){\n            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){\n                dist[j]=dist[u]+G.Edge[u][i];\n                path[j]=u;\n            }\n        }\n    }\n}\n```\n\n代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是 $O(\\lvert V \\rvert ^ {2})$ 。\n\n由于Dijkstra算法是每一步都选择路径最短的顶点，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**，如果图中含有权值为负值的边，则可能不适用此算法。\n\n例如如下的图， $0 \\rightarrow 1 \\rightarrow 2$  路径长度就比  $0 \\rightarrow 2$ 的路径短，但是第一步时算法就会选择 $2$ ，根本无法得到路径  $0 \\rightarrow 1 \\rightarrow 2$ ：\n\n![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png)\n\n## Floyd（各顶点之间的最短路径）\n\n算法思想（动态规划）：\n\n递推产生一个n阶方阵序列 $A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $ ，\n\n $A^{(k)}[i][j]$ : 顶点 $v_{i}$ 到 $v_{j}$ 的最短路径长度，且该路径经过的顶点编号不大于k。\n\n递推公式：\n\n初始化： $A^{(-1)}[i][j]=arcs[i][j]$ \n\n递推方法： $A^{(k)}[i][j]=min\\\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\\\}, k=0,1,...,n-1$ ，其中 $A^{(k-1)}[i][k]$ 就是从起始顶点到顶点k的路径， $A^{(k-1)}[k][j]$ 就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。\n\n```c\n#define VEXNUM 10\n\nvoid Floyd(Graph G){\n    int A[VEXNUM][VEXNUM];\n    // 初始化\n    for(int i=0; i<VEXNUM; i++){\n        for(int j=0; i<VEXNUM; j++){\n            A[i][j] = G.Edge[i][j];\n        }\n    }\n    // 递推\n    for(int k=0; k<VEXNUM; k++){\n        for(int i=0; i<VEXNUM; i++){\n            for(int j=0; j<VEXNUM; j++){\n                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];\n            }\n        }\n    }\n}\n```\n\nFloyd算法的时间复杂度是 $O(\\lvert V \\rvert ^ {3})$ ，可以算出任意两个结点之间的最短路径，且可以包含负值。"},"catalogue":{"title":"最短路径","json-path":"数据结构/2020-08-02-最短路径.json","mdate":"2020-08-02","cover":"https://i.328888.xyz/2022/12/31/ndNlC.jpeg","icon":"🐻","visible":true,"tags":["数据结构","图"]}}