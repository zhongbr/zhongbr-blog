{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '散列表'\ntags: ['数据结构','散列表','查找']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,46],"raw":"﻿---\ntitle: '散列表'\ntags: ['数据结构','散列表','查找']\n--","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"散列表","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":5}},"range":[49,52],"raw":" 散列"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":5}},"range":[47,52],"raw":"\n# 散列"},{"type":"Paragraph","children":[{"type":"Str","value":"散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。","loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":45}},"range":[54,99],"raw":"\n散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":45}},"range":[54,99],"raw":"\n散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"1. 散列函数","loc":{"start":{"line":9,"column":3},"end":{"line":9,"column":10}},"range":[104,111],"raw":" 1. 散列函"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":10}},"range":[101,111],"raw":"\n## 1. 散列函"},{"type":"Paragraph","children":[{"type":"Str","value":"散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。","loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":30}},"range":[113,143],"raw":"\n散列函数：把查找表中的关键字映射成该关键字对应的地址的函数"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":30}},"range":[113,143],"raw":"\n散列函数：把查找表中的关键字映射成该关键字对应的地址的函数"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"1.1 散列函数的要求","loc":{"start":{"line":13,"column":4},"end":{"line":13,"column":15}},"range":[149,160],"raw":" 1.1 散列函数的要"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":15}},"range":[145,160],"raw":"\n### 1.1 散列函数的要"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。","loc":{"start":{"line":15,"column":3},"end":{"line":15,"column":48}},"range":[165,210],"raw":" 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围"}],"loc":{"start":{"line":15,"column":3},"end":{"line":15,"column":48}},"range":[165,210],"raw":" 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":48}},"range":[162,210],"raw":"\n1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。","loc":{"start":{"line":16,"column":3},"end":{"line":16,"column":44}},"range":[214,255],"raw":" 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生"}],"loc":{"start":{"line":16,"column":3},"end":{"line":16,"column":44}},"range":[214,255],"raw":" 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":44}},"range":[211,255],"raw":"\n2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址","loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":36}},"range":[259,292],"raw":" 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地"}],"loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":36}},"range":[259,292],"raw":" 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":36}},"range":[256,292],"raw":"\n3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地"}],"loc":{"start":{"line":15,"column":0},"end":{"line":17,"column":36}},"range":[162,292],"raw":"\n1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。\n3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"1.2 散列函数的构造方法","loc":{"start":{"line":19,"column":4},"end":{"line":19,"column":17}},"range":[298,311],"raw":" 1.2 散列函数的构造方"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":17}},"range":[294,311],"raw":"\n### 1.2 散列函数的构造方"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.1 直接定址法","loc":{"start":{"line":21,"column":5},"end":{"line":21,"column":16}},"range":[318,329],"raw":" 1.2.1 直接定址"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":16}},"range":[313,329],"raw":"\n#### 1.2.1 直接定址"},{"type":"Paragraph","children":[{"type":"Str","value":"直接取关键字的某个线性函数的散列地址","loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":18}},"range":[331,349],"raw":"\n直接取关键字的某个线性函数的散列地"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":18}},"range":[331,349],"raw":"\n直接取关键字的某个线性函数的散列地"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：","loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":3}},"range":[351,354],"raw":"\n优点"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":3}},"range":[351,354],"raw":"\n优点"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"方法简单，不会产生冲突","loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":13}},"range":[358,369],"raw":" 方法简单，不会产生冲"}],"loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":13}},"range":[358,369],"raw":" 方法简单，不会产生冲"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":13}},"range":[356,369],"raw":"\n- 方法简单，不会产生冲"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":13}},"range":[356,369],"raw":"\n- 方法简单，不会产生冲"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：","loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":3}},"range":[371,374],"raw":"\n缺点"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":3}},"range":[371,374],"raw":"\n缺点"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"关键字分布不连续的时候会浪费空间","loc":{"start":{"line":31,"column":2},"end":{"line":31,"column":18}},"range":[378,394],"raw":" 关键字分布不连续的时候会浪费空"}],"loc":{"start":{"line":31,"column":2},"end":{"line":31,"column":18}},"range":[378,394],"raw":" 关键字分布不连续的时候会浪费空"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":18}},"range":[376,394],"raw":"\n- 关键字分布不连续的时候会浪费空"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":18}},"range":[376,394],"raw":"\n- 关键字分布不连续的时候会浪费空"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.2 除留取余法","loc":{"start":{"line":33,"column":5},"end":{"line":33,"column":16}},"range":[401,412],"raw":" 1.2.2 除留取余"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":16}},"range":[396,412],"raw":"\n#### 1.2.2 除留取余"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"Hash(key)=key\\%p","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"Hash(key)=key\\%p"}]},"loc":{"start":{"line":35,"column":1},"end":{"line":35,"column":19}},"range":[415,433],"raw":" $Hash(key)=key\\%p"},{"type":"Str","value":" ，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。","loc":{"start":{"line":35,"column":19},"end":{"line":35,"column":58}},"range":[433,472],"raw":"$ ，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p"}],"loc":{"start":{"line":35,"column":1},"end":{"line":35,"column":58}},"range":[415,472],"raw":" $Hash(key)=key\\%p$ ，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.3 数字分析法","loc":{"start":{"line":37,"column":5},"end":{"line":37,"column":16}},"range":[479,490],"raw":" 1.2.3 数字分析"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":16}},"range":[474,490],"raw":"\n#### 1.2.3 数字分析"},{"type":"Paragraph","children":[{"type":"Str","value":"选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":60}},"range":[492,552],"raw":"\n选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":60}},"range":[492,552],"raw":"\n选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.4 平方取中法","loc":{"start":{"line":41,"column":5},"end":{"line":41,"column":16}},"range":[559,570],"raw":" 1.2.4 平方取中"}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":16}},"range":[554,570],"raw":"\n#### 1.2.4 平方取中"},{"type":"Paragraph","children":[{"type":"Str","value":"取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。","loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":50}},"range":[572,622],"raw":"\n取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":50}},"range":[572,622],"raw":"\n取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.5 折叠法","loc":{"start":{"line":45,"column":5},"end":{"line":45,"column":14}},"range":[629,638],"raw":" 1.2.5 折叠"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":14}},"range":[624,638],"raw":"\n#### 1.2.5 折叠"},{"type":"Paragraph","children":[{"type":"Str","value":"将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":36}},"range":[640,676],"raw":"\n将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":36}},"range":[640,676],"raw":"\n将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于关键字的位数多，且关键字每位数分布均匀的情况。","loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":26}},"range":[678,704],"raw":"\n适用于关键字的位数多，且关键字每位数分布均匀的情况"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":26}},"range":[678,704],"raw":"\n适用于关键字的位数多，且关键字每位数分布均匀的情况"},{"type":"HorizontalRule","loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":5}},"range":[706,711],"raw":"\n****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"2. 冲突","loc":{"start":{"line":53,"column":3},"end":{"line":53,"column":8}},"range":[716,721],"raw":" 2. 冲"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":8}},"range":[713,721],"raw":"\n## 2. 冲"},{"type":"Paragraph","children":[{"type":"Str","value":"冲突：散列函数可能存在把多个值映射到同一个地址的可能。","loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":27}},"range":[723,750],"raw":"\n冲突：散列函数可能存在把多个值映射到同一个地址的可能"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":27}},"range":[723,750],"raw":"\n冲突：散列函数可能存在把多个值映射到同一个地址的可能"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"2.1 开放定址法","loc":{"start":{"line":57,"column":4},"end":{"line":57,"column":13}},"range":[756,765],"raw":" 2.1 开放定址"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":13}},"range":[752,765],"raw":"\n### 2.1 开放定址"},{"type":"Paragraph","children":[{"type":"Str","value":"可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。","loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":34}},"range":[767,801],"raw":"\n可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放"}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":34}},"range":[767,801],"raw":"\n可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)"}]},"loc":{"start":{"line":61,"column":1},"end":{"line":61,"column":52}},"range":[804,855],"raw":" $H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)"},{"type":"Str","value":" ; m为散列表表长， ","loc":{"start":{"line":61,"column":52},"end":{"line":61,"column":64}},"range":[855,867],"raw":"$ ; m为散列表表长，"},{"type":"InlineMath","value":"d_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{i}"}]},"loc":{"start":{"line":61,"column":64},"end":{"line":61,"column":71}},"range":[867,874],"raw":" $d_{i}"},{"type":"Str","value":" 为增量序列。","loc":{"start":{"line":61,"column":71},"end":{"line":61,"column":78}},"range":[874,881],"raw":"$ 为增量序列"}],"loc":{"start":{"line":61,"column":1},"end":{"line":61,"column":78}},"range":[804,881],"raw":" $H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)$ ; m为散列表表长， $d_{i}$ 为增量序列"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"2.1.1 增量序列的计算方法","loc":{"start":{"line":63,"column":5},"end":{"line":63,"column":20}},"range":[888,903],"raw":" 2.1.1 增量序列的计算方"}],"loc":{"start":{"line":63,"column":0},"end":{"line":63,"column":20}},"range":[883,903],"raw":"\n#### 2.1.1 增量序列的计算方"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.1 线性探查法","loc":{"start":{"line":65,"column":6},"end":{"line":65,"column":19}},"range":[911,924],"raw":" 2.1.1.1 线性探查"}],"loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":19}},"range":[905,924],"raw":"\n##### 2.1.1.1 线性探查"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"d_{i} = 0,1,2,3,...,m-1","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{i} = 0,1,2,3,...,m-1"}]},"loc":{"start":{"line":67,"column":1},"end":{"line":67,"column":26}},"range":[927,952],"raw":" $d_{i} = 0,1,2,3,...,m-1"}],"loc":{"start":{"line":67,"column":1},"end":{"line":67,"column":27}},"range":[927,953],"raw":" $d_{i} = 0,1,2,3,...,m-1$"},{"type":"Paragraph","children":[{"type":"Str","value":"存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。","loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":48}},"range":[955,1003],"raw":"\n存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推"}],"loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":48}},"range":[955,1003],"raw":"\n存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推"},{"type":"Paragraph","children":[{"type":"Str","value":"查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。","loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":83}},"range":[1005,1088],"raw":"\n查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止"}],"loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":83}},"range":[1005,1088],"raw":"\n查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止"},{"type":"Header","depth":6,"children":[{"type":"Str","value":"缺点","loc":{"start":{"line":73,"column":7},"end":{"line":73,"column":9}},"range":[1097,1099],"raw":" 缺"}],"loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":9}},"range":[1090,1099],"raw":"\n###### 缺"},{"type":"Paragraph","children":[{"type":"Str","value":"存在堆积现象，大大降低查找效率","loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":15}},"range":[1101,1116],"raw":"\n存在堆积现象，大大降低查找效"}],"loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":15}},"range":[1101,1116],"raw":"\n存在堆积现象，大大降低查找效"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.2 平方探测法","loc":{"start":{"line":77,"column":6},"end":{"line":77,"column":19}},"range":[1124,1137],"raw":" 2.1.1.2 平方探测"}],"loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":19}},"range":[1118,1137],"raw":"\n##### 2.1.1.2 平方探测"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}"}]},"loc":{"start":{"line":79,"column":1},"end":{"line":79,"column":63}},"range":[1140,1202],"raw":" $d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}"},{"type":"Str","value":" ，其中 ","loc":{"start":{"line":79,"column":63},"end":{"line":79,"column":68}},"range":[1202,1207],"raw":"$ ，其中"},{"type":"InlineMath","value":"k \\leq m/2","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"k \\leq m/2"}]},"loc":{"start":{"line":79,"column":68},"end":{"line":79,"column":80}},"range":[1207,1219],"raw":" $k \\leq m/2"}],"loc":{"start":{"line":79,"column":1},"end":{"line":79,"column":81}},"range":[1140,1220],"raw":" $d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$ ，其中 $k \\leq m/2$"},{"type":"Paragraph","children":[{"type":"Str","value":"可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）","loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":39}},"range":[1222,1261],"raw":"\n可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元"}],"loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":39}},"range":[1222,1261],"raw":"\n可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.3 再散列法","loc":{"start":{"line":83,"column":6},"end":{"line":83,"column":18}},"range":[1269,1281],"raw":" 2.1.1.3 再散列"}],"loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":18}},"range":[1263,1281],"raw":"\n##### 2.1.1.3 再散列"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"d_{i}=i*Hash2(key)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{i}=i*Hash2(key)"}]},"loc":{"start":{"line":85,"column":1},"end":{"line":85,"column":21}},"range":[1284,1304],"raw":" $d_{i}=i*Hash2(key)"}],"loc":{"start":{"line":85,"column":1},"end":{"line":85,"column":22}},"range":[1284,1305],"raw":" $d_{i}=i*Hash2(key)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.4 伪随机序列法","loc":{"start":{"line":87,"column":6},"end":{"line":87,"column":20}},"range":[1313,1327],"raw":" 2.1.1.4 伪随机序列"}],"loc":{"start":{"line":87,"column":0},"end":{"line":87,"column":20}},"range":[1307,1327],"raw":"\n##### 2.1.1.4 伪随机序列"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"d_{i}=伪随机序列","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{i}=伪随机序列"}]},"loc":{"start":{"line":89,"column":1},"end":{"line":89,"column":14}},"range":[1330,1343],"raw":" $d_{i}=伪随机序列"}],"loc":{"start":{"line":89,"column":1},"end":{"line":89,"column":15}},"range":[1330,1344],"raw":" $d_{i}=伪随机序列$"},{"type":"Paragraph","children":[{"type":"Html","value":"<font color=\"red\">","loc":{"start":{"line":91,"column":0},"end":{"line":91,"column":18}},"range":[1346,1364],"raw":"\n<font color=\"red\""},{"type":"Str","value":"开放定址法不能随意删除表项，否则可能造成其他表项查找失败。","loc":{"start":{"line":91,"column":18},"end":{"line":91,"column":47}},"range":[1364,1393],"raw":">开放定址法不能随意删除表项，否则可能造成其他表项查找失败"},{"type":"Html","value":"</font>","loc":{"start":{"line":91,"column":47},"end":{"line":91,"column":54}},"range":[1393,1400],"raw":"。</font"}],"loc":{"start":{"line":91,"column":0},"end":{"line":91,"column":54}},"range":[1346,1400],"raw":"\n<font color=\"red\">开放定址法不能随意删除表项，否则可能造成其他表项查找失败。</font"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"2.2 拉链法","loc":{"start":{"line":93,"column":4},"end":{"line":93,"column":11}},"range":[1406,1413],"raw":" 2.2 拉链"}],"loc":{"start":{"line":93,"column":0},"end":{"line":93,"column":11}},"range":[1402,1413],"raw":"\n### 2.2 拉链"},{"type":"Paragraph","children":[{"type":"Str","value":"把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。","loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":51}},"range":[1415,1466],"raw":"\n把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针"}],"loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":51}},"range":[1415,1466],"raw":"\n把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于经常插入和删除的情况，会增加指针域，占用空间。","loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":26}},"range":[1468,1494],"raw":"\n适用于经常插入和删除的情况，会增加指针域，占用空间"}],"loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":26}},"range":[1468,1494],"raw":"\n适用于经常插入和删除的情况，会增加指针域，占用空间"},{"type":"HorizontalRule","loc":{"start":{"line":99,"column":0},"end":{"line":99,"column":5}},"range":[1496,1501],"raw":"\n****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"3 查找","loc":{"start":{"line":101,"column":3},"end":{"line":101,"column":7}},"range":[1506,1510],"raw":" 3 查"}],"loc":{"start":{"line":101,"column":0},"end":{"line":101,"column":7}},"range":[1503,1510],"raw":"\n## 3 查"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"3.1 查找效率","loc":{"start":{"line":103,"column":4},"end":{"line":103,"column":12}},"range":[1516,1524],"raw":" 3.1 查找效"}],"loc":{"start":{"line":103,"column":0},"end":{"line":103,"column":12}},"range":[1512,1524],"raw":"\n### 3.1 查找效"},{"type":"Paragraph","children":[{"type":"Str","value":"与散列函数、处理冲突和填装因子有关","loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":17}},"range":[1526,1543],"raw":"\n与散列函数、处理冲突和填装因子有"}],"loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":17}},"range":[1526,1543],"raw":"\n与散列函数、处理冲突和填装因子有"},{"type":"Paragraph","children":[{"type":"Str","value":"填装因子 ","loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":5}},"range":[1545,1550],"raw":"\n填装因子"},{"type":"InlineMath","value":"\\alpha = \\frac{表中记录数n}{散列表长度m}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"\\alpha = \\frac{表中记录数n}{散列表长度m}"}]},"loc":{"start":{"line":107,"column":5},"end":{"line":107,"column":37}},"range":[1550,1582],"raw":" $\\alpha = \\frac{表中记录数n}{散列表长度m}"}],"loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":38}},"range":[1545,1583],"raw":"\n填装因子 $\\alpha = \\frac{表中记录数n}{散列表长度m}$"}],"loc":{"start":{"line":1,"column":0},"end":{"line":108,"column":0}},"range":[0,1584],"raw":"﻿---\ntitle: '散列表'\ntags: ['数据结构','散列表','查找']\n---\n# 散列表\n\n散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。\n\n## 1. 散列函数\n\n散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。\n\n### 1.1 散列函数的要求\n\n1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。\n3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址\n\n### 1.2 散列函数的构造方法\n\n#### 1.2.1 直接定址法\n\n直接取关键字的某个线性函数的散列地址\n\n优点：\n\n- 方法简单，不会产生冲突\n\n缺点：\n\n- 关键字分布不连续的时候会浪费空间\n\n#### 1.2.2 除留取余法\n\n $Hash(key)=key\\%p$ ，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。\n\n#### 1.2.3 数字分析法\n\n选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。\n\n#### 1.2.4 平方取中法\n\n取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。\n\n#### 1.2.5 折叠法\n\n将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。\n\n适用于关键字的位数多，且关键字每位数分布均匀的情况。\n\n*****\n\n## 2. 冲突\n\n冲突：散列函数可能存在把多个值映射到同一个地址的可能。\n\n### 2.1 开放定址法\n\n可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。\n\n $H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)$ ; m为散列表表长， $d_{i}$ 为增量序列。\n\n#### 2.1.1 增量序列的计算方法\n\n##### 2.1.1.1 线性探查法\n\n $d_{i} = 0,1,2,3,...,m-1$ \n\n存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。\n\n查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。\n\n###### 缺点\n\n存在堆积现象，大大降低查找效率\n\n##### 2.1.1.2 平方探测法\n\n $d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$ ，其中 $k \\leq m/2$ \n\n可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）\n\n##### 2.1.1.3 再散列法\n\n $d_{i}=i*Hash2(key)$ \n\n##### 2.1.1.4 伪随机序列法\n\n $d_{i}=伪随机序列$ \n\n<font color=\"red\">开放定址法不能随意删除表项，否则可能造成其他表项查找失败。</font>\n\n### 2.2 拉链法\n\n把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。\n\n适用于经常插入和删除的情况，会增加指针域，占用空间。\n\n*****\n\n## 3 查找\n\n### 3.1 查找效率\n\n与散列函数、处理冲突和填装因子有关\n\n填装因子 $\\alpha = \\frac{表中记录数n}{散列表长度m}$ "},"catalogue":{"title":"散列表","json-path":"数据结构/2020-08-08-散列表.json","mdate":"2020-08-08","cover":"https://i.328888.xyz/2022/12/31/ndmRJ.jpeg","icon":"⭐️","visible":true,"tags":["数据结构","散列表","查找"]}}