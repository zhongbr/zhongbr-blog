{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '各种排序算法总结'\ntags: ['数据结构','排序']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,45],"raw":"﻿---\ntitle: '各种排序算法总结'\ntags: ['数据结构','排序']\n--","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"排序的基本概念","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":9}},"range":[48,55],"raw":" 排序的基本概"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":9}},"range":[46,55],"raw":"\n# 排序的基本概"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"各种排序算法汇总","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":11}},"range":[60,68],"raw":" 各种排序算法汇"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":11}},"range":[57,68],"raw":"\n## 各种排序算法汇"},{"type":"Table","align":[null,null,null,null,null,null,null],"children":[{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"算法","loc":{"start":{"line":9,"column":1},"end":{"line":9,"column":3}},"range":[71,73],"raw":"|算"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":4}},"range":[70,74],"raw":"\n|算法"},{"type":"TableCell","children":[{"type":"Str","value":"类别","loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":6}},"range":[74,76],"raw":"|类"}],"loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":7}},"range":[74,77],"raw":"|类别"},{"type":"TableCell","children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":9,"column":7},"end":{"line":9,"column":12}},"range":[77,82],"raw":"|时间复杂"}],"loc":{"start":{"line":9,"column":7},"end":{"line":9,"column":13}},"range":[77,83],"raw":"|时间复杂度"},{"type":"TableCell","children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":9,"column":13},"end":{"line":9,"column":18}},"range":[83,88],"raw":"|空间复杂"}],"loc":{"start":{"line":9,"column":13},"end":{"line":9,"column":19}},"range":[83,89],"raw":"|空间复杂度"},{"type":"TableCell","children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":9,"column":19},"end":{"line":9,"column":22}},"range":[89,92],"raw":"|稳定"}],"loc":{"start":{"line":9,"column":19},"end":{"line":9,"column":23}},"range":[89,93],"raw":"|稳定性"},{"type":"TableCell","children":[{"type":"Str","value":"支持顺序存储结构","loc":{"start":{"line":9,"column":23},"end":{"line":9,"column":31}},"range":[93,101],"raw":"|支持顺序存储结"}],"loc":{"start":{"line":9,"column":23},"end":{"line":9,"column":32}},"range":[93,102],"raw":"|支持顺序存储结构"},{"type":"TableCell","children":[{"type":"Str","value":"支持链式存储结构","loc":{"start":{"line":9,"column":32},"end":{"line":9,"column":40}},"range":[102,110],"raw":"|支持链式存储结"}],"loc":{"start":{"line":9,"column":32},"end":{"line":9,"column":41}},"range":[102,111],"raw":"|支持链式存储结构"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":41}},"range":[70,111],"raw":"\n|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"直接插入排序","loc":{"start":{"line":11,"column":1},"end":{"line":11,"column":7}},"range":[129,135],"raw":"|直接插入排"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":8}},"range":[128,136],"raw":"\n|直接插入排序"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":11,"column":8},"end":{"line":11,"column":12}},"range":[136,140],"raw":"|插入排"}],"loc":{"start":{"line":11,"column":8},"end":{"line":11,"column":13}},"range":[136,141],"raw":"|插入排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":11,"column":14},"end":{"line":11,"column":24}},"range":[142,152],"raw":" $O(n^{2})"}],"loc":{"start":{"line":11,"column":13},"end":{"line":11,"column":26}},"range":[141,154],"raw":"| $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":11,"column":27},"end":{"line":11,"column":33}},"range":[155,161],"raw":" $O(1)"}],"loc":{"start":{"line":11,"column":26},"end":{"line":11,"column":35}},"range":[154,163],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":11,"column":35},"end":{"line":11,"column":37}},"range":[163,165],"raw":"|稳"}],"loc":{"start":{"line":11,"column":35},"end":{"line":11,"column":38}},"range":[163,166],"raw":"|稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":11,"column":38},"end":{"line":11,"column":40}},"range":[166,168],"raw":"|支"}],"loc":{"start":{"line":11,"column":38},"end":{"line":11,"column":41}},"range":[166,169],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":11,"column":41},"end":{"line":11,"column":43}},"range":[169,171],"raw":"|支"}],"loc":{"start":{"line":11,"column":41},"end":{"line":11,"column":44}},"range":[169,172],"raw":"|支持"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":44}},"range":[128,172],"raw":"\n|直接插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"折半插入排序","loc":{"start":{"line":12,"column":1},"end":{"line":12,"column":7}},"range":[174,180],"raw":"|折半插入排"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":8}},"range":[173,181],"raw":"\n|折半插入排序"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":12,"column":8},"end":{"line":12,"column":12}},"range":[181,185],"raw":"|插入排"}],"loc":{"start":{"line":12,"column":8},"end":{"line":12,"column":13}},"range":[181,186],"raw":"|插入排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":12,"column":14},"end":{"line":12,"column":24}},"range":[187,197],"raw":" $O(n^{2})"}],"loc":{"start":{"line":12,"column":13},"end":{"line":12,"column":26}},"range":[186,199],"raw":"| $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":12,"column":27},"end":{"line":12,"column":33}},"range":[200,206],"raw":" $O(1)"}],"loc":{"start":{"line":12,"column":26},"end":{"line":12,"column":35}},"range":[199,208],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":12,"column":35},"end":{"line":12,"column":37}},"range":[208,210],"raw":"|稳"}],"loc":{"start":{"line":12,"column":35},"end":{"line":12,"column":38}},"range":[208,211],"raw":"|稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":12,"column":38},"end":{"line":12,"column":40}},"range":[211,213],"raw":"|支"}],"loc":{"start":{"line":12,"column":38},"end":{"line":12,"column":41}},"range":[211,214],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"不支持","loc":{"start":{"line":12,"column":41},"end":{"line":12,"column":44}},"range":[214,217],"raw":"|不支"}],"loc":{"start":{"line":12,"column":41},"end":{"line":12,"column":45}},"range":[214,218],"raw":"|不支持"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":45}},"range":[173,218],"raw":"\n|折半插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|不支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"希尔排序","loc":{"start":{"line":13,"column":1},"end":{"line":13,"column":5}},"range":[220,224],"raw":"|希尔排"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":6}},"range":[219,225],"raw":"\n|希尔排序"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":13,"column":6},"end":{"line":13,"column":10}},"range":[225,229],"raw":"|插入排"}],"loc":{"start":{"line":13,"column":6},"end":{"line":13,"column":11}},"range":[225,230],"raw":"|插入排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":13,"column":12},"end":{"line":13,"column":22}},"range":[231,241],"raw":" $O(n^{2})"}],"loc":{"start":{"line":13,"column":11},"end":{"line":13,"column":24}},"range":[230,243],"raw":"| $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":13,"column":25},"end":{"line":13,"column":31}},"range":[244,250],"raw":" $O(1)"}],"loc":{"start":{"line":13,"column":24},"end":{"line":13,"column":33}},"range":[243,252],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":13,"column":33},"end":{"line":13,"column":36}},"range":[252,255],"raw":"|不稳"}],"loc":{"start":{"line":13,"column":33},"end":{"line":13,"column":37}},"range":[252,256],"raw":"|不稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":13,"column":37},"end":{"line":13,"column":39}},"range":[256,258],"raw":"|支"}],"loc":{"start":{"line":13,"column":37},"end":{"line":13,"column":40}},"range":[256,259],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"不支持","loc":{"start":{"line":13,"column":40},"end":{"line":13,"column":43}},"range":[259,262],"raw":"|不支"}],"loc":{"start":{"line":13,"column":40},"end":{"line":13,"column":44}},"range":[259,263],"raw":"|不支持"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":44}},"range":[219,263],"raw":"\n|希尔排序|插入排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|不支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"冒泡排序","loc":{"start":{"line":14,"column":1},"end":{"line":14,"column":5}},"range":[265,269],"raw":"|冒泡排"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":6}},"range":[264,270],"raw":"\n|冒泡排序"},{"type":"TableCell","children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":14,"column":6},"end":{"line":14,"column":10}},"range":[270,274],"raw":"|交换排"}],"loc":{"start":{"line":14,"column":6},"end":{"line":14,"column":11}},"range":[270,275],"raw":"|交换排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":14,"column":12},"end":{"line":14,"column":22}},"range":[276,286],"raw":" $O(n^{2})"}],"loc":{"start":{"line":14,"column":11},"end":{"line":14,"column":24}},"range":[275,288],"raw":"| $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":14,"column":25},"end":{"line":14,"column":31}},"range":[289,295],"raw":" $O(1)"}],"loc":{"start":{"line":14,"column":24},"end":{"line":14,"column":33}},"range":[288,297],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":14,"column":33},"end":{"line":14,"column":35}},"range":[297,299],"raw":"|稳"}],"loc":{"start":{"line":14,"column":33},"end":{"line":14,"column":36}},"range":[297,300],"raw":"|稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":14,"column":36},"end":{"line":14,"column":38}},"range":[300,302],"raw":"|支"}],"loc":{"start":{"line":14,"column":36},"end":{"line":14,"column":39}},"range":[300,303],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":14,"column":39},"end":{"line":14,"column":41}},"range":[303,305],"raw":"|支"}],"loc":{"start":{"line":14,"column":39},"end":{"line":14,"column":42}},"range":[303,306],"raw":"|支持"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":42}},"range":[264,306],"raw":"\n|冒泡排序|交换排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"快速排序","loc":{"start":{"line":15,"column":1},"end":{"line":15,"column":5}},"range":[308,312],"raw":"|快速排"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":6}},"range":[307,313],"raw":"\n|快速排序"},{"type":"TableCell","children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":15,"column":6},"end":{"line":15,"column":10}},"range":[313,317],"raw":"|交换排"}],"loc":{"start":{"line":15,"column":6},"end":{"line":15,"column":11}},"range":[313,318],"raw":"|交换排序"},{"type":"TableCell","children":[{"type":"Str","value":"最好、平均： ","loc":{"start":{"line":15,"column":11},"end":{"line":15,"column":18}},"range":[318,325],"raw":"|最好、平均："},{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":15,"column":18},"end":{"line":15,"column":34}},"range":[325,341],"raw":" $O(nlog_{2}(n))"},{"type":"Str","value":" ，最坏： ","loc":{"start":{"line":15,"column":34},"end":{"line":15,"column":40}},"range":[341,347],"raw":"$ ，最坏："},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":15,"column":40},"end":{"line":15,"column":50}},"range":[347,357],"raw":" $O(n^{2})"}],"loc":{"start":{"line":15,"column":11},"end":{"line":15,"column":52}},"range":[318,359],"raw":"|最好、平均： $O(nlog_{2}(n))$ ，最坏： $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"Str","value":"最好、平均： ","loc":{"start":{"line":15,"column":52},"end":{"line":15,"column":59}},"range":[359,366],"raw":"|最好、平均："},{"type":"InlineMath","value":"O(log_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(log_{2}(n))"}]},"loc":{"start":{"line":15,"column":59},"end":{"line":15,"column":74}},"range":[366,381],"raw":" $O(log_{2}(n))"},{"type":"Str","value":" ，最坏： ","loc":{"start":{"line":15,"column":74},"end":{"line":15,"column":80}},"range":[381,387],"raw":"$ ，最坏："},{"type":"InlineMath","value":"O(n)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n)"}]},"loc":{"start":{"line":15,"column":80},"end":{"line":15,"column":86}},"range":[387,393],"raw":" $O(n)"}],"loc":{"start":{"line":15,"column":52},"end":{"line":15,"column":88}},"range":[359,395],"raw":"|最好、平均： $O(log_{2}(n))$ ，最坏： $O(n)$ "},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":15,"column":88},"end":{"line":15,"column":91}},"range":[395,398],"raw":"|不稳"}],"loc":{"start":{"line":15,"column":88},"end":{"line":15,"column":92}},"range":[395,399],"raw":"|不稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":15,"column":92},"end":{"line":15,"column":94}},"range":[399,401],"raw":"|支"}],"loc":{"start":{"line":15,"column":92},"end":{"line":15,"column":95}},"range":[399,402],"raw":"|支持"},{"type":"TableCell","children":[],"loc":{"start":{"line":15,"column":95},"end":{"line":15,"column":96}},"range":[402,403],"raw":"|"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":96}},"range":[307,403],"raw":"\n|快速排序|交换排序|最好、平均： $O(nlog_{2}(n))$ ，最坏： $O(n^{2})$ |最好、平均： $O(log_{2}(n))$ ，最坏： $O(n)$ |不稳定|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"简单选择排序","loc":{"start":{"line":16,"column":1},"end":{"line":16,"column":7}},"range":[405,411],"raw":"|简单选择排"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":8}},"range":[404,412],"raw":"\n|简单选择排序"},{"type":"TableCell","children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":16,"column":8},"end":{"line":16,"column":12}},"range":[412,416],"raw":"|选择排"}],"loc":{"start":{"line":16,"column":8},"end":{"line":16,"column":13}},"range":[412,417],"raw":"|选择排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":16,"column":14},"end":{"line":16,"column":24}},"range":[418,428],"raw":" $O(n^{2})"}],"loc":{"start":{"line":16,"column":13},"end":{"line":16,"column":26}},"range":[417,430],"raw":"| $O(n^{2})$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":16,"column":27},"end":{"line":16,"column":33}},"range":[431,437],"raw":" $O(1)"}],"loc":{"start":{"line":16,"column":26},"end":{"line":16,"column":35}},"range":[430,439],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":16,"column":35},"end":{"line":16,"column":38}},"range":[439,442],"raw":"|不稳"}],"loc":{"start":{"line":16,"column":35},"end":{"line":16,"column":39}},"range":[439,443],"raw":"|不稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":16,"column":39},"end":{"line":16,"column":41}},"range":[443,445],"raw":"|支"}],"loc":{"start":{"line":16,"column":39},"end":{"line":16,"column":42}},"range":[443,446],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":16,"column":42},"end":{"line":16,"column":44}},"range":[446,448],"raw":"|支"}],"loc":{"start":{"line":16,"column":42},"end":{"line":16,"column":45}},"range":[446,449],"raw":"|支持"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":45}},"range":[404,449],"raw":"\n|简单选择排序|选择排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"堆排序","loc":{"start":{"line":17,"column":1},"end":{"line":17,"column":4}},"range":[451,454],"raw":"|堆排"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":5}},"range":[450,455],"raw":"\n|堆排序"},{"type":"TableCell","children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":17,"column":5},"end":{"line":17,"column":9}},"range":[455,459],"raw":"|选择排"}],"loc":{"start":{"line":17,"column":5},"end":{"line":17,"column":10}},"range":[455,460],"raw":"|选择排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":17,"column":11},"end":{"line":17,"column":27}},"range":[461,477],"raw":" $O(nlog_{2}(n))"}],"loc":{"start":{"line":17,"column":10},"end":{"line":17,"column":29}},"range":[460,479],"raw":"| $O(nlog_{2}(n))$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":17,"column":30},"end":{"line":17,"column":36}},"range":[480,486],"raw":" $O(1)"}],"loc":{"start":{"line":17,"column":29},"end":{"line":17,"column":38}},"range":[479,488],"raw":"| $O(1)$ "},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":17,"column":38},"end":{"line":17,"column":41}},"range":[488,491],"raw":"|不稳"}],"loc":{"start":{"line":17,"column":38},"end":{"line":17,"column":42}},"range":[488,492],"raw":"|不稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":17,"column":42},"end":{"line":17,"column":44}},"range":[492,494],"raw":"|支"}],"loc":{"start":{"line":17,"column":42},"end":{"line":17,"column":45}},"range":[492,495],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":17,"column":45},"end":{"line":17,"column":47}},"range":[495,497],"raw":"|支"}],"loc":{"start":{"line":17,"column":45},"end":{"line":17,"column":48}},"range":[495,498],"raw":"|支持"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":48}},"range":[450,498],"raw":"\n|堆排序|选择排序| $O(nlog_{2}(n))$ | $O(1)$ |不稳定|支持|支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":18,"column":1},"end":{"line":18,"column":5}},"range":[500,504],"raw":"|归并排"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":6}},"range":[499,505],"raw":"\n|归并排序"},{"type":"TableCell","children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":18,"column":6},"end":{"line":18,"column":10}},"range":[505,509],"raw":"|归并排"}],"loc":{"start":{"line":18,"column":6},"end":{"line":18,"column":11}},"range":[505,510],"raw":"|归并排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":18,"column":12},"end":{"line":18,"column":28}},"range":[511,527],"raw":" $O(nlog_{2}(n))"}],"loc":{"start":{"line":18,"column":11},"end":{"line":18,"column":30}},"range":[510,529],"raw":"| $O(nlog_{2}(n))$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(n)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n)"}]},"loc":{"start":{"line":18,"column":31},"end":{"line":18,"column":37}},"range":[530,536],"raw":" $O(n)"}],"loc":{"start":{"line":18,"column":30},"end":{"line":18,"column":39}},"range":[529,538],"raw":"| $O(n)$ "},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":18,"column":39},"end":{"line":18,"column":41}},"range":[538,540],"raw":"|稳"}],"loc":{"start":{"line":18,"column":39},"end":{"line":18,"column":42}},"range":[538,541],"raw":"|稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":18,"column":42},"end":{"line":18,"column":44}},"range":[541,543],"raw":"|支"}],"loc":{"start":{"line":18,"column":42},"end":{"line":18,"column":45}},"range":[541,544],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":18,"column":45},"end":{"line":18,"column":47}},"range":[544,546],"raw":"|支"}],"loc":{"start":{"line":18,"column":45},"end":{"line":18,"column":48}},"range":[544,547],"raw":"|支持"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":48}},"range":[499,547],"raw":"\n|归并排序|归并排序| $O(nlog_{2}(n))$ | $O(n)$ |稳定|支持|支持"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":19,"column":1},"end":{"line":19,"column":5}},"range":[549,553],"raw":"|基数排"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":6}},"range":[548,554],"raw":"\n|基数排序"},{"type":"TableCell","children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":19,"column":6},"end":{"line":19,"column":10}},"range":[554,558],"raw":"|基数排"}],"loc":{"start":{"line":19,"column":6},"end":{"line":19,"column":11}},"range":[554,559],"raw":"|基数排序"},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(d(n+r))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(d(n+r))"}]},"loc":{"start":{"line":19,"column":12},"end":{"line":19,"column":23}},"range":[560,571],"raw":" $O(d(n+r))"}],"loc":{"start":{"line":19,"column":11},"end":{"line":19,"column":25}},"range":[559,573],"raw":"| $O(d(n+r))$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"O(r)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(r)"}]},"loc":{"start":{"line":19,"column":26},"end":{"line":19,"column":32}},"range":[574,580],"raw":" $O(r)"}],"loc":{"start":{"line":19,"column":25},"end":{"line":19,"column":34}},"range":[573,582],"raw":"| $O(r)$ "},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":19,"column":34},"end":{"line":19,"column":36}},"range":[582,584],"raw":"|稳"}],"loc":{"start":{"line":19,"column":34},"end":{"line":19,"column":37}},"range":[582,585],"raw":"|稳定"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":19,"column":37},"end":{"line":19,"column":39}},"range":[585,587],"raw":"|支"}],"loc":{"start":{"line":19,"column":37},"end":{"line":19,"column":40}},"range":[585,588],"raw":"|支持"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":19,"column":40},"end":{"line":19,"column":42}},"range":[588,590],"raw":"|支"}],"loc":{"start":{"line":19,"column":40},"end":{"line":19,"column":43}},"range":[588,591],"raw":"|支持"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":43}},"range":[548,591],"raw":"\n|基数排序|基数排序| $O(d(n+r))$ | $O(r)$ |稳定|支持|支持"}],"loc":{"start":{"line":9,"column":0},"end":{"line":19,"column":43}},"range":[70,591],"raw":"\n|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构|\n|-|-|-|-|-|-|-|\n|直接插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持|\n|折半插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|不支持|\n|希尔排序|插入排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|不支持|\n|冒泡排序|交换排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持|\n|快速排序|交换排序|最好、平均： $O(nlog_{2}(n))$ ，最坏： $O(n^{2})$ |最好、平均： $O(log_{2}(n))$ ，最坏： $O(n)$ |不稳定|支持||\n|简单选择排序|选择排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|支持|\n|堆排序|选择排序| $O(nlog_{2}(n))$ | $O(1)$ |不稳定|支持|支持|\n|归并排序|归并排序| $O(nlog_{2}(n))$ | $O(n)$ |稳定|支持|支持|\n|基数排序|基数排序| $O(d(n+r))$ | $O(r)$ |稳定|支持|支持"},{"type":"HorizontalRule","loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":5}},"range":[593,598],"raw":"\n****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"基本概念","loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":7}},"range":[603,607],"raw":" 基本概"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":7}},"range":[600,607],"raw":"\n## 基本概"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的定义","loc":{"start":{"line":25,"column":4},"end":{"line":25,"column":9}},"range":[613,618],"raw":" 排序的定"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":9}},"range":[609,618],"raw":"\n### 排序的定"},{"type":"Paragraph","children":[{"type":"Str","value":"重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。","loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":38}},"range":[620,658],"raw":"\n重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":38}},"range":[620,658],"raw":"\n重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的时间复杂度和空间复杂度","loc":{"start":{"line":29,"column":4},"end":{"line":29,"column":18}},"range":[664,678],"raw":" 排序的时间复杂度和空间复杂"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":18}},"range":[660,678],"raw":"\n### 排序的时间复杂度和空间复杂"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的稳定性","loc":{"start":{"line":31,"column":4},"end":{"line":31,"column":10}},"range":[684,690],"raw":" 排序的稳定"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":10}},"range":[680,690],"raw":"\n### 排序的稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"如果表中有两个元素 ","loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":10}},"range":[692,702],"raw":"\n如果表中有两个元素"},{"type":"InlineMath","value":"R_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{i}"}]},"loc":{"start":{"line":33,"column":10},"end":{"line":33,"column":17}},"range":[702,709],"raw":" $R_{i}"},{"type":"Str","value":" 和 ","loc":{"start":{"line":33,"column":17},"end":{"line":33,"column":20}},"range":[709,712],"raw":"$ 和"},{"type":"InlineMath","value":"R_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{j}"}]},"loc":{"start":{"line":33,"column":20},"end":{"line":33,"column":27}},"range":[712,719],"raw":" $R_{j}"},{"type":"Str","value":" ，其对应的关键字 ","loc":{"start":{"line":33,"column":27},"end":{"line":33,"column":37}},"range":[719,729],"raw":"$ ，其对应的关键字"},{"type":"InlineMath","value":"key_{i}=key_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"key_{i}=key_{j}"}]},"loc":{"start":{"line":33,"column":37},"end":{"line":33,"column":54}},"range":[729,746],"raw":" $key_{i}=key_{j}"},{"type":"Str","value":" ，且 ","loc":{"start":{"line":33,"column":54},"end":{"line":33,"column":58}},"range":[746,750],"raw":"$ ，且"},{"type":"InlineMath","value":"R_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{i}"}]},"loc":{"start":{"line":33,"column":58},"end":{"line":33,"column":65}},"range":[750,757],"raw":" $R_{i}"},{"type":"Str","value":" 排在 ","loc":{"start":{"line":33,"column":65},"end":{"line":33,"column":69}},"range":[757,761],"raw":"$ 排在"},{"type":"InlineMath","value":"R_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{j}"}]},"loc":{"start":{"line":33,"column":69},"end":{"line":33,"column":76}},"range":[761,768],"raw":" $R_{j}"},{"type":"Str","value":" 前面，使用某一排序算法后， ","loc":{"start":{"line":33,"column":76},"end":{"line":33,"column":91}},"range":[768,783],"raw":"$ 前面，使用某一排序算法后，"},{"type":"InlineMath","value":"R_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{i}"}]},"loc":{"start":{"line":33,"column":91},"end":{"line":33,"column":98}},"range":[783,790],"raw":" $R_{i}"},{"type":"Str","value":" 仍排在 ","loc":{"start":{"line":33,"column":98},"end":{"line":33,"column":103}},"range":[790,795],"raw":"$ 仍排在"},{"type":"InlineMath","value":"R_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"R_{j}"}]},"loc":{"start":{"line":33,"column":103},"end":{"line":33,"column":110}},"range":[795,802],"raw":" $R_{j}"},{"type":"Str","value":" 前面，就称这个算法是稳定的。","loc":{"start":{"line":33,"column":110},"end":{"line":33,"column":125}},"range":[802,817],"raw":"$ 前面，就称这个算法是稳定的"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":125}},"range":[692,817],"raw":"\n如果表中有两个元素 $R_{i}$ 和 $R_{j}$ ，其对应的关键字 $key_{i}=key_{j}$ ，且 $R_{i}$ 排在 $R_{j}$ 前面，使用某一排序算法后， $R_{i}$ 仍排在 $R_{j}$ 前面，就称这个算法是稳定的"},{"type":"HorizontalRule","loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":5}},"range":[819,824],"raw":"\n****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"内部排序","loc":{"start":{"line":37,"column":3},"end":{"line":37,"column":7}},"range":[829,833],"raw":" 内部排"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":7}},"range":[826,833],"raw":"\n## 内部排"},{"type":"Paragraph","children":[{"type":"Str","value":"排序过程中，所有的元素都存放在内存中的排序。","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":22}},"range":[835,857],"raw":"\n排序过程中，所有的元素都存放在内存中的排序"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":22}},"range":[835,857],"raw":"\n排序过程中，所有的元素都存放在内存中的排序"},{"type":"Paragraph","children":[{"type":"Str","value":"公式：对任意n个元素的列表进行排序的比较次数至少为  ","loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":27}},"range":[859,886],"raw":"\n公式：对任意n个元素的列表进行排序的比较次数至少为 "},{"type":"InlineMath","value":"\\lceil log_{2}{(n!)} \\rceil","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"\\lceil log_{2}{(n!)} \\rceil"}]},"loc":{"start":{"line":41,"column":27},"end":{"line":41,"column":56}},"range":[886,915],"raw":" $\\lceil log_{2}{(n!)} \\rceil"},{"type":"Str","value":"  。","loc":{"start":{"line":41,"column":56},"end":{"line":41,"column":59}},"range":[915,918],"raw":"$  "}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":59}},"range":[859,918],"raw":"\n公式：对任意n个元素的列表进行排序的比较次数至少为  $\\lceil log_{2}{(n!)} \\rceil$  "},{"type":"Header","depth":3,"children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":43,"column":4},"end":{"line":43,"column":8}},"range":[924,928],"raw":" 插入排"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":8}},"range":[920,928],"raw":"\n### 插入排"},{"type":"Paragraph","children":[{"type":"Str","value":"每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。","loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":49}},"range":[930,979],"raw":"\n每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":49}},"range":[930,979],"raw":"\n每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成"},{"type":"HorizontalRule","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":5}},"range":[981,986],"raw":"\n****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"直接插入排序","loc":{"start":{"line":49,"column":5},"end":{"line":49,"column":11}},"range":[993,999],"raw":" 直接插入排"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":11}},"range":[988,999],"raw":"\n#### 直接插入排"},{"type":"Table","align":[null,null,null],"children":[{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"有序序列","loc":{"start":{"line":51,"column":1},"end":{"line":51,"column":5}},"range":[1002,1006],"raw":"|有序序"}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":6}},"range":[1001,1007],"raw":"\n|有序序列"},{"type":"TableCell","children":[{"type":"Str","value":"要插入的","loc":{"start":{"line":51,"column":6},"end":{"line":51,"column":10}},"range":[1007,1011],"raw":"|要插入"}],"loc":{"start":{"line":51,"column":6},"end":{"line":51,"column":11}},"range":[1007,1012],"raw":"|要插入的"},{"type":"TableCell","children":[{"type":"Str","value":"无序序列","loc":{"start":{"line":51,"column":11},"end":{"line":51,"column":15}},"range":[1012,1016],"raw":"|无序序"}],"loc":{"start":{"line":51,"column":11},"end":{"line":51,"column":16}},"range":[1012,1017],"raw":"|无序序列"}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":16}},"range":[1001,1017],"raw":"\n|有序序列|要插入的|无序序列"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"InlineMath","value":"L[1...i-1]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[1...i-1]"}]},"loc":{"start":{"line":53,"column":2},"end":{"line":53,"column":14}},"range":[1028,1040],"raw":" $L[1...i-1]"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":16}},"range":[1026,1042],"raw":"\n| $L[1...i-1]$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"L(i)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i)"}]},"loc":{"start":{"line":53,"column":17},"end":{"line":53,"column":23}},"range":[1043,1049],"raw":" $L(i)"}],"loc":{"start":{"line":53,"column":16},"end":{"line":53,"column":25}},"range":[1042,1051],"raw":"| $L(i)$ "},{"type":"TableCell","children":[{"type":"InlineMath","value":"L[i+1...n]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[i+1...n]"}]},"loc":{"start":{"line":53,"column":26},"end":{"line":53,"column":38}},"range":[1052,1064],"raw":" $L[i+1...n]"}],"loc":{"start":{"line":53,"column":25},"end":{"line":53,"column":40}},"range":[1051,1066],"raw":"| $L[i+1...n]$ "}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":40}},"range":[1026,1066],"raw":"\n| $L[1...i-1]$ | $L(i)$ | $L[i+1...n]$ "}],"loc":{"start":{"line":51,"column":0},"end":{"line":53,"column":40}},"range":[1001,1066],"raw":"\n|有序序列|要插入的|无序序列|\n|-|-|-|\n| $L[1...i-1]$ | $L(i)$ | $L[i+1...n]$ "},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"查找 ","loc":{"start":{"line":55,"column":3},"end":{"line":55,"column":6}},"range":[1071,1074],"raw":" 查找"},{"type":"InlineMath","value":"L(i)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i)"}]},"loc":{"start":{"line":55,"column":6},"end":{"line":55,"column":12}},"range":[1074,1080],"raw":" $L(i)"},{"type":"Str","value":" 的插入位置k；","loc":{"start":{"line":55,"column":12},"end":{"line":55,"column":20}},"range":[1080,1088],"raw":"$ 的插入位置k"}],"loc":{"start":{"line":55,"column":3},"end":{"line":55,"column":20}},"range":[1071,1088],"raw":" 查找 $L(i)$ 的插入位置k"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":20}},"range":[1068,1088],"raw":"\n1. 查找 $L(i)$ 的插入位置k"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"将 ","loc":{"start":{"line":56,"column":3},"end":{"line":56,"column":5}},"range":[1092,1094],"raw":" 将"},{"type":"InlineMath","value":"L[k...i-1]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[k...i-1]"}]},"loc":{"start":{"line":56,"column":5},"end":{"line":56,"column":17}},"range":[1094,1106],"raw":" $L[k...i-1]"},{"type":"Str","value":" 所有的元素都向后移动一个位置；","loc":{"start":{"line":56,"column":17},"end":{"line":56,"column":33}},"range":[1106,1122],"raw":"$ 所有的元素都向后移动一个位置"}],"loc":{"start":{"line":56,"column":3},"end":{"line":56,"column":33}},"range":[1092,1122],"raw":" 将 $L[k...i-1]$ 所有的元素都向后移动一个位置"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":33}},"range":[1089,1122],"raw":"\n2. 将 $L[k...i-1]$ 所有的元素都向后移动一个位置"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"将 ","loc":{"start":{"line":57,"column":3},"end":{"line":57,"column":5}},"range":[1126,1128],"raw":" 将"},{"type":"InlineMath","value":"L(i)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i)"}]},"loc":{"start":{"line":57,"column":5},"end":{"line":57,"column":11}},"range":[1128,1134],"raw":" $L(i)"},{"type":"Str","value":" 复制到k的位置。","loc":{"start":{"line":57,"column":11},"end":{"line":57,"column":20}},"range":[1134,1143],"raw":"$ 复制到k的位置"}],"loc":{"start":{"line":57,"column":3},"end":{"line":57,"column":20}},"range":[1126,1143],"raw":" 将 $L(i)$ 复制到k的位置"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":20}},"range":[1123,1143],"raw":"\n3. 将 $L(i)$ 复制到k的位置"}],"loc":{"start":{"line":55,"column":0},"end":{"line":57,"column":20}},"range":[1068,1143],"raw":"\n1. 查找 $L(i)$ 的插入位置k；\n2. 将 $L[k...i-1]$ 所有的元素都向后移动一个位置；\n3. 将 $L(i)$ 复制到k的位置"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":59,"column":6},"end":{"line":59,"column":10}},"range":[1151,1155],"raw":" 代码实"}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":10}},"range":[1145,1155],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}","loc":{"start":{"line":61,"column":0},"end":{"line":70,"column":3}},"range":[1157,1373],"raw":"\n```c\nvoid InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":72,"column":6},"end":{"line":72,"column":11}},"range":[1381,1386],"raw":" 时间复杂"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":11}},"range":[1375,1386],"raw":"\n##### 时间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为 ","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":31}},"range":[1388,1419],"raw":"\n当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为"},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":74,"column":31},"end":{"line":74,"column":41}},"range":[1419,1429],"raw":" $O(n^{2})"},{"type":"Str","value":" 。","loc":{"start":{"line":74,"column":41},"end":{"line":74,"column":43}},"range":[1429,1431],"raw":"$ "}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":43}},"range":[1388,1431],"raw":"\n当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为 $O(n^{2})$ "},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":76,"column":6},"end":{"line":76,"column":11}},"range":[1439,1444],"raw":" 空间复杂"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":11}},"range":[1433,1444],"raw":"\n##### 空间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"只用到一个用于赋值的临时变量，空间复杂度为O(1)。","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":26}},"range":[1446,1472],"raw":"\n只用到一个用于赋值的临时变量，空间复杂度为O(1)"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":26}},"range":[1446,1472],"raw":"\n只用到一个用于赋值的临时变量，空间复杂度为O(1)"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":80,"column":6},"end":{"line":80,"column":9}},"range":[1480,1483],"raw":" 稳定"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":9}},"range":[1474,1483],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":50}},"range":[1485,1535],"raw":"\n比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":50}},"range":[1485,1535],"raw":"\n比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":84,"column":6},"end":{"line":84,"column":10}},"range":[1543,1547],"raw":" 存储结"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":10}},"range":[1537,1547],"raw":"\n##### 存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储","loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":36}},"range":[1549,1585],"raw":"\n排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存"}],"loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":36}},"range":[1549,1585],"raw":"\n排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存"},{"type":"HorizontalRule","loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":5}},"range":[1587,1592],"raw":"\n****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"折半插入排序（二分插入排序）","loc":{"start":{"line":90,"column":5},"end":{"line":90,"column":19}},"range":[1599,1613],"raw":" 折半插入排序（二分插入排序"}],"loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":19}},"range":[1594,1613],"raw":"\n#### 折半插入排序（二分插入排序"},{"type":"Paragraph","children":[{"type":"Str","value":"使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。","loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":40}},"range":[1615,1655],"raw":"\n使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":40}},"range":[1615,1655],"raw":"\n使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":94,"column":6},"end":{"line":94,"column":10}},"range":[1663,1667],"raw":" 代码实"}],"loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":10}},"range":[1657,1667],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}","loc":{"start":{"line":96,"column":0},"end":{"line":119,"column":3}},"range":[1669,2202],"raw":"\n```c\nvoid BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":121,"column":6},"end":{"line":121,"column":11}},"range":[2210,2215],"raw":" 时间复杂"}],"loc":{"start":{"line":121,"column":0},"end":{"line":121,"column":11}},"range":[2204,2215],"raw":"\n##### 时间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"由于查找过程使用了二分查找，所以其时间复杂度是 ","loc":{"start":{"line":123,"column":0},"end":{"line":123,"column":24}},"range":[2217,2241],"raw":"\n由于查找过程使用了二分查找，所以其时间复杂度是"},{"type":"InlineMath","value":"O(n*n*log_{2}(n))=O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n*n*log_{2}(n))=O(n^{2})"}]},"loc":{"start":{"line":123,"column":24},"end":{"line":123,"column":52}},"range":[2241,2269],"raw":" $O(n*n*log_{2}(n))=O(n^{2})"},{"type":"Str","value":" 。","loc":{"start":{"line":123,"column":52},"end":{"line":123,"column":54}},"range":[2269,2271],"raw":"$ "}],"loc":{"start":{"line":123,"column":0},"end":{"line":123,"column":54}},"range":[2217,2271],"raw":"\n由于查找过程使用了二分查找，所以其时间复杂度是 $O(n*n*log_{2}(n))=O(n^{2})$ "},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":125,"column":6},"end":{"line":125,"column":11}},"range":[2279,2284],"raw":" 空间复杂"}],"loc":{"start":{"line":125,"column":0},"end":{"line":125,"column":11}},"range":[2273,2284],"raw":"\n##### 空间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"只是用到了常数个额外的内存空间，所以其空间复杂度是 ","loc":{"start":{"line":127,"column":0},"end":{"line":127,"column":26}},"range":[2286,2312],"raw":"\n只是用到了常数个额外的内存空间，所以其空间复杂度是"},{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":127,"column":26},"end":{"line":127,"column":32}},"range":[2312,2318],"raw":" $O(1)"},{"type":"Str","value":" 。","loc":{"start":{"line":127,"column":32},"end":{"line":127,"column":34}},"range":[2318,2320],"raw":"$ "}],"loc":{"start":{"line":127,"column":0},"end":{"line":127,"column":34}},"range":[2286,2320],"raw":"\n只是用到了常数个额外的内存空间，所以其空间复杂度是 $O(1)$ "},{"type":"Header","depth":5,"children":[{"type":"Str","value":"排序稳定性","loc":{"start":{"line":129,"column":6},"end":{"line":129,"column":11}},"range":[2328,2333],"raw":" 排序稳定"}],"loc":{"start":{"line":129,"column":0},"end":{"line":129,"column":11}},"range":[2322,2333],"raw":"\n##### 排序稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"与直接插入排序相同","loc":{"start":{"line":131,"column":0},"end":{"line":131,"column":9}},"range":[2335,2344],"raw":"\n与直接插入排序相"}],"loc":{"start":{"line":131,"column":0},"end":{"line":131,"column":9}},"range":[2335,2344],"raw":"\n与直接插入排序相"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":133,"column":6},"end":{"line":133,"column":10}},"range":[2352,2356],"raw":" 存储结"}],"loc":{"start":{"line":133,"column":0},"end":{"line":133,"column":10}},"range":[2346,2356],"raw":"\n##### 存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"由于使用了二分查找，所以只能适用于顺序存储的线性表","loc":{"start":{"line":135,"column":0},"end":{"line":135,"column":25}},"range":[2358,2383],"raw":"\n由于使用了二分查找，所以只能适用于顺序存储的线性"}],"loc":{"start":{"line":135,"column":0},"end":{"line":135,"column":25}},"range":[2358,2383],"raw":"\n由于使用了二分查找，所以只能适用于顺序存储的线性"},{"type":"HorizontalRule","loc":{"start":{"line":137,"column":0},"end":{"line":137,"column":5}},"range":[2385,2390],"raw":"\n****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"希尔排序（缩小增量排序）","loc":{"start":{"line":139,"column":5},"end":{"line":139,"column":17}},"range":[2397,2409],"raw":" 希尔排序（缩小增量排序"}],"loc":{"start":{"line":139,"column":0},"end":{"line":139,"column":17}},"range":[2392,2409],"raw":"\n#### 希尔排序（缩小增量排序"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"先将要排序的序列分割成 ","loc":{"start":{"line":141,"column":2},"end":{"line":141,"column":14}},"range":[2413,2425],"raw":" 先将要排序的序列分割成"},{"type":"InlineMath","value":"d=d_{i}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d=d_{i}"}]},"loc":{"start":{"line":141,"column":14},"end":{"line":141,"column":23}},"range":[2425,2434],"raw":" $d=d_{i}"},{"type":"Str","value":" 个形如  ","loc":{"start":{"line":141,"column":23},"end":{"line":141,"column":29}},"range":[2434,2440],"raw":"$ 个形如 "},{"type":"InlineMath","value":"L[i,i+d,i+2d,...,i+kd]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[i,i+d,i+2d,...,i+kd]"}]},"loc":{"start":{"line":141,"column":29},"end":{"line":141,"column":53}},"range":[2440,2464],"raw":" $L[i,i+d,i+2d,...,i+kd]"},{"type":"Str","value":"  的子序列","loc":{"start":{"line":141,"column":53},"end":{"line":141,"column":59}},"range":[2464,2470],"raw":"$  的子序"}],"loc":{"start":{"line":141,"column":2},"end":{"line":141,"column":59}},"range":[2413,2470],"raw":" 先将要排序的序列分割成 $d=d_{i}$ 个形如  $L[i,i+d,i+2d,...,i+kd]$  的子序"}],"loc":{"start":{"line":141,"column":0},"end":{"line":141,"column":59}},"range":[2411,2470],"raw":"\n- 先将要排序的序列分割成 $d=d_{i}$ 个形如  $L[i,i+d,i+2d,...,i+kd]$  的子序"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"对各个子序列进行直接插入排序","loc":{"start":{"line":142,"column":2},"end":{"line":142,"column":16}},"range":[2473,2487],"raw":" 对各个子序列进行直接插入排"}],"loc":{"start":{"line":142,"column":2},"end":{"line":142,"column":16}},"range":[2473,2487],"raw":" 对各个子序列进行直接插入排"}],"loc":{"start":{"line":142,"column":0},"end":{"line":142,"column":16}},"range":[2471,2487],"raw":"\n- 对各个子序列进行直接插入排"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"令 ","loc":{"start":{"line":143,"column":2},"end":{"line":143,"column":4}},"range":[2490,2492],"raw":" 令"},{"type":"InlineMath","value":"d=d_{i+1}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d=d_{i+1}"}]},"loc":{"start":{"line":143,"column":4},"end":{"line":143,"column":15}},"range":[2492,2503],"raw":" $d=d_{i+1}"},{"type":"Str","value":" ，重复上面的两步，直到d=1时，排序完成","loc":{"start":{"line":143,"column":15},"end":{"line":143,"column":36}},"range":[2503,2524],"raw":"$ ，重复上面的两步，直到d=1时，排序完"}],"loc":{"start":{"line":143,"column":2},"end":{"line":143,"column":36}},"range":[2490,2524],"raw":" 令 $d=d_{i+1}$ ，重复上面的两步，直到d=1时，排序完"}],"loc":{"start":{"line":143,"column":0},"end":{"line":143,"column":36}},"range":[2488,2524],"raw":"\n- 令 $d=d_{i+1}$ ，重复上面的两步，直到d=1时，排序完"}],"loc":{"start":{"line":141,"column":0},"end":{"line":143,"column":36}},"range":[2411,2524],"raw":"\n- 先将要排序的序列分割成 $d=d_{i}$ 个形如  $L[i,i+d,i+2d,...,i+kd]$  的子序列\n- 对各个子序列进行直接插入排序\n- 令 $d=d_{i+1}$ ，重复上面的两步，直到d=1时，排序完"},{"type":"Paragraph","children":[{"type":"InlineMath","value":"d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1"}]},"loc":{"start":{"line":145,"column":1},"end":{"line":145,"column":93}},"range":[2527,2619],"raw":" $d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1"}],"loc":{"start":{"line":145,"column":1},"end":{"line":145,"column":94}},"range":[2527,2620],"raw":" $d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":147,"column":6},"end":{"line":147,"column":10}},"range":[2628,2632],"raw":" 代码实"}],"loc":{"start":{"line":147,"column":0},"end":{"line":147,"column":10}},"range":[2622,2632],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}","loc":{"start":{"line":149,"column":0},"end":{"line":164,"column":3}},"range":[2634,3032],"raw":"\n```c\nvoid ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":166,"column":6},"end":{"line":166,"column":11}},"range":[3040,3045],"raw":" 时间复杂"}],"loc":{"start":{"line":166,"column":0},"end":{"line":166,"column":11}},"range":[3034,3045],"raw":"\n##### 时间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"希尔排序的时间复杂度 ","loc":{"start":{"line":168,"column":0},"end":{"line":168,"column":11}},"range":[3047,3058],"raw":"\n希尔排序的时间复杂度"},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":168,"column":11},"end":{"line":168,"column":21}},"range":[3058,3068],"raw":" $O(n^{2})"},{"type":"Str","value":" ，n在某一个范围之内的时候，希尔排序的时间复杂度可以到 ","loc":{"start":{"line":168,"column":21},"end":{"line":168,"column":50}},"range":[3068,3097],"raw":"$ ，n在某一个范围之内的时候，希尔排序的时间复杂度可以到"},{"type":"InlineMath","value":"O(n^{1.3})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{1.3})"}]},"loc":{"start":{"line":168,"column":50},"end":{"line":168,"column":62}},"range":[3097,3109],"raw":" $O(n^{1.3})"}],"loc":{"start":{"line":168,"column":0},"end":{"line":168,"column":63}},"range":[3047,3110],"raw":"\n希尔排序的时间复杂度 $O(n^{2})$ ，n在某一个范围之内的时候，希尔排序的时间复杂度可以到 $O(n^{1.3})$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":170,"column":6},"end":{"line":170,"column":11}},"range":[3118,3123],"raw":" 空间复杂"}],"loc":{"start":{"line":170,"column":0},"end":{"line":170,"column":11}},"range":[3112,3123],"raw":"\n##### 空间复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"辅助空间是常数级的，空间复杂度是 ","loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":17}},"range":[3125,3142],"raw":"\n辅助空间是常数级的，空间复杂度是"},{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":172,"column":17},"end":{"line":172,"column":23}},"range":[3142,3148],"raw":" $O(1)"},{"type":"Str","value":" 。","loc":{"start":{"line":172,"column":23},"end":{"line":172,"column":25}},"range":[3148,3150],"raw":"$ "}],"loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":25}},"range":[3125,3150],"raw":"\n辅助空间是常数级的，空间复杂度是 $O(1)$ "},{"type":"Header","depth":5,"children":[{"type":"Str","value":"希尔排序的稳定性","loc":{"start":{"line":174,"column":6},"end":{"line":174,"column":14}},"range":[3158,3166],"raw":" 希尔排序的稳定"}],"loc":{"start":{"line":174,"column":0},"end":{"line":174,"column":14}},"range":[3152,3166],"raw":"\n##### 希尔排序的稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。","loc":{"start":{"line":176,"column":0},"end":{"line":176,"column":41}},"range":[3168,3209],"raw":"\n希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置"}],"loc":{"start":{"line":176,"column":0},"end":{"line":176,"column":41}},"range":[3168,3209],"raw":"\n希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"希尔排序的存储结构","loc":{"start":{"line":178,"column":6},"end":{"line":178,"column":15}},"range":[3217,3226],"raw":" 希尔排序的存储结"}],"loc":{"start":{"line":178,"column":0},"end":{"line":178,"column":15}},"range":[3211,3226],"raw":"\n##### 希尔排序的存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。","loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":31}},"range":[3228,3259],"raw":"\n用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表"}],"loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":31}},"range":[3228,3259],"raw":"\n用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表"},{"type":"HorizontalRule","loc":{"start":{"line":182,"column":0},"end":{"line":182,"column":5}},"range":[3261,3266],"raw":"\n****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":184,"column":4},"end":{"line":184,"column":8}},"range":[3272,3276],"raw":" 交换排"}],"loc":{"start":{"line":184,"column":0},"end":{"line":184,"column":8}},"range":[3268,3276],"raw":"\n### 交换排"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"冒泡排序","loc":{"start":{"line":186,"column":5},"end":{"line":186,"column":9}},"range":[3283,3287],"raw":" 冒泡排"}],"loc":{"start":{"line":186,"column":0},"end":{"line":186,"column":9}},"range":[3278,3287],"raw":"\n#### 冒泡排"},{"type":"Paragraph","children":[{"type":"Str","value":"一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。","loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":88}},"range":[3289,3377],"raw":"\n一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后"}],"loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":88}},"range":[3289,3377],"raw":"\n一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后"},{"type":"Paragraph","children":[{"type":"Str","value":"然后再对前面的n-1个元素进行一轮冒泡，依次类推。","loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":25}},"range":[3379,3404],"raw":"\n然后再对前面的n-1个元素进行一轮冒泡，依次类推"}],"loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":25}},"range":[3379,3404],"raw":"\n然后再对前面的n-1个元素进行一轮冒泡，依次类推"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":192,"column":6},"end":{"line":192,"column":10}},"range":[3412,3416],"raw":" 代码实"}],"loc":{"start":{"line":192,"column":0},"end":{"line":192,"column":10}},"range":[3406,3416],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}","loc":{"start":{"line":194,"column":0},"end":{"line":215,"column":3}},"range":[3418,3928],"raw":"\n```c\n#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":217,"column":6},"end":{"line":217,"column":11}},"range":[3936,3941],"raw":" 时空复杂"}],"loc":{"start":{"line":217,"column":0},"end":{"line":217,"column":11}},"range":[3930,3941],"raw":"\n##### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：O(n^{2})","loc":{"start":{"line":219,"column":0},"end":{"line":219,"column":14}},"range":[3943,3957],"raw":"\n时间复杂度：O(n^{2}"}],"loc":{"start":{"line":219,"column":0},"end":{"line":219,"column":14}},"range":[3943,3957],"raw":"\n时间复杂度：O(n^{2}"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：O(1)","loc":{"start":{"line":221,"column":0},"end":{"line":221,"column":10}},"range":[3959,3969],"raw":"\n空间复杂度：O(1"}],"loc":{"start":{"line":221,"column":0},"end":{"line":221,"column":10}},"range":[3959,3969],"raw":"\n空间复杂度：O(1"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":223,"column":6},"end":{"line":223,"column":9}},"range":[3977,3980],"raw":" 稳定"}],"loc":{"start":{"line":223,"column":0},"end":{"line":223,"column":9}},"range":[3971,3980],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"冒泡排序是稳定的","loc":{"start":{"line":225,"column":0},"end":{"line":225,"column":8}},"range":[3982,3990],"raw":"\n冒泡排序是稳定"}],"loc":{"start":{"line":225,"column":0},"end":{"line":225,"column":8}},"range":[3982,3990],"raw":"\n冒泡排序是稳定"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"快排排序","loc":{"start":{"line":227,"column":5},"end":{"line":227,"column":9}},"range":[3997,4001],"raw":" 快排排"}],"loc":{"start":{"line":227,"column":0},"end":{"line":227,"column":9}},"range":[3992,4001],"raw":"\n#### 快排排"},{"type":"Paragraph","children":[{"type":"Str","value":"在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。","loc":{"start":{"line":229,"column":0},"end":{"line":229,"column":97}},"range":[4003,4100],"raw":"\n在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置"}],"loc":{"start":{"line":229,"column":0},"end":{"line":229,"column":97}},"range":[4003,4100],"raw":"\n在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置"},{"type":"Paragraph","children":[{"type":"Str","value":"然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。","loc":{"start":{"line":231,"column":0},"end":{"line":231,"column":53}},"range":[4102,4155],"raw":"\n然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止"}],"loc":{"start":{"line":231,"column":0},"end":{"line":231,"column":53}},"range":[4102,4155],"raw":"\n然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止"},{"type":"Paragraph","children":[{"type":"Str","value":"基本思路：","loc":{"start":{"line":233,"column":0},"end":{"line":233,"column":5}},"range":[4157,4162],"raw":"\n基本思路"}],"loc":{"start":{"line":233,"column":0},"end":{"line":233,"column":5}},"range":[4157,4162],"raw":"\n基本思路"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始化low指向要划分的第一个元素，high指向要划分的最后一个元素","loc":{"start":{"line":235,"column":3},"end":{"line":235,"column":37}},"range":[4167,4201],"raw":" 初始化low指向要划分的第一个元素，high指向要划分的最后一个元"}],"loc":{"start":{"line":235,"column":3},"end":{"line":235,"column":37}},"range":[4167,4201],"raw":" 初始化low指向要划分的第一个元素，high指向要划分的最后一个元"}],"loc":{"start":{"line":235,"column":0},"end":{"line":235,"column":37}},"range":[4164,4201],"raw":"\n1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素","loc":{"start":{"line":236,"column":3},"end":{"line":236,"column":49}},"range":[4205,4251],"raw":" 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元"}],"loc":{"start":{"line":236,"column":3},"end":{"line":236,"column":49}},"range":[4205,4251],"raw":" 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元"}],"loc":{"start":{"line":236,"column":0},"end":{"line":236,"column":49}},"range":[4202,4251],"raw":"\n2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"交换low和high指向的元素","loc":{"start":{"line":237,"column":3},"end":{"line":237,"column":18}},"range":[4255,4270],"raw":" 交换low和high指向的元"}],"loc":{"start":{"line":237,"column":3},"end":{"line":237,"column":18}},"range":[4255,4270],"raw":" 交换low和high指向的元"}],"loc":{"start":{"line":237,"column":0},"end":{"line":237,"column":18}},"range":[4252,4270],"raw":"\n3. 交换low和high指向的元"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"继续移动low和high直到low>=high","loc":{"start":{"line":238,"column":3},"end":{"line":238,"column":26}},"range":[4274,4297],"raw":" 继续移动low和high直到low>=hig"}],"loc":{"start":{"line":238,"column":3},"end":{"line":238,"column":26}},"range":[4274,4297],"raw":" 继续移动low和high直到low>=hig"}],"loc":{"start":{"line":238,"column":0},"end":{"line":238,"column":26}},"range":[4271,4297],"raw":"\n4. 继续移动low和high直到low>=hig"}],"loc":{"start":{"line":235,"column":0},"end":{"line":238,"column":26}},"range":[4164,4297],"raw":"\n1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元素\n2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素\n3. 交换low和high指向的元素\n4. 继续移动low和high直到low>=hig"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":240,"column":6},"end":{"line":240,"column":10}},"range":[4305,4309],"raw":" 代码实"}],"loc":{"start":{"line":240,"column":0},"end":{"line":240,"column":10}},"range":[4299,4309],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}","loc":{"start":{"line":242,"column":0},"end":{"line":292,"column":3}},"range":[4311,5594],"raw":"\n```c\nint Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":294,"column":6},"end":{"line":294,"column":11}},"range":[5602,5607],"raw":" 时空复杂"}],"loc":{"start":{"line":294,"column":0},"end":{"line":294,"column":11}},"range":[5596,5607],"raw":"\n##### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"最好、平均时间复杂度： ","loc":{"start":{"line":296,"column":0},"end":{"line":296,"column":12}},"range":[5609,5621],"raw":"\n最好、平均时间复杂度："},{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":296,"column":12},"end":{"line":296,"column":28}},"range":[5621,5637],"raw":" $O(nlog_{2}(n))"}],"loc":{"start":{"line":296,"column":0},"end":{"line":296,"column":29}},"range":[5609,5638],"raw":"\n最好、平均时间复杂度： $O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"最好、平均空间复杂度： ","loc":{"start":{"line":298,"column":0},"end":{"line":298,"column":12}},"range":[5640,5652],"raw":"\n最好、平均空间复杂度："},{"type":"InlineMath","value":"O(log_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(log_{2}(n))"}]},"loc":{"start":{"line":298,"column":12},"end":{"line":298,"column":27}},"range":[5652,5667],"raw":" $O(log_{2}(n))"}],"loc":{"start":{"line":298,"column":0},"end":{"line":298,"column":28}},"range":[5640,5668],"raw":"\n最好、平均空间复杂度： $O(log_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"最坏空间复杂度： ","loc":{"start":{"line":300,"column":0},"end":{"line":300,"column":9}},"range":[5670,5679],"raw":"\n最坏空间复杂度："},{"type":"InlineMath","value":"O(n)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n)"}]},"loc":{"start":{"line":300,"column":9},"end":{"line":300,"column":15}},"range":[5679,5685],"raw":" $O(n)"}],"loc":{"start":{"line":300,"column":0},"end":{"line":300,"column":16}},"range":[5670,5686],"raw":"\n最坏空间复杂度： $O(n)$"},{"type":"Paragraph","children":[{"type":"Str","value":"最坏时间复杂度： ","loc":{"start":{"line":302,"column":0},"end":{"line":302,"column":9}},"range":[5688,5697],"raw":"\n最坏时间复杂度："},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":302,"column":9},"end":{"line":302,"column":19}},"range":[5697,5707],"raw":" $O(n^{2})"}],"loc":{"start":{"line":302,"column":0},"end":{"line":302,"column":20}},"range":[5688,5708],"raw":"\n最坏时间复杂度： $O(n^{2})$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":304,"column":6},"end":{"line":304,"column":9}},"range":[5716,5719],"raw":" 稳定"}],"loc":{"start":{"line":304,"column":0},"end":{"line":304,"column":9}},"range":[5710,5719],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"快速排序是不稳定的","loc":{"start":{"line":306,"column":0},"end":{"line":306,"column":9}},"range":[5721,5730],"raw":"\n快速排序是不稳定"}],"loc":{"start":{"line":306,"column":0},"end":{"line":306,"column":9}},"range":[5721,5730],"raw":"\n快速排序是不稳定"},{"type":"HorizontalRule","loc":{"start":{"line":308,"column":0},"end":{"line":308,"column":6}},"range":[5732,5738],"raw":"\n*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":310,"column":4},"end":{"line":310,"column":8}},"range":[5744,5748],"raw":" 选择排"}],"loc":{"start":{"line":310,"column":0},"end":{"line":310,"column":8}},"range":[5740,5748],"raw":"\n### 选择排"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"简单选择排序","loc":{"start":{"line":312,"column":5},"end":{"line":312,"column":11}},"range":[5755,5761],"raw":" 简单选择排"}],"loc":{"start":{"line":312,"column":0},"end":{"line":312,"column":11}},"range":[5750,5761],"raw":"\n#### 简单选择排"},{"type":"Paragraph","children":[{"type":"Str","value":"在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。","loc":{"start":{"line":314,"column":0},"end":{"line":314,"column":58}},"range":[5763,5821],"raw":"\n在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止"}],"loc":{"start":{"line":314,"column":0},"end":{"line":314,"column":58}},"range":[5763,5821],"raw":"\n在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":316,"column":6},"end":{"line":316,"column":10}},"range":[5829,5833],"raw":" 代码实"}],"loc":{"start":{"line":316,"column":0},"end":{"line":316,"column":10}},"range":[5823,5833],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}","loc":{"start":{"line":318,"column":0},"end":{"line":332,"column":3}},"range":[5835,6227],"raw":"\n```c\nvoid SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":334,"column":6},"end":{"line":334,"column":9}},"range":[6235,6238],"raw":" 稳定"}],"loc":{"start":{"line":334,"column":0},"end":{"line":334,"column":9}},"range":[6229,6238],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"选择排序是不稳定的","loc":{"start":{"line":336,"column":0},"end":{"line":336,"column":9}},"range":[6240,6249],"raw":"\n选择排序是不稳定"}],"loc":{"start":{"line":336,"column":0},"end":{"line":336,"column":9}},"range":[6240,6249],"raw":"\n选择排序是不稳定"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":338,"column":6},"end":{"line":338,"column":11}},"range":[6257,6262],"raw":" 时空复杂"}],"loc":{"start":{"line":338,"column":0},"end":{"line":338,"column":11}},"range":[6251,6262],"raw":"\n##### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度： ","loc":{"start":{"line":340,"column":0},"end":{"line":340,"column":7}},"range":[6264,6271],"raw":"\n时间复杂度："},{"type":"InlineMath","value":"O(n^{2})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n^{2})"}]},"loc":{"start":{"line":340,"column":7},"end":{"line":340,"column":17}},"range":[6271,6281],"raw":" $O(n^{2})"}],"loc":{"start":{"line":340,"column":0},"end":{"line":340,"column":18}},"range":[6264,6282],"raw":"\n时间复杂度： $O(n^{2})$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度： ","loc":{"start":{"line":342,"column":0},"end":{"line":342,"column":7}},"range":[6284,6291],"raw":"\n空间复杂度："},{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":342,"column":7},"end":{"line":342,"column":13}},"range":[6291,6297],"raw":" $O(1)"}],"loc":{"start":{"line":342,"column":0},"end":{"line":342,"column":14}},"range":[6284,6298],"raw":"\n空间复杂度： $O(1)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":344,"column":6},"end":{"line":344,"column":10}},"range":[6306,6310],"raw":" 存储结"}],"loc":{"start":{"line":344,"column":0},"end":{"line":344,"column":10}},"range":[6300,6310],"raw":"\n##### 存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":346,"column":0},"end":{"line":346,"column":12}},"range":[6312,6324],"raw":"\n适用于顺序存储和链式存"}],"loc":{"start":{"line":346,"column":0},"end":{"line":346,"column":12}},"range":[6312,6324],"raw":"\n适用于顺序存储和链式存"},{"type":"HorizontalRule","loc":{"start":{"line":348,"column":0},"end":{"line":348,"column":5}},"range":[6326,6331],"raw":"\n****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"堆排序","loc":{"start":{"line":350,"column":5},"end":{"line":350,"column":8}},"range":[6338,6341],"raw":" 堆排"}],"loc":{"start":{"line":350,"column":0},"end":{"line":350,"column":8}},"range":[6333,6341],"raw":"\n#### 堆排"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"堆：n个关键字序列 ","loc":{"start":{"line":352,"column":2},"end":{"line":352,"column":12}},"range":[6345,6355],"raw":" 堆：n个关键字序列"},{"type":"InlineMath","value":"L[1...n]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[1...n]"}]},"loc":{"start":{"line":352,"column":12},"end":{"line":352,"column":22}},"range":[6355,6365],"raw":" $L[1...n]"},{"type":"Str","value":" 称为堆，当且仅当该序列满足：","loc":{"start":{"line":352,"column":22},"end":{"line":352,"column":37}},"range":[6365,6380],"raw":"$ 称为堆，当且仅当该序列满足"}],"loc":{"start":{"line":352,"column":2},"end":{"line":352,"column":37}},"range":[6345,6380],"raw":" 堆：n个关键字序列 $L[1...n]$ 称为堆，当且仅当该序列满足"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若 ","loc":{"start":{"line":353,"column":5},"end":{"line":353,"column":7}},"range":[6386,6388],"raw":" 若"},{"type":"InlineMath","value":"L(i) \\leq L(2i)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i) \\leq L(2i)"}]},"loc":{"start":{"line":353,"column":7},"end":{"line":353,"column":24}},"range":[6388,6405],"raw":" $L(i) \\leq L(2i)"},{"type":"Str","value":" 且 ","loc":{"start":{"line":353,"column":24},"end":{"line":353,"column":27}},"range":[6405,6408],"raw":"$ 且"},{"type":"InlineMath","value":"L(i) \\leq L(2i+1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i) \\leq L(2i+1)"}]},"loc":{"start":{"line":353,"column":27},"end":{"line":353,"column":46}},"range":[6408,6427],"raw":" $L(i) \\leq L(2i+1)"},{"type":"Str","value":" ，称该堆为小根堆","loc":{"start":{"line":353,"column":46},"end":{"line":353,"column":55}},"range":[6427,6436],"raw":"$ ，称该堆为小根"}],"loc":{"start":{"line":353,"column":5},"end":{"line":353,"column":55}},"range":[6386,6436],"raw":" 若 $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ ，称该堆为小根"}],"loc":{"start":{"line":353,"column":2},"end":{"line":353,"column":55}},"range":[6383,6436],"raw":" 1. 若 $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ ，称该堆为小根"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若 ","loc":{"start":{"line":354,"column":5},"end":{"line":354,"column":7}},"range":[6442,6444],"raw":" 若"},{"type":"InlineMath","value":"L(i) \\geq L(2i)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i) \\geq L(2i)"}]},"loc":{"start":{"line":354,"column":7},"end":{"line":354,"column":24}},"range":[6444,6461],"raw":" $L(i) \\geq L(2i)"},{"type":"Str","value":" 且 ","loc":{"start":{"line":354,"column":24},"end":{"line":354,"column":27}},"range":[6461,6464],"raw":"$ 且"},{"type":"InlineMath","value":"L(i) \\geq L(2i+1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L(i) \\geq L(2i+1)"}]},"loc":{"start":{"line":354,"column":27},"end":{"line":354,"column":46}},"range":[6464,6483],"raw":" $L(i) \\geq L(2i+1)"},{"type":"Str","value":" ，称该堆为大根堆","loc":{"start":{"line":354,"column":46},"end":{"line":354,"column":55}},"range":[6483,6492],"raw":"$ ，称该堆为大根"}],"loc":{"start":{"line":354,"column":5},"end":{"line":354,"column":55}},"range":[6442,6492],"raw":" 若 $L(i) \\geq L(2i)$ 且 $L(i) \\geq L(2i+1)$ ，称该堆为大根"}],"loc":{"start":{"line":354,"column":2},"end":{"line":354,"column":55}},"range":[6439,6492],"raw":" 2. 若 $L(i) \\geq L(2i)$ 且 $L(i) \\geq L(2i+1)$ ，称该堆为大根"}],"loc":{"start":{"line":353,"column":2},"end":{"line":355,"column":1}},"range":[6383,6494],"raw":" 1. 若 $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ ，称该堆为小根堆\n> 2. 若 $L(i) \\geq L(2i)$ 且 $L(i) \\geq L(2i+1)$ ，称该堆为大根堆\n"},{"type":"Paragraph","children":[{"type":"Str","value":"在排序得过程中，将序列 ","loc":{"start":{"line":356,"column":2},"end":{"line":356,"column":14}},"range":[6497,6509],"raw":" 在排序得过程中，将序列"},{"type":"InlineMath","value":"L[1...n]","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"L[1...n]"}]},"loc":{"start":{"line":356,"column":14},"end":{"line":356,"column":24}},"range":[6509,6519],"raw":" $L[1...n]"},{"type":"Str","value":" 视为一棵完全二叉树","loc":{"start":{"line":356,"column":24},"end":{"line":356,"column":34}},"range":[6519,6529],"raw":"$ 视为一棵完全二叉"}],"loc":{"start":{"line":356,"column":2},"end":{"line":356,"column":34}},"range":[6497,6529],"raw":" 在排序得过程中，将序列 $L[1...n]$ 视为一棵完全二叉"}],"loc":{"start":{"line":352,"column":0},"end":{"line":356,"column":34}},"range":[6343,6529],"raw":"\n> 堆：n个关键字序列 $L[1...n]$ 称为堆，当且仅当该序列满足：\n> 1. 若 $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ ，称该堆为小根堆\n> 2. 若 $L(i) \\geq L(2i)$ 且 $L(i) \\geq L(2i+1)$ ，称该堆为大根堆\n>\n> 在排序得过程中，将序列 $L[1...n]$ 视为一棵完全二叉"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的","loc":{"start":{"line":358,"column":2},"end":{"line":358,"column":32}},"range":[6533,6563],"raw":" 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小"}],"loc":{"start":{"line":358,"column":2},"end":{"line":358,"column":32}},"range":[6533,6563],"raw":" 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小"}],"loc":{"start":{"line":358,"column":0},"end":{"line":358,"column":32}},"range":[6531,6563],"raw":"\n- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的","loc":{"start":{"line":359,"column":2},"end":{"line":359,"column":32}},"range":[6566,6596],"raw":" 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大"}],"loc":{"start":{"line":359,"column":2},"end":{"line":359,"column":32}},"range":[6566,6596],"raw":" 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大"}],"loc":{"start":{"line":359,"column":0},"end":{"line":359,"column":32}},"range":[6564,6596],"raw":"\n- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大"}],"loc":{"start":{"line":358,"column":0},"end":{"line":359,"column":32}},"range":[6531,6596],"raw":"\n- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的\n- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"堆的初始化","loc":{"start":{"line":361,"column":6},"end":{"line":361,"column":11}},"range":[6604,6609],"raw":" 堆的初始"}],"loc":{"start":{"line":361,"column":0},"end":{"line":361,"column":11}},"range":[6598,6609],"raw":"\n##### 堆的初始"},{"type":"Paragraph","children":[{"type":"Str","value":"将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号 ","loc":{"start":{"line":363,"column":0},"end":{"line":364,"column":15}},"range":[6611,6643],"raw":"\n将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号"},{"type":"InlineMath","value":"\\lfloor \\frac{n}{2} \\rfloor 到 1","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"\\lfloor \\frac{n}{2} \\rfloor 到 1"}]},"loc":{"start":{"line":364,"column":15},"end":{"line":364,"column":48}},"range":[6643,6676],"raw":" $\\lfloor \\frac{n}{2} \\rfloor 到 1"},{"type":"Str","value":" 做如下的调整：","loc":{"start":{"line":364,"column":48},"end":{"line":364,"column":56}},"range":[6676,6684],"raw":"$ 做如下的调整"}],"loc":{"start":{"line":363,"column":0},"end":{"line":364,"column":56}},"range":[6611,6684],"raw":"\n将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号 $\\lfloor \\frac{n}{2} \\rfloor 到 1$ 做如下的调整"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整","loc":{"start":{"line":366,"column":2},"end":{"line":366,"column":52}},"range":[6688,6738],"raw":" 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调"}],"loc":{"start":{"line":366,"column":2},"end":{"line":366,"column":52}},"range":[6688,6738],"raw":" 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调"}],"loc":{"start":{"line":366,"column":0},"end":{"line":366,"column":52}},"range":[6686,6738],"raw":"\n- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果该节点的孩子结点的值均小于该节点，该节点的调整结束","loc":{"start":{"line":367,"column":2},"end":{"line":367,"column":29}},"range":[6741,6768],"raw":" 如果该节点的孩子结点的值均小于该节点，该节点的调整结"}],"loc":{"start":{"line":367,"column":2},"end":{"line":367,"column":29}},"range":[6741,6768],"raw":" 如果该节点的孩子结点的值均小于该节点，该节点的调整结"}],"loc":{"start":{"line":367,"column":0},"end":{"line":367,"column":29}},"range":[6739,6768],"raw":"\n- 如果该节点的孩子结点的值均小于该节点，该节点的调整结"}],"loc":{"start":{"line":366,"column":0},"end":{"line":367,"column":29}},"range":[6686,6768],"raw":"\n- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整\n- 如果该节点的孩子结点的值均小于该节点，该节点的调整结"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":369,"column":6},"end":{"line":369,"column":10}},"range":[6776,6780],"raw":" 代码实"}],"loc":{"start":{"line":369,"column":0},"end":{"line":369,"column":10}},"range":[6770,6780],"raw":"\n##### 代码实"},{"type":"CodeBlock","lang":"c","meta":null,"value":"// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}","loc":{"start":{"line":371,"column":0},"end":{"line":401,"column":3}},"range":[6782,7497],"raw":"\n```c\n// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":403,"column":6},"end":{"line":403,"column":11}},"range":[7505,7510],"raw":" 时空复杂"}],"loc":{"start":{"line":403,"column":0},"end":{"line":403,"column":11}},"range":[7499,7510],"raw":"\n##### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度： ","loc":{"start":{"line":405,"column":0},"end":{"line":405,"column":7}},"range":[7512,7519],"raw":"\n时间复杂度："},{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":405,"column":7},"end":{"line":405,"column":23}},"range":[7519,7535],"raw":" $O(nlog_{2}(n))"}],"loc":{"start":{"line":405,"column":0},"end":{"line":405,"column":24}},"range":[7512,7536],"raw":"\n时间复杂度： $O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度： ","loc":{"start":{"line":407,"column":0},"end":{"line":407,"column":7}},"range":[7538,7545],"raw":"\n空间复杂度："},{"type":"InlineMath","value":"O(1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(1)"}]},"loc":{"start":{"line":407,"column":7},"end":{"line":407,"column":13}},"range":[7545,7551],"raw":" $O(1)"}],"loc":{"start":{"line":407,"column":0},"end":{"line":407,"column":14}},"range":[7538,7552],"raw":"\n空间复杂度： $O(1)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":409,"column":6},"end":{"line":409,"column":9}},"range":[7560,7563],"raw":" 稳定"}],"loc":{"start":{"line":409,"column":0},"end":{"line":409,"column":9}},"range":[7554,7563],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":411,"column":0},"end":{"line":411,"column":3}},"range":[7565,7568],"raw":"\n不稳"}],"loc":{"start":{"line":411,"column":0},"end":{"line":411,"column":3}},"range":[7565,7568],"raw":"\n不稳"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":413,"column":6},"end":{"line":413,"column":10}},"range":[7576,7580],"raw":" 存储结"}],"loc":{"start":{"line":413,"column":0},"end":{"line":413,"column":10}},"range":[7570,7580],"raw":"\n##### 存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":415,"column":0},"end":{"line":415,"column":12}},"range":[7582,7594],"raw":"\n适用于顺序存储和链式存"}],"loc":{"start":{"line":415,"column":0},"end":{"line":415,"column":12}},"range":[7582,7594],"raw":"\n适用于顺序存储和链式存"},{"type":"HorizontalRule","loc":{"start":{"line":417,"column":0},"end":{"line":417,"column":5}},"range":[7596,7601],"raw":"\n****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":419,"column":4},"end":{"line":419,"column":8}},"range":[7607,7611],"raw":" 归并排"}],"loc":{"start":{"line":419,"column":0},"end":{"line":419,"column":8}},"range":[7603,7611],"raw":"\n### 归并排"},{"type":"Paragraph","children":[{"type":"Str","value":"二路归并排序：","loc":{"start":{"line":421,"column":0},"end":{"line":421,"column":7}},"range":[7613,7620],"raw":"\n二路归并排序"}],"loc":{"start":{"line":421,"column":0},"end":{"line":421,"column":7}},"range":[7613,7620],"raw":"\n二路归并排序"},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png","alt":"quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png","loc":{"start":{"line":423,"column":0},"end":{"line":423,"column":102}},"range":[7622,7724],"raw":"\n![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png"}],"loc":{"start":{"line":423,"column":0},"end":{"line":423,"column":102}},"range":[7622,7724],"raw":"\n![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}","loc":{"start":{"line":425,"column":0},"end":{"line":452,"column":3}},"range":[7726,8446],"raw":"\n```c\nint *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}\n``"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":454,"column":6},"end":{"line":454,"column":11}},"range":[8454,8459],"raw":" 时空复杂"}],"loc":{"start":{"line":454,"column":0},"end":{"line":454,"column":11}},"range":[8448,8459],"raw":"\n##### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度： ","loc":{"start":{"line":456,"column":0},"end":{"line":456,"column":7}},"range":[8461,8468],"raw":"\n时间复杂度："},{"type":"InlineMath","value":"O(nlog_{2}(n))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(nlog_{2}(n))"}]},"loc":{"start":{"line":456,"column":7},"end":{"line":456,"column":23}},"range":[8468,8484],"raw":" $O(nlog_{2}(n))"}],"loc":{"start":{"line":456,"column":0},"end":{"line":456,"column":24}},"range":[8461,8485],"raw":"\n时间复杂度： $O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度： ","loc":{"start":{"line":458,"column":0},"end":{"line":458,"column":7}},"range":[8487,8494],"raw":"\n空间复杂度："},{"type":"InlineMath","value":"O(n)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(n)"}]},"loc":{"start":{"line":458,"column":7},"end":{"line":458,"column":13}},"range":[8494,8500],"raw":" $O(n)"}],"loc":{"start":{"line":458,"column":0},"end":{"line":458,"column":14}},"range":[8487,8501],"raw":"\n空间复杂度： $O(n)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":460,"column":6},"end":{"line":460,"column":9}},"range":[8509,8512],"raw":" 稳定"}],"loc":{"start":{"line":460,"column":0},"end":{"line":460,"column":9}},"range":[8503,8512],"raw":"\n##### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"归并排序是稳定的","loc":{"start":{"line":462,"column":0},"end":{"line":462,"column":8}},"range":[8514,8522],"raw":"\n归并排序是稳定"}],"loc":{"start":{"line":462,"column":0},"end":{"line":462,"column":8}},"range":[8514,8522],"raw":"\n归并排序是稳定"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":464,"column":6},"end":{"line":464,"column":10}},"range":[8530,8534],"raw":" 存储结"}],"loc":{"start":{"line":464,"column":0},"end":{"line":464,"column":10}},"range":[8524,8534],"raw":"\n##### 存储结"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":466,"column":0},"end":{"line":466,"column":12}},"range":[8536,8548],"raw":"\n适用于顺序存储和链式存"}],"loc":{"start":{"line":466,"column":0},"end":{"line":466,"column":12}},"range":[8536,8548],"raw":"\n适用于顺序存储和链式存"},{"type":"HorizontalRule","loc":{"start":{"line":468,"column":0},"end":{"line":468,"column":5}},"range":[8550,8555],"raw":"\n****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":470,"column":4},"end":{"line":470,"column":8}},"range":[8561,8565],"raw":" 基数排"}],"loc":{"start":{"line":470,"column":0},"end":{"line":470,"column":8}},"range":[8557,8565],"raw":"\n### 基数排"},{"type":"Paragraph","children":[{"type":"Str","value":"借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。","loc":{"start":{"line":472,"column":0},"end":{"line":472,"column":51}},"range":[8567,8618],"raw":"\n借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)"}],"loc":{"start":{"line":472,"column":0},"end":{"line":472,"column":51}},"range":[8567,8618],"raw":"\n借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)"},{"type":"Paragraph","children":[{"type":"Str","value":"LSD基数排序的过程：","loc":{"start":{"line":474,"column":0},"end":{"line":474,"column":11}},"range":[8620,8631],"raw":"\nLSD基数排序的过程"}],"loc":{"start":{"line":474,"column":0},"end":{"line":474,"column":11}},"range":[8620,8631],"raw":"\nLSD基数排序的过程"},{"type":"Paragraph","children":[{"type":"Str","value":"假设线性表由 ","loc":{"start":{"line":476,"column":0},"end":{"line":476,"column":7}},"range":[8633,8640],"raw":"\n假设线性表由"},{"type":"InlineMath","value":"a_{0}, a_{1},...,a_{n-1}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"a_{0}, a_{1},...,a_{n-1}"}]},"loc":{"start":{"line":476,"column":7},"end":{"line":476,"column":33}},"range":[8640,8666],"raw":" $a_{0}, a_{1},...,a_{n-1}"},{"type":"Str","value":" 构成，每个结点 ","loc":{"start":{"line":476,"column":33},"end":{"line":476,"column":42}},"range":[8666,8675],"raw":"$ 构成，每个结点"},{"type":"InlineMath","value":"a_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"a_{j}"}]},"loc":{"start":{"line":476,"column":42},"end":{"line":476,"column":49}},"range":[8675,8682],"raw":" $a_{j}"},{"type":"Str","value":" 的关键字由d元组 ","loc":{"start":{"line":476,"column":49},"end":{"line":476,"column":59}},"range":[8682,8692],"raw":"$ 的关键字由d元组"},{"type":"InlineMath","value":"(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})"}]},"loc":{"start":{"line":476,"column":59},"end":{"line":476,"column":106}},"range":[8692,8739],"raw":" $(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})"},{"type":"Str","value":" 组成，其中 ","loc":{"start":{"line":476,"column":106},"end":{"line":476,"column":113}},"range":[8739,8746],"raw":"$ 组成，其中"},{"type":"InlineMath","value":"0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)"}]},"loc":{"start":{"line":476,"column":113},"end":{"line":476,"column":169}},"range":[8746,8802],"raw":" $0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)"},{"type":"Str","value":" 。","loc":{"start":{"line":476,"column":169},"end":{"line":476,"column":171}},"range":[8802,8804],"raw":"$ "}],"loc":{"start":{"line":476,"column":0},"end":{"line":476,"column":171}},"range":[8633,8804],"raw":"\n假设线性表由 $a_{0}, a_{1},...,a_{n-1}$ 构成，每个结点 $a_{j}$ 的关键字由d元组 $(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})$ 组成，其中 $0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$ "},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"使用r个辅助队列  ","loc":{"start":{"line":478,"column":2},"end":{"line":478,"column":12}},"range":[8808,8818],"raw":" 使用r个辅助队列 "},{"type":"InlineMath","value":"Q_{0}, Q_{1},..., Q_{r-1}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"Q_{0}, Q_{1},..., Q_{r-1}"}]},"loc":{"start":{"line":478,"column":12},"end":{"line":478,"column":39}},"range":[8818,8845],"raw":" $Q_{0}, Q_{1},..., Q_{r-1}"}],"loc":{"start":{"line":478,"column":2},"end":{"line":478,"column":41}},"range":[8808,8847],"raw":" 使用r个辅助队列  $Q_{0}, Q_{1},..., Q_{r-1}$ "}],"loc":{"start":{"line":478,"column":0},"end":{"line":478,"column":41}},"range":[8806,8847],"raw":"\n- 使用r个辅助队列  $Q_{0}, Q_{1},..., Q_{r-1}$ "},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始时将r个辅助队列置为空","loc":{"start":{"line":479,"column":2},"end":{"line":479,"column":15}},"range":[8850,8863],"raw":" 初始时将r个辅助队列置为"}],"loc":{"start":{"line":479,"column":2},"end":{"line":479,"column":15}},"range":[8850,8863],"raw":" 初始时将r个辅助队列置为"}],"loc":{"start":{"line":479,"column":0},"end":{"line":479,"column":15}},"range":[8848,8863],"raw":"\n- 初始时将r个辅助队列置为"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"分配：依次考察线性表中各个结点的 ","loc":{"start":{"line":480,"column":2},"end":{"line":480,"column":19}},"range":[8866,8883],"raw":" 分配：依次考察线性表中各个结点的"},{"type":"InlineMath","value":"a_{j}(j=0,1,...,n-1)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"a_{j}(j=0,1,...,n-1)"}]},"loc":{"start":{"line":480,"column":19},"end":{"line":480,"column":41}},"range":[8883,8905],"raw":" $a_{j}(j=0,1,...,n-1)"},{"type":"Str","value":" ，若结点 ","loc":{"start":{"line":480,"column":41},"end":{"line":480,"column":47}},"range":[8905,8911],"raw":"$ ，若结点"},{"type":"InlineMath","value":"a_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"a_{j}"}]},"loc":{"start":{"line":480,"column":47},"end":{"line":480,"column":54}},"range":[8911,8918],"raw":" $a_{j}"},{"type":"Str","value":" 的关键字的 ","loc":{"start":{"line":480,"column":54},"end":{"line":480,"column":61}},"range":[8918,8925],"raw":"$ 的关键字的"},{"type":"InlineMath","value":"k_{j}^{i}=k","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"k_{j}^{i}=k"}]},"loc":{"start":{"line":480,"column":61},"end":{"line":480,"column":74}},"range":[8925,8938],"raw":" $k_{j}^{i}=k"},{"type":"Str","value":" ，就把 ","loc":{"start":{"line":480,"column":74},"end":{"line":480,"column":79}},"range":[8938,8943],"raw":"$ ，就把"},{"type":"InlineMath","value":"a_{j}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"a_{j}"}]},"loc":{"start":{"line":480,"column":79},"end":{"line":480,"column":86}},"range":[8943,8950],"raw":" $a_{j}"},{"type":"Str","value":" 放进队列 ","loc":{"start":{"line":480,"column":86},"end":{"line":480,"column":92}},"range":[8950,8956],"raw":"$ 放进队列"},{"type":"InlineMath","value":"Q_{k}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"Q_{k}"}]},"loc":{"start":{"line":480,"column":92},"end":{"line":480,"column":99}},"range":[8956,8963],"raw":" $Q_{k}"},{"type":"Str","value":" 。","loc":{"start":{"line":480,"column":99},"end":{"line":480,"column":101}},"range":[8963,8965],"raw":"$ "}],"loc":{"start":{"line":480,"column":2},"end":{"line":480,"column":101}},"range":[8866,8965],"raw":" 分配：依次考察线性表中各个结点的 $a_{j}(j=0,1,...,n-1)$ ，若结点 $a_{j}$ 的关键字的 $k_{j}^{i}=k$ ，就把 $a_{j}$ 放进队列 $Q_{k}$ "}],"loc":{"start":{"line":480,"column":0},"end":{"line":480,"column":101}},"range":[8864,8965],"raw":"\n- 分配：依次考察线性表中各个结点的 $a_{j}(j=0,1,...,n-1)$ ，若结点 $a_{j}$ 的关键字的 $k_{j}^{i}=k$ ，就把 $a_{j}$ 放进队列 $Q_{k}$ "},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"收集：把  ","loc":{"start":{"line":481,"column":2},"end":{"line":481,"column":8}},"range":[8968,8974],"raw":" 收集：把 "},{"type":"InlineMath","value":"Q_{0}, Q_{1},..., Q_{r-1}","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"Q_{0}, Q_{1},..., Q_{r-1}"}]},"loc":{"start":{"line":481,"column":8},"end":{"line":481,"column":35}},"range":[8974,9001],"raw":" $Q_{0}, Q_{1},..., Q_{r-1}"},{"type":"Str","value":"  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。","loc":{"start":{"line":481,"column":35},"end":{"line":481,"column":70}},"range":[9001,9036],"raw":"$  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表"}],"loc":{"start":{"line":481,"column":2},"end":{"line":481,"column":70}},"range":[8968,9036],"raw":" 收集：把  $Q_{0}, Q_{1},..., Q_{r-1}$  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表"}],"loc":{"start":{"line":481,"column":0},"end":{"line":481,"column":70}},"range":[8966,9036],"raw":"\n- 收集：把  $Q_{0}, Q_{1},..., Q_{r-1}$  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表"}],"loc":{"start":{"line":478,"column":0},"end":{"line":481,"column":70}},"range":[8806,9036],"raw":"\n- 使用r个辅助队列  $Q_{0}, Q_{1},..., Q_{r-1}$  \n- 初始时将r个辅助队列置为空\n- 分配：依次考察线性表中各个结点的 $a_{j}(j=0,1,...,n-1)$ ，若结点 $a_{j}$ 的关键字的 $k_{j}^{i}=k$ ，就把 $a_{j}$ 放进队列 $Q_{k}$ 。\n- 收集：把  $Q_{0}, Q_{1},..., Q_{r-1}$  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":483,"column":5},"end":{"line":483,"column":10}},"range":[9043,9048],"raw":" 时空复杂"}],"loc":{"start":{"line":483,"column":0},"end":{"line":483,"column":10}},"range":[9038,9048],"raw":"\n#### 时空复杂"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度： ","loc":{"start":{"line":485,"column":0},"end":{"line":485,"column":7}},"range":[9050,9057],"raw":"\n时间复杂度："},{"type":"InlineMath","value":"O(d(n+r))","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(d(n+r))"}]},"loc":{"start":{"line":485,"column":7},"end":{"line":485,"column":18}},"range":[9057,9068],"raw":" $O(d(n+r))"}],"loc":{"start":{"line":485,"column":0},"end":{"line":485,"column":19}},"range":[9050,9069],"raw":"\n时间复杂度： $O(d(n+r))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度： ","loc":{"start":{"line":487,"column":0},"end":{"line":487,"column":7}},"range":[9071,9078],"raw":"\n空间复杂度："},{"type":"InlineMath","value":"O(r)","data":{"hName":"span","hProperties":{"className":["math","math-inline"]},"hChildren":[{"type":"Str","value":"O(r)"}]},"loc":{"start":{"line":487,"column":7},"end":{"line":487,"column":13}},"range":[9078,9084],"raw":" $O(r)"}],"loc":{"start":{"line":487,"column":0},"end":{"line":487,"column":14}},"range":[9071,9085],"raw":"\n空间复杂度： $O(r)$"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":489,"column":5},"end":{"line":489,"column":8}},"range":[9092,9095],"raw":" 稳定"}],"loc":{"start":{"line":489,"column":0},"end":{"line":489,"column":8}},"range":[9087,9095],"raw":"\n#### 稳定"},{"type":"Paragraph","children":[{"type":"Str","value":"基数排序是稳定的","loc":{"start":{"line":491,"column":0},"end":{"line":491,"column":8}},"range":[9097,9105],"raw":"\n基数排序是稳定"}],"loc":{"start":{"line":491,"column":0},"end":{"line":491,"column":8}},"range":[9097,9105],"raw":"\n基数排序是稳定"},{"type":"HorizontalRule","loc":{"start":{"line":493,"column":0},"end":{"line":493,"column":5}},"range":[9107,9112],"raw":"\n****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"外部排序","loc":{"start":{"line":495,"column":3},"end":{"line":495,"column":7}},"range":[9117,9121],"raw":" 外部排"}],"loc":{"start":{"line":495,"column":0},"end":{"line":495,"column":7}},"range":[9114,9121],"raw":"\n## 外部排"},{"type":"Paragraph","children":[{"type":"Str","value":"排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序","loc":{"start":{"line":497,"column":0},"end":{"line":497,"column":64}},"range":[9123,9187],"raw":"\n排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排"}],"loc":{"start":{"line":497,"column":0},"end":{"line":497,"column":64}},"range":[9123,9187],"raw":"\n排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排"}],"loc":{"start":{"line":1,"column":0},"end":{"line":498,"column":0}},"range":[0,9188],"raw":"﻿---\ntitle: '各种排序算法总结'\ntags: ['数据结构','排序']\n---\n# 排序的基本概念\n\n## 各种排序算法汇总\n\n|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构|\n|-|-|-|-|-|-|-|\n|直接插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持|\n|折半插入排序|插入排序| $O(n^{2})$ | $O(1)$ |稳定|支持|不支持|\n|希尔排序|插入排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|不支持|\n|冒泡排序|交换排序| $O(n^{2})$ | $O(1)$ |稳定|支持|支持|\n|快速排序|交换排序|最好、平均： $O(nlog_{2}(n))$ ，最坏： $O(n^{2})$ |最好、平均： $O(log_{2}(n))$ ，最坏： $O(n)$ |不稳定|支持||\n|简单选择排序|选择排序| $O(n^{2})$ | $O(1)$ |不稳定|支持|支持|\n|堆排序|选择排序| $O(nlog_{2}(n))$ | $O(1)$ |不稳定|支持|支持|\n|归并排序|归并排序| $O(nlog_{2}(n))$ | $O(n)$ |稳定|支持|支持|\n|基数排序|基数排序| $O(d(n+r))$ | $O(r)$ |稳定|支持|支持|\n\n*****\n\n## 基本概念\n\n### 排序的定义\n\n重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。\n\n### 排序的时间复杂度和空间复杂度\n\n### 排序的稳定性\n\n如果表中有两个元素 $R_{i}$ 和 $R_{j}$ ，其对应的关键字 $key_{i}=key_{j}$ ，且 $R_{i}$ 排在 $R_{j}$ 前面，使用某一排序算法后， $R_{i}$ 仍排在 $R_{j}$ 前面，就称这个算法是稳定的。\n\n*****\n\n## 内部排序\n\n排序过程中，所有的元素都存放在内存中的排序。\n\n公式：对任意n个元素的列表进行排序的比较次数至少为  $\\lceil log_{2}{(n!)} \\rceil$  。\n\n### 插入排序\n\n每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。\n\n*****\n\n#### 直接插入排序\n\n|有序序列|要插入的|无序序列|\n|-|-|-|\n| $L[1...i-1]$ | $L(i)$ | $L[i+1...n]$ |\n\n1. 查找 $L(i)$ 的插入位置k；\n2. 将 $L[k...i-1]$ 所有的元素都向后移动一个位置；\n3. 将 $L(i)$ 复制到k的位置。\n\n##### 代码实现\n\n```c\nvoid InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}\n```\n\n##### 时间复杂度\n\n当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为 $O(n^{2})$ 。\n\n##### 空间复杂度\n\n只用到一个用于赋值的临时变量，空间复杂度为O(1)。\n\n##### 稳定性\n\n比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。\n\n##### 存储结构\n\n排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储\n\n*****\n\n#### 折半插入排序（二分插入排序）\n\n使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。\n\n##### 代码实现\n\n```c\nvoid BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}\n```\n\n##### 时间复杂度\n\n由于查找过程使用了二分查找，所以其时间复杂度是 $O(n*n*log_{2}(n))=O(n^{2})$ 。\n\n##### 空间复杂度\n\n只是用到了常数个额外的内存空间，所以其空间复杂度是 $O(1)$ 。\n\n##### 排序稳定性\n\n与直接插入排序相同\n\n##### 存储结构\n\n由于使用了二分查找，所以只能适用于顺序存储的线性表\n\n*****\n\n#### 希尔排序（缩小增量排序）\n\n- 先将要排序的序列分割成 $d=d_{i}$ 个形如  $L[i,i+d,i+2d,...,i+kd]$  的子序列\n- 对各个子序列进行直接插入排序\n- 令 $d=d_{i+1}$ ，重复上面的两步，直到d=1时，排序完成\n\n $d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1$ \n\n##### 代码实现\n\n```c\nvoid ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}\n```\n\n##### 时间复杂度\n\n希尔排序的时间复杂度 $O(n^{2})$ ，n在某一个范围之内的时候，希尔排序的时间复杂度可以到 $O(n^{1.3})$ \n\n##### 空间复杂度\n\n辅助空间是常数级的，空间复杂度是 $O(1)$ 。\n\n##### 希尔排序的稳定性\n\n希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。\n\n##### 希尔排序的存储结构\n\n用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。\n\n*****\n\n### 交换排序\n\n#### 冒泡排序\n\n一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。\n\n然后再对前面的n-1个元素进行一轮冒泡，依次类推。\n\n##### 代码实现\n\n```c\n#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度：O(n^{2})\n\n空间复杂度：O(1)\n\n##### 稳定性\n\n冒泡排序是稳定的\n\n#### 快排排序\n\n在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。\n\n然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。\n\n基本思路：\n\n1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元素\n2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素\n3. 交换low和high指向的元素\n4. 继续移动low和high直到low>=high\n\n##### 代码实现\n\n```c\nint Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}\n```\n\n##### 时空复杂度\n\n最好、平均时间复杂度： $O(nlog_{2}(n))$ \n\n最好、平均空间复杂度： $O(log_{2}(n))$ \n\n最坏空间复杂度： $O(n)$ \n\n最坏时间复杂度： $O(n^{2})$ \n\n##### 稳定性\n\n快速排序是不稳定的\n\n******\n\n### 选择排序\n\n#### 简单选择排序\n\n在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。\n\n##### 代码实现\n\n```c\nvoid SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}\n```\n\n##### 稳定性\n\n选择排序是不稳定的\n\n##### 时空复杂度\n\n时间复杂度： $O(n^{2})$ \n\n空间复杂度： $O(1)$ \n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n#### 堆排序\n\n> 堆：n个关键字序列 $L[1...n]$ 称为堆，当且仅当该序列满足：\n> 1. 若 $L(i) \\leq L(2i)$ 且 $L(i) \\leq L(2i+1)$ ，称该堆为小根堆\n> 2. 若 $L(i) \\geq L(2i)$ 且 $L(i) \\geq L(2i+1)$ ，称该堆为大根堆\n>\n> 在排序得过程中，将序列 $L[1...n]$ 视为一棵完全二叉树\n\n- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的\n- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的\n\n##### 堆的初始化\n\n将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号 $\\lfloor \\frac{n}{2} \\rfloor 到 1$ 做如下的调整：\n\n- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整\n- 如果该节点的孩子结点的值均小于该节点，该节点的调整结束\n\n##### 代码实现\n\n```c\n// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度： $O(nlog_{2}(n))$ \n\n空间复杂度： $O(1)$ \n\n##### 稳定性\n\n不稳定\n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n### 归并排序\n\n二路归并排序：\n\n![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png)\n\n```c\nint *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度： $O(nlog_{2}(n))$ \n\n空间复杂度： $O(n)$ \n\n##### 稳定性\n\n归并排序是稳定的\n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n### 基数排序\n\n借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。\n\nLSD基数排序的过程：\n\n假设线性表由 $a_{0}, a_{1},...,a_{n-1}$ 构成，每个结点 $a_{j}$ 的关键字由d元组 $(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})$ 组成，其中 $0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$ 。\n\n- 使用r个辅助队列  $Q_{0}, Q_{1},..., Q_{r-1}$  \n- 初始时将r个辅助队列置为空\n- 分配：依次考察线性表中各个结点的 $a_{j}(j=0,1,...,n-1)$ ，若结点 $a_{j}$ 的关键字的 $k_{j}^{i}=k$ ，就把 $a_{j}$ 放进队列 $Q_{k}$ 。\n- 收集：把  $Q_{0}, Q_{1},..., Q_{r-1}$  各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。\n\n#### 时空复杂度\n\n时间复杂度： $O(d(n+r))$ \n\n空间复杂度： $O(r)$ \n\n#### 稳定性\n\n基数排序是稳定的\n\n*****\n\n## 外部排序\n\n排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序"},"catalogue":{"title":"各种排序算法总结","json-path":"数据结构/2020-08-09-排序的基本概念.json","mdate":"2020-08-09","cover":"https://i.328888.xyz/2022/12/31/ndrgP.jpeg","icon":"🦁","visible":true,"tags":["数据结构","排序"]}}