{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: 'NPM 依赖更新策略引起的问题排查'\ntags: ['前端', 'NodeJS', 'NPM']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,64],"raw":"---\ntitle: 'NPM 依赖更新策略引起的问题排查'\ntags: ['前端', 'NodeJS', 'NPM']\n---","visible":false},{"type":"Header","depth":1,"children":[{"type":"Str","value":"NPM 依赖更新算法","loc":{"start":{"line":6,"column":2},"end":{"line":6,"column":12}},"range":[68,78],"raw":"NPM 依赖更新算法"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":12}},"range":[66,78],"raw":"# NPM 依赖更新算法"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"在工作中，同事遇到一个问题，和我一起研究了下：\n同事的项目里原本的 package-lock.json 将一个 NPM 包 packageA 锁定在了 1.0.1，但是在 TA 使用 npm install 来更新一个 packageC 的版本时，神奇的事情发生了，另一个包 packageA 和 TA 的项目不兼容了，项目直接跑不起来了。\n同样的代码，clone 到我的电脑上，就可以正常启动。","loc":{"start":{"line":8,"column":2},"end":{"line":10,"column":27}},"range":[82,280],"raw":"在工作中，同事遇到一个问题，和我一起研究了下：\n同事的项目里原本的 package-lock.json 将一个 NPM 包 packageA 锁定在了 1.0.1，但是在 TA 使用 npm install 来更新一个 packageC 的版本时，神奇的事情发生了，另一个包 packageA 和 TA 的项目不兼容了，项目直接跑不起来了。\n同样的代码，clone 到我的电脑上，就可以正常启动。"}],"loc":{"start":{"line":8,"column":2},"end":{"line":10,"column":27}},"range":[82,280],"raw":"在工作中，同事遇到一个问题，和我一起研究了下：\n同事的项目里原本的 package-lock.json 将一个 NPM 包 packageA 锁定在了 1.0.1，但是在 TA 使用 npm install 来更新一个 packageC 的版本时，神奇的事情发生了，另一个包 packageA 和 TA 的项目不兼容了，项目直接跑不起来了。\n同样的代码，clone 到我的电脑上，就可以正常启动。"}],"loc":{"start":{"line":8,"column":0},"end":{"line":11,"column":2}},"range":[80,283],"raw":"> 在工作中，同事遇到一个问题，和我一起研究了下：\n同事的项目里原本的 package-lock.json 将一个 NPM 包 packageA 锁定在了 1.0.1，但是在 TA 使用 npm install 来更新一个 packageC 的版本时，神奇的事情发生了，另一个包 packageA 和 TA 的项目不兼容了，项目直接跑不起来了。\n同样的代码，clone 到我的电脑上，就可以正常启动。\n> "},{"type":"Paragraph","children":[{"type":"Str","value":"同样的代码，在一个电脑上可以启动，而另一个电脑上不能启动，那自然会联想到是环境的问题。","loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":43}},"range":[285,328],"raw":"同样的代码，在一个电脑上可以启动，而另一个电脑上不能启动，那自然会联想到是环境的问题。"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":43}},"range":[285,328],"raw":"同样的代码，在一个电脑上可以启动，而另一个电脑上不能启动，那自然会联想到是环境的问题。"},{"type":"Paragraph","children":[{"type":"Str","value":"同事 TA 使用的 NodeJS 14，npm 版本是 6.x，而我使用的 NodeJS 版本是 16，npm 版本是 8.x。","loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":64}},"range":[330,394],"raw":"同事 TA 使用的 NodeJS 14，npm 版本是 6.x，而我使用的 NodeJS 版本是 16，npm 版本是 8.x。"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":64}},"range":[330,394],"raw":"同事 TA 使用的 NodeJS 14，npm 版本是 6.x，而我使用的 NodeJS 版本是 16，npm 版本是 8.x。"},{"type":"Paragraph","children":[{"type":"Str","value":"即使是有 package-lock.json，使用不同版本 npm，对同一个项目的依赖进行安装时，安装到的依赖版本号是可能存在差异的，这是由于不同版本的 NPM 在 ","loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":83}},"range":[396,479],"raw":"即使是有 package-lock.json，使用不同版本 npm，对同一个项目的依赖进行安装时，安装到的依赖版本号是可能存在差异的，这是由于不同版本的 NPM 在 "},{"type":"Code","value":"npm install","loc":{"start":{"line":17,"column":83},"end":{"line":17,"column":96}},"range":[479,492],"raw":"`npm install`"},{"type":"Str","value":" 或者 ","loc":{"start":{"line":17,"column":96},"end":{"line":17,"column":100}},"range":[492,496],"raw":" 或者 "},{"type":"Code","value":"npm update","loc":{"start":{"line":17,"column":100},"end":{"line":17,"column":112}},"range":[496,508],"raw":"`npm update`"},{"type":"Str","value":" 时的策略是不一样的。","loc":{"start":{"line":17,"column":112},"end":{"line":17,"column":123}},"range":[508,519],"raw":" 时的策略是不一样的。"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":123}},"range":[396,519],"raw":"即使是有 package-lock.json，使用不同版本 npm，对同一个项目的依赖进行安装时，安装到的依赖版本号是可能存在差异的，这是由于不同版本的 NPM 在 `npm install` 或者 `npm update` 时的策略是不一样的。"},{"type":"Paragraph","children":[{"type":"Str","value":"⚠️⚠️：","loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":5}},"range":[521,526],"raw":"⚠️⚠️："},{"type":"Strong","children":[{"type":"Str","value":"不止有执行 ","loc":{"start":{"line":19,"column":7},"end":{"line":19,"column":13}},"range":[528,534],"raw":"不止有执行 "},{"type":"Code","value":"npm update","loc":{"start":{"line":19,"column":13},"end":{"line":19,"column":25}},"range":[534,546],"raw":"`npm update`"},{"type":"Str","value":" 时会更新依赖，在有些情况下执行 ","loc":{"start":{"line":19,"column":25},"end":{"line":19,"column":42}},"range":[546,563],"raw":" 时会更新依赖，在有些情况下执行 "},{"type":"Code","value":"npm install","loc":{"start":{"line":19,"column":42},"end":{"line":19,"column":55}},"range":[563,576],"raw":"`npm install`"},{"type":"Str","value":" 也会更新依赖","loc":{"start":{"line":19,"column":55},"end":{"line":19,"column":62}},"range":[576,583],"raw":" 也会更新依赖"}],"loc":{"start":{"line":19,"column":5},"end":{"line":19,"column":64}},"range":[526,585],"raw":"**不止有执行 `npm update` 时会更新依赖，在有些情况下执行 `npm install` 也会更新依赖**"},{"type":"Str","value":"。","loc":{"start":{"line":19,"column":64},"end":{"line":19,"column":65}},"range":[585,586],"raw":"。"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":65}},"range":[521,586],"raw":"⚠️⚠️：**不止有执行 `npm update` 时会更新依赖，在有些情况下执行 `npm install` 也会更新依赖**。"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"NPM 6.x 嵌套更新","loc":{"start":{"line":21,"column":2},"end":{"line":21,"column":14}},"range":[590,602],"raw":"NPM 6.x 嵌套更新"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":14}},"range":[588,602],"raw":"# NPM 6.x 嵌套更新"},{"type":"Paragraph","children":[{"type":"Str","value":"对于比较老的 NPM 版本，执行 ","loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":17}},"range":[604,621],"raw":"对于比较老的 NPM 版本，执行 "},{"type":"Code","value":"npm install","loc":{"start":{"line":23,"column":17},"end":{"line":23,"column":30}},"range":[621,634],"raw":"`npm install`"},{"type":"Str","value":" 时，npm 会根据 package.json 和 package-lock.json 文件中的依赖树，检查需要更新的依赖包。","loc":{"start":{"line":23,"column":30},"end":{"line":23,"column":93}},"range":[634,697],"raw":" 时，npm 会根据 package.json 和 package-lock.json 文件中的依赖树，检查需要更新的依赖包。"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":93}},"range":[604,697],"raw":"对于比较老的 NPM 版本，执行 `npm install` 时，npm 会根据 package.json 和 package-lock.json 文件中的依赖树，检查需要更新的依赖包。"},{"type":"Paragraph","children":[{"type":"Str","value":"对于需要更新的依赖包，npm 会从底层（依赖树的叶子节点）开始，逐层向上更新，同时检查每一层的依赖包是否冲突，","loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":55}},"range":[699,754],"raw":"对于需要更新的依赖包，npm 会从底层（依赖树的叶子节点）开始，逐层向上更新，同时检查每一层的依赖包是否冲突，"},{"type":"Strong","children":[{"type":"Str","value":"对于冲突的包，npm 会尝试升级以解决冲突","loc":{"start":{"line":25,"column":57},"end":{"line":25,"column":78}},"range":[756,777],"raw":"对于冲突的包，npm 会尝试升级以解决冲突"}],"loc":{"start":{"line":25,"column":55},"end":{"line":25,"column":80}},"range":[754,779],"raw":"**对于冲突的包，npm 会尝试升级以解决冲突**"},{"type":"Str","value":"。这个升级的过程可能会导致依赖树发生变化，从而","loc":{"start":{"line":25,"column":80},"end":{"line":25,"column":103}},"range":[779,802],"raw":"。这个升级的过程可能会导致依赖树发生变化，从而"},{"type":"Strong","children":[{"type":"Str","value":"更新 package-lock.json","loc":{"start":{"line":25,"column":105},"end":{"line":25,"column":125}},"range":[804,824],"raw":"更新 package-lock.json"}],"loc":{"start":{"line":25,"column":103},"end":{"line":25,"column":127}},"range":[802,826],"raw":"**更新 package-lock.json**"},{"type":"Str","value":"。","loc":{"start":{"line":25,"column":127},"end":{"line":25,"column":128}},"range":[826,827],"raw":"。"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":128}},"range":[699,827],"raw":"对于需要更新的依赖包，npm 会从底层（依赖树的叶子节点）开始，逐层向上更新，同时检查每一层的依赖包是否冲突，**对于冲突的包，npm 会尝试升级以解决冲突**。这个升级的过程可能会导致依赖树发生变化，从而**更新 package-lock.json**。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"npm 6.x 的嵌套更新的问题","loc":{"start":{"line":27,"column":3},"end":{"line":27,"column":19}},"range":[832,848],"raw":"npm 6.x 的嵌套更新的问题"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":19}},"range":[829,848],"raw":"## npm 6.x 的嵌套更新的问题"},{"type":"Paragraph","children":[{"type":"Str","value":"NPM 6.x 的这种嵌套更新的机制，没有考虑到间接依赖的升级对项目稳定性的影响。","loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":41}},"range":[850,891],"raw":"NPM 6.x 的这种嵌套更新的机制，没有考虑到间接依赖的升级对项目稳定性的影响。"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":41}},"range":[850,891],"raw":"NPM 6.x 的这种嵌套更新的机制，没有考虑到间接依赖的升级对项目稳定性的影响。"},{"type":"Paragraph","children":[{"type":"Str","value":"packageB 和 packageC 均依赖 packageA：","loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":33}},"range":[893,926],"raw":"packageB 和 packageC 均依赖 packageA："}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":33}},"range":[893,926],"raw":"packageB 和 packageC 均依赖 packageA："},{"type":"CodeBlock","lang":"mermaid","meta":null,"value":"graph TD\n  pA1[packageA:^1.0.1] --> pB[packageB]\n\n\tpA1 -. up .-> pA3[packageA:1.1.0]\n\tnpm[packageA: latest is 1.1.0] -. download .-> pA3\n\tpA2 -. up .-> pA3\n\n\tpA2[packageA:^1.0.1] .-> pC[packageC]\n\n\tpB --> project\n\tpA3 .-> project\n\tpC -. install .-> project","loc":{"start":{"line":33,"column":0},"end":{"line":46,"column":3}},"range":[928,1199],"raw":"```mermaid\ngraph TD\n  pA1[packageA:^1.0.1] --> pB[packageB]\n\n\tpA1 -. up .-> pA3[packageA:1.1.0]\n\tnpm[packageA: latest is 1.1.0] -. download .-> pA3\n\tpA2 -. up .-> pA3\n\n\tpA2[packageA:^1.0.1] .-> pC[packageC]\n\n\tpB --> project\n\tpA3 .-> project\n\tpC -. install .-> project\n```"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"一个项目中开始只有 packageB，package-lock.json 中","loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":40}},"range":[1203,1241],"raw":"一个项目中开始只有 packageB，package-lock.json 中"},{"type":"Strong","children":[{"type":"Str","value":"将 packageA 的版本锁定在 1.0.1 版本","loc":{"start":{"line":48,"column":42},"end":{"line":48,"column":68}},"range":[1243,1269],"raw":"将 packageA 的版本锁定在 1.0.1 版本"}],"loc":{"start":{"line":48,"column":40},"end":{"line":48,"column":70}},"range":[1241,1271],"raw":"**将 packageA 的版本锁定在 1.0.1 版本**"},{"type":"Str","value":"。","loc":{"start":{"line":48,"column":70},"end":{"line":48,"column":71}},"range":[1271,1272],"raw":"。"}],"loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":71}},"range":[1203,1272],"raw":"一个项目中开始只有 packageB，package-lock.json 中**将 packageA 的版本锁定在 1.0.1 版本**。"}],"loc":{"start":{"line":48,"column":0},"end":{"line":48,"column":71}},"range":[1201,1272],"raw":"- 一个项目中开始只有 packageB，package-lock.json 中**将 packageA 的版本锁定在 1.0.1 版本**。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里","loc":{"start":{"line":49,"column":2},"end":{"line":49,"column":51}},"range":[1275,1324],"raw":"过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里"},{"type":"Strong","children":[{"type":"Str","value":"仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。","loc":{"start":{"line":49,"column":53},"end":{"line":49,"column":89}},"range":[1326,1362],"raw":"仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。"}],"loc":{"start":{"line":49,"column":51},"end":{"line":49,"column":91}},"range":[1324,1364],"raw":"**仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。**"}],"loc":{"start":{"line":49,"column":2},"end":{"line":49,"column":91}},"range":[1275,1364],"raw":"过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里**仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。**"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":91}},"range":[1273,1364],"raw":"- 过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里**仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。**"},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"又过了一段时间，我需要向 project 中安装一个 packageC，执行 ","loc":{"start":{"line":50,"column":2},"end":{"line":50,"column":41}},"range":[1367,1406],"raw":"又过了一段时间，我需要向 project 中安装一个 packageC，执行 "},{"type":"Code","value":"npm install packageC","loc":{"start":{"line":50,"column":41},"end":{"line":50,"column":63}},"range":[1406,1428],"raw":"`npm install packageC`"},{"type":"Str","value":" ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。","loc":{"start":{"line":50,"column":63},"end":{"line":50,"column":107}},"range":[1428,1472],"raw":" ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。"}],"loc":{"start":{"line":50,"column":2},"end":{"line":50,"column":107}},"range":[1367,1472],"raw":"又过了一段时间，我需要向 project 中安装一个 packageC，执行 `npm install packageC` ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。"},{"type":"Paragraph","children":[{"type":"Str","value":"但是","loc":{"start":{"line":52,"column":4},"end":{"line":52,"column":6}},"range":[1482,1484],"raw":"但是"},{"type":"Strong","children":[{"type":"Str","value":"由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布","loc":{"start":{"line":52,"column":8},"end":{"line":52,"column":43}},"range":[1486,1521],"raw":"由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布"}],"loc":{"start":{"line":52,"column":6},"end":{"line":52,"column":45}},"range":[1484,1523],"raw":"**由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布**"},{"type":"Str","value":"，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。","loc":{"start":{"line":52,"column":45},"end":{"line":52,"column":138}},"range":[1523,1616],"raw":"，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。"}],"loc":{"start":{"line":52,"column":4},"end":{"line":52,"column":138}},"range":[1482,1616],"raw":"但是**由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布**，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。"}],"loc":{"start":{"line":50,"column":0},"end":{"line":52,"column":138}},"range":[1365,1616],"raw":"- 又过了一段时间，我需要向 project 中安装一个 packageC，执行 `npm install packageC` ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。\n    \n    但是**由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布**，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。"}],"loc":{"start":{"line":48,"column":0},"end":{"line":53,"column":4}},"range":[1201,1621],"raw":"- 一个项目中开始只有 packageB，package-lock.json 中**将 packageA 的版本锁定在 1.0.1 版本**。\n- 过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里**仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。**\n- 又过了一段时间，我需要向 project 中安装一个 packageC，执行 `npm install packageC` ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。\n    \n    但是**由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布**，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。\n    "},{"type":"Header","depth":1,"children":[{"type":"Str","value":"NPM 8.x 自适应更新策略","loc":{"start":{"line":55,"column":2},"end":{"line":55,"column":17}},"range":[1625,1640],"raw":"NPM 8.x 自适应更新策略"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":17}},"range":[1623,1640],"raw":"# NPM 8.x 自适应更新策略"},{"type":"Paragraph","children":[{"type":"Str","value":"造成这场事故的罪魁祸首，就是 NPM 6.x 嵌套更新策略，这个策略过于激进，它会更新 packageC 依赖树中所有的包（自然包括了 packageA）而导致项目不稳定。既然找到了 NPM 6.x 出问题的原因，那为什么在我的电脑上执行同样的操作就不会报错，可以正常启动呢？","loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":138}},"range":[1642,1780],"raw":"造成这场事故的罪魁祸首，就是 NPM 6.x 嵌套更新策略，这个策略过于激进，它会更新 packageC 依赖树中所有的包（自然包括了 packageA）而导致项目不稳定。既然找到了 NPM 6.x 出问题的原因，那为什么在我的电脑上执行同样的操作就不会报错，可以正常启动呢？"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":138}},"range":[1642,1780],"raw":"造成这场事故的罪魁祸首，就是 NPM 6.x 嵌套更新策略，这个策略过于激进，它会更新 packageC 依赖树中所有的包（自然包括了 packageA）而导致项目不稳定。既然找到了 NPM 6.x 出问题的原因，那为什么在我的电脑上执行同样的操作就不会报错，可以正常启动呢？"},{"type":"Paragraph","children":[{"type":"Str","value":"这个就得益于 NPM 8.x 推出的","loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":18}},"range":[1782,1800],"raw":"这个就得益于 NPM 8.x 推出的"},{"type":"Strong","children":[{"type":"Str","value":"自适应的更新策略","loc":{"start":{"line":59,"column":20},"end":{"line":59,"column":28}},"range":[1802,1810],"raw":"自适应的更新策略"}],"loc":{"start":{"line":59,"column":18},"end":{"line":59,"column":30}},"range":[1800,1812],"raw":"**自适应的更新策略**"},{"type":"Str","value":"了，自适应的更新策略相对于 NPM 6.x 而言，其更新时影响的范围更小：","loc":{"start":{"line":59,"column":30},"end":{"line":59,"column":67}},"range":[1812,1849],"raw":"了，自适应的更新策略相对于 NPM 6.x 而言，其更新时影响的范围更小："}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":67}},"range":[1782,1849],"raw":"这个就得益于 NPM 8.x 推出的**自适应的更新策略**了，自适应的更新策略相对于 NPM 6.x 而言，其更新时影响的范围更小："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"npm 8 的自适应更新算法会先尝试","loc":{"start":{"line":61,"column":2},"end":{"line":61,"column":20}},"range":[1853,1871],"raw":"npm 8 的自适应更新算法会先尝试"},{"type":"Strong","children":[{"type":"Str","value":"更新直接依赖：","loc":{"start":{"line":61,"column":22},"end":{"line":61,"column":29}},"range":[1873,1880],"raw":"更新直接依赖："}],"loc":{"start":{"line":61,"column":20},"end":{"line":61,"column":31}},"range":[1871,1882],"raw":"**更新直接依赖：**"}],"loc":{"start":{"line":61,"column":2},"end":{"line":61,"column":31}},"range":[1853,1882],"raw":"npm 8 的自适应更新算法会先尝试**更新直接依赖：**"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"没有冲突，则","loc":{"start":{"line":62,"column":6},"end":{"line":62,"column":12}},"range":[1889,1895],"raw":"没有冲突，则"},{"type":"Strong","children":[{"type":"Str","value":"直接更新成功","loc":{"start":{"line":62,"column":14},"end":{"line":62,"column":20}},"range":[1897,1903],"raw":"直接更新成功"}],"loc":{"start":{"line":62,"column":12},"end":{"line":62,"column":22}},"range":[1895,1905],"raw":"**直接更新成功**"},{"type":"Str","value":"。","loc":{"start":{"line":62,"column":22},"end":{"line":62,"column":23}},"range":[1905,1906],"raw":"。"}],"loc":{"start":{"line":62,"column":6},"end":{"line":62,"column":23}},"range":[1889,1906],"raw":"没有冲突，则**直接更新成功**。"}],"loc":{"start":{"line":62,"column":4},"end":{"line":62,"column":23}},"range":[1887,1906],"raw":"- 没有冲突，则**直接更新成功**。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。","loc":{"start":{"line":63,"column":6},"end":{"line":63,"column":64}},"range":[1913,1971],"raw":"发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"}],"loc":{"start":{"line":63,"column":6},"end":{"line":63,"column":64}},"range":[1913,1971],"raw":"发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"}],"loc":{"start":{"line":63,"column":4},"end":{"line":63,"column":64}},"range":[1911,1971],"raw":"- 发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"}],"loc":{"start":{"line":62,"column":4},"end":{"line":63,"column":64}},"range":[1887,1971],"raw":"- 没有冲突，则**直接更新成功**。\n    - 发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"}],"loc":{"start":{"line":61,"column":0},"end":{"line":63,"column":64}},"range":[1851,1971],"raw":"- npm 8 的自适应更新算法会先尝试**更新直接依赖：**\n    - 没有冲突，则**直接更新成功**。\n    - 发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"}],"loc":{"start":{"line":61,"column":0},"end":{"line":63,"column":64}},"range":[1851,1971],"raw":"- npm 8 的自适应更新算法会先尝试**更新直接依赖：**\n    - 没有冲突，则**直接更新成功**。\n    - 发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。"},{"type":"Paragraph","children":[{"type":"Str","value":"由此可见，在使用 NPM 8.x，在执行 ","loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":21}},"range":[1973,1994],"raw":"由此可见，在使用 NPM 8.x，在执行 "},{"type":"Code","value":"npm install packageC","loc":{"start":{"line":65,"column":21},"end":{"line":65,"column":43}},"range":[1994,2016],"raw":"`npm install packageC`"},{"type":"Str","value":" 操作时，会首先尝试直接安装 packageC，对于 packageC 依赖树上项目里原本就存在的包，在**不冲突时采用项目中的版本。**自然也就不会更新 packageA 了。","loc":{"start":{"line":65,"column":43},"end":{"line":65,"column":132}},"range":[2016,2105],"raw":" 操作时，会首先尝试直接安装 packageC，对于 packageC 依赖树上项目里原本就存在的包，在**不冲突时采用项目中的版本。**自然也就不会更新 packageA 了。"}],"loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":132}},"range":[1973,2105],"raw":"由此可见，在使用 NPM 8.x，在执行 `npm install packageC` 操作时，会首先尝试直接安装 packageC，对于 packageC 依赖树上项目里原本就存在的包，在**不冲突时采用项目中的版本。**自然也就不会更新 packageA 了。"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"问题的解决方案","loc":{"start":{"line":67,"column":2},"end":{"line":67,"column":9}},"range":[2109,2116],"raw":"问题的解决方案"}],"loc":{"start":{"line":67,"column":0},"end":{"line":67,"column":9}},"range":[2107,2116],"raw":"# 问题的解决方案"},{"type":"Paragraph","children":[{"type":"Str","value":"分析清楚了问题发生的条件和原因，解决方案就很明确了，这里列出三种解决方案：","loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":37}},"range":[2118,2155],"raw":"分析清楚了问题发生的条件和原因，解决方案就很明确了，这里列出三种解决方案："}],"loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":37}},"range":[2118,2155],"raw":"分析清楚了问题发生的条件和原因，解决方案就很明确了，这里列出三种解决方案："},{"type":"Header","depth":2,"children":[{"type":"Str","value":"方案一：升级 NPM 版本到 8.x","loc":{"start":{"line":71,"column":3},"end":{"line":71,"column":21}},"range":[2160,2178],"raw":"方案一：升级 NPM 版本到 8.x"}],"loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":21}},"range":[2157,2178],"raw":"## 方案一：升级 NPM 版本到 8.x"},{"type":"Paragraph","children":[{"type":"Str","value":"升级 NodeJS 和 NPM 版本肯定是最优雅的解决方案","loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":29}},"range":[2180,2209],"raw":"升级 NodeJS 和 NPM 版本肯定是最优雅的解决方案"}],"loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":29}},"range":[2180,2209],"raw":"升级 NodeJS 和 NPM 版本肯定是最优雅的解决方案"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：不需要对项目进行任何的修改就可以解决问题","loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":23}},"range":[2211,2234],"raw":"优点：不需要对项目进行任何的修改就可以解决问题"}],"loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":23}},"range":[2211,2234],"raw":"优点：不需要对项目进行任何的修改就可以解决问题"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：本地的 NodeJS 环境自然是好升级的，CI/CD 上的 NodeJS 和 NPM 版本升级起来就要考虑很多了，它是公司所有项目发布都需要经过的流程，如果影响到其他的工程打包，或者埋下了暗坑，又是一场惨痛的事故。","loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":110}},"range":[2236,2346],"raw":"缺点：本地的 NodeJS 环境自然是好升级的，CI/CD 上的 NodeJS 和 NPM 版本升级起来就要考虑很多了，它是公司所有项目发布都需要经过的流程，如果影响到其他的工程打包，或者埋下了暗坑，又是一场惨痛的事故。"}],"loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":110}},"range":[2236,2346],"raw":"缺点：本地的 NodeJS 环境自然是好升级的，CI/CD 上的 NodeJS 和 NPM 版本升级起来就要考虑很多了，它是公司所有项目发布都需要经过的流程，如果影响到其他的工程打包，或者埋下了暗坑，又是一场惨痛的事故。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"方案二：手动修改 package-lock.json 中 packageA 的版本","loc":{"start":{"line":79,"column":3},"end":{"line":79,"column":44}},"range":[2351,2392],"raw":"方案二：手动修改 package-lock.json 中 packageA 的版本"}],"loc":{"start":{"line":79,"column":0},"end":{"line":79,"column":44}},"range":[2348,2392],"raw":"## 方案二：手动修改 package-lock.json 中 packageA 的版本"},{"type":"Paragraph","children":[{"type":"Str","value":"手动修改 package-lock.json 里 packageA 的版本为 1.0.1。","loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":45}},"range":[2394,2439],"raw":"手动修改 package-lock.json 里 packageA 的版本为 1.0.1。"}],"loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":45}},"range":[2394,2439],"raw":"手动修改 package-lock.json 里 packageA 的版本为 1.0.1。"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：既然选择升级 NodeJS 和 NPM 的成本很高，那我修改 package-lock.json 里 packageA 的版本，就不会影响别的项目了。","loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":78}},"range":[2441,2519],"raw":"优点：既然选择升级 NodeJS 和 NPM 的成本很高，那我修改 package-lock.json 里 packageA 的版本，就不会影响别的项目了。"}],"loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":78}},"range":[2441,2519],"raw":"优点：既然选择升级 NodeJS 和 NPM 的成本很高，那我修改 package-lock.json 里 packageA 的版本，就不会影响别的项目了。"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：治标不治本，解决得不持久，如果下次再升级 packageC 或者安装依赖了 packageA 的包，那同样的问题又会再次出现。","loc":{"start":{"line":85,"column":0},"end":{"line":85,"column":66}},"range":[2521,2587],"raw":"缺点：治标不治本，解决得不持久，如果下次再升级 packageC 或者安装依赖了 packageA 的包，那同样的问题又会再次出现。"}],"loc":{"start":{"line":85,"column":0},"end":{"line":85,"column":66}},"range":[2521,2587],"raw":"缺点：治标不治本，解决得不持久，如果下次再升级 packageC 或者安装依赖了 packageA 的包，那同样的问题又会再次出现。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"方案三：在项目的 package.json 里将 packageA 作为直接依赖，并约束版本号","loc":{"start":{"line":87,"column":3},"end":{"line":87,"column":50}},"range":[2592,2639],"raw":"方案三：在项目的 package.json 里将 packageA 作为直接依赖，并约束版本号"}],"loc":{"start":{"line":87,"column":0},"end":{"line":87,"column":50}},"range":[2589,2639],"raw":"## 方案三：在项目的 package.json 里将 packageA 作为直接依赖，并约束版本号"},{"type":"Paragraph","children":[{"type":"Str","value":"修改项目 package.json ，在 dependencies 里增加","loc":{"start":{"line":89,"column":0},"end":{"line":89,"column":37}},"range":[2641,2678],"raw":"修改项目 package.json ，在 dependencies 里增加"}],"loc":{"start":{"line":89,"column":0},"end":{"line":89,"column":37}},"range":[2641,2678],"raw":"修改项目 package.json ，在 dependencies 里增加"},{"type":"CodeBlock","lang":"json","meta":null,"value":"{\n\t\"packageA\": \"~1.0.1\"\n}","loc":{"start":{"line":91,"column":0},"end":{"line":95,"column":3}},"range":[2680,2717],"raw":"```json\n{\n\t\"packageA\": \"~1.0.1\"\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"只接受修订版本号更新，这样 NPM 6.x 就不会下载 packageA 的 ","loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":39}},"range":[2719,2758],"raw":"只接受修订版本号更新，这样 NPM 6.x 就不会下载 packageA 的 "},{"type":"Code","value":"1.1.0","loc":{"start":{"line":97,"column":39},"end":{"line":97,"column":46}},"range":[2758,2765],"raw":"`1.1.0`"},{"type":"Str","value":" 版本了。","loc":{"start":{"line":97,"column":46},"end":{"line":97,"column":51}},"range":[2765,2770],"raw":" 版本了。"}],"loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":51}},"range":[2719,2770],"raw":"只接受修订版本号更新，这样 NPM 6.x 就不会下载 packageA 的 `1.1.0` 版本了。"},{"type":"Paragraph","children":[{"type":"Str","value":"这三种方案都可以解决问题，但是不推荐使用第二种方案，这种方案会降低项目的稳定性，下次换个人又会一脸蒙圈了。","loc":{"start":{"line":99,"column":0},"end":{"line":99,"column":53}},"range":[2772,2825],"raw":"这三种方案都可以解决问题，但是不推荐使用第二种方案，这种方案会降低项目的稳定性，下次换个人又会一脸蒙圈了。"}],"loc":{"start":{"line":99,"column":0},"end":{"line":99,"column":53}},"range":[2772,2825],"raw":"这三种方案都可以解决问题，但是不推荐使用第二种方案，这种方案会降低项目的稳定性，下次换个人又会一脸蒙圈了。"},{"type":"Paragraph","children":[{"type":"Str","value":"至于方案一和方案三，就结合实际情况选择即可。","loc":{"start":{"line":101,"column":0},"end":{"line":101,"column":22}},"range":[2827,2849],"raw":"至于方案一和方案三，就结合实际情况选择即可。"}],"loc":{"start":{"line":101,"column":0},"end":{"line":101,"column":22}},"range":[2827,2849],"raw":"至于方案一和方案三，就结合实际情况选择即可。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"方案零：使用 PNPM","loc":{"start":{"line":103,"column":3},"end":{"line":103,"column":14}},"range":[2854,2865],"raw":"方案零：使用 PNPM"}],"loc":{"start":{"line":103,"column":0},"end":{"line":103,"column":14}},"range":[2851,2865],"raw":"## 方案零：使用 PNPM"},{"type":"Paragraph","children":[{"type":"Str","value":"这种方案适用于包与包之间的不兼容导致的项目报错：","loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":24}},"range":[2867,2891],"raw":"这种方案适用于包与包之间的不兼容导致的项目报错："}],"loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":24}},"range":[2867,2891],"raw":"这种方案适用于包与包之间的不兼容导致的项目报错："},{"type":"Paragraph","children":[{"type":"Str","value":"例如项目无法启动是由于 ","loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":12}},"range":[2893,2905],"raw":"例如项目无法启动是由于 "},{"type":"Code","value":"1.1.0","loc":{"start":{"line":107,"column":12},"end":{"line":107,"column":19}},"range":[2905,2912],"raw":"`1.1.0`"},{"type":"Str","value":" 的 packageA 和 packageB 的内部逻辑冲突而导致的无法启动，使用 pnpm 之后，packageB 和 packageC 使引用的 packageA 就是隔离开的了，更新 packageC 并不会影响 packageB 中 packageA 的版本。","loc":{"start":{"line":107,"column":19},"end":{"line":107,"column":153}},"range":[2912,3046],"raw":" 的 packageA 和 packageB 的内部逻辑冲突而导致的无法启动，使用 pnpm 之后，packageB 和 packageC 使引用的 packageA 就是隔离开的了，更新 packageC 并不会影响 packageB 中 packageA 的版本。"}],"loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":153}},"range":[2893,3046],"raw":"例如项目无法启动是由于 `1.1.0` 的 packageA 和 packageB 的内部逻辑冲突而导致的无法启动，使用 pnpm 之后，packageB 和 packageC 使引用的 packageA 就是隔离开的了，更新 packageC 并不会影响 packageB 中 packageA 的版本。"},{"type":"Paragraph","children":[{"type":"Str","value":"但是，同事的项目无法启动，是由于 ","loc":{"start":{"line":109,"column":0},"end":{"line":109,"column":17}},"range":[3048,3065],"raw":"但是，同事的项目无法启动，是由于 "},{"type":"Code","value":"1.1.0","loc":{"start":{"line":109,"column":17},"end":{"line":109,"column":24}},"range":[3065,3072],"raw":"`1.1.0`"},{"type":"Str","value":" 版本的 packageA 与","loc":{"start":{"line":109,"column":24},"end":{"line":109,"column":39}},"range":[3072,3087],"raw":" 版本的 packageA 与"},{"type":"Strong","children":[{"type":"Str","value":"项目自身的脚手架不兼容","loc":{"start":{"line":109,"column":41},"end":{"line":109,"column":52}},"range":[3089,3100],"raw":"项目自身的脚手架不兼容"}],"loc":{"start":{"line":109,"column":39},"end":{"line":109,"column":54}},"range":[3087,3102],"raw":"**项目自身的脚手架不兼容**"},{"type":"Str","value":"，属于语法层面的不兼容，并不是由于 packageB 和 packageC 引用了同一份 packageA 导致的，所以用不用 pnpm 不是重点。","loc":{"start":{"line":109,"column":54},"end":{"line":109,"column":128}},"range":[3102,3176],"raw":"，属于语法层面的不兼容，并不是由于 packageB 和 packageC 引用了同一份 packageA 导致的，所以用不用 pnpm 不是重点。"}],"loc":{"start":{"line":109,"column":0},"end":{"line":109,"column":128}},"range":[3048,3176],"raw":"但是，同事的项目无法启动，是由于 `1.1.0` 版本的 packageA 与**项目自身的脚手架不兼容**，属于语法层面的不兼容，并不是由于 packageB 和 packageC 引用了同一份 packageA 导致的，所以用不用 pnpm 不是重点。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":110,"column":0}},"range":[0,3177],"raw":"---\ntitle: 'NPM 依赖更新策略引起的问题排查'\ntags: ['前端', 'NodeJS', 'NPM']\n---\n\n# NPM 依赖更新算法\n\n> 在工作中，同事遇到一个问题，和我一起研究了下：\n同事的项目里原本的 package-lock.json 将一个 NPM 包 packageA 锁定在了 1.0.1，但是在 TA 使用 npm install 来更新一个 packageC 的版本时，神奇的事情发生了，另一个包 packageA 和 TA 的项目不兼容了，项目直接跑不起来了。\n同样的代码，clone 到我的电脑上，就可以正常启动。\n> \n\n同样的代码，在一个电脑上可以启动，而另一个电脑上不能启动，那自然会联想到是环境的问题。\n\n同事 TA 使用的 NodeJS 14，npm 版本是 6.x，而我使用的 NodeJS 版本是 16，npm 版本是 8.x。\n\n即使是有 package-lock.json，使用不同版本 npm，对同一个项目的依赖进行安装时，安装到的依赖版本号是可能存在差异的，这是由于不同版本的 NPM 在 `npm install` 或者 `npm update` 时的策略是不一样的。\n\n⚠️⚠️：**不止有执行 `npm update` 时会更新依赖，在有些情况下执行 `npm install` 也会更新依赖**。\n\n# NPM 6.x 嵌套更新\n\n对于比较老的 NPM 版本，执行 `npm install` 时，npm 会根据 package.json 和 package-lock.json 文件中的依赖树，检查需要更新的依赖包。\n\n对于需要更新的依赖包，npm 会从底层（依赖树的叶子节点）开始，逐层向上更新，同时检查每一层的依赖包是否冲突，**对于冲突的包，npm 会尝试升级以解决冲突**。这个升级的过程可能会导致依赖树发生变化，从而**更新 package-lock.json**。\n\n## npm 6.x 的嵌套更新的问题\n\nNPM 6.x 的这种嵌套更新的机制，没有考虑到间接依赖的升级对项目稳定性的影响。\n\npackageB 和 packageC 均依赖 packageA：\n\n```mermaid\ngraph TD\n  pA1[packageA:^1.0.1] --> pB[packageB]\n\n\tpA1 -. up .-> pA3[packageA:1.1.0]\n\tnpm[packageA: latest is 1.1.0] -. download .-> pA3\n\tpA2 -. up .-> pA3\n\n\tpA2[packageA:^1.0.1] .-> pC[packageC]\n\n\tpB --> project\n\tpA3 .-> project\n\tpC -. install .-> project\n```\n\n- 一个项目中开始只有 packageB，package-lock.json 中**将 packageA 的版本锁定在 1.0.1 版本**。\n- 过了一段时间，packageA 的作者发布了 1.1.0 版本，虽然修订的是子版本号，但是这个包里**仍有些不可向下兼容的代码（业务开发也很难让所有人都按照规范更新版本号）。**\n- 又过了一段时间，我需要向 project 中安装一个 packageC，执行 `npm install packageC` ，虽然 packageC 和 packageB 对 packageA 的版本约束一致。\n    \n    但是**由于 npm 6.x 检测到有符合版本约束的新版本（1.1.0）包发布**，所以会下载 1.1.0 版本的包安装到项目里,并且这个 1.1.0 版本的 packageA 是 packageB 和 packageC 共同引用的，又无法向下兼容，导致项目无法启动。\n    \n\n# NPM 8.x 自适应更新策略\n\n造成这场事故的罪魁祸首，就是 NPM 6.x 嵌套更新策略，这个策略过于激进，它会更新 packageC 依赖树中所有的包（自然包括了 packageA）而导致项目不稳定。既然找到了 NPM 6.x 出问题的原因，那为什么在我的电脑上执行同样的操作就不会报错，可以正常启动呢？\n\n这个就得益于 NPM 8.x 推出的**自适应的更新策略**了，自适应的更新策略相对于 NPM 6.x 而言，其更新时影响的范围更小：\n\n- npm 8 的自适应更新算法会先尝试**更新直接依赖：**\n    - 没有冲突，则**直接更新成功**。\n    - 发现了冲突，npm 会分析冲突的原因，并尝试自动解决冲突，如果自动解决不了，则会停止更新，提供相应的错误信息和建议。\n\n由此可见，在使用 NPM 8.x，在执行 `npm install packageC` 操作时，会首先尝试直接安装 packageC，对于 packageC 依赖树上项目里原本就存在的包，在**不冲突时采用项目中的版本。**自然也就不会更新 packageA 了。\n\n# 问题的解决方案\n\n分析清楚了问题发生的条件和原因，解决方案就很明确了，这里列出三种解决方案：\n\n## 方案一：升级 NPM 版本到 8.x\n\n升级 NodeJS 和 NPM 版本肯定是最优雅的解决方案\n\n优点：不需要对项目进行任何的修改就可以解决问题\n\n缺点：本地的 NodeJS 环境自然是好升级的，CI/CD 上的 NodeJS 和 NPM 版本升级起来就要考虑很多了，它是公司所有项目发布都需要经过的流程，如果影响到其他的工程打包，或者埋下了暗坑，又是一场惨痛的事故。\n\n## 方案二：手动修改 package-lock.json 中 packageA 的版本\n\n手动修改 package-lock.json 里 packageA 的版本为 1.0.1。\n\n优点：既然选择升级 NodeJS 和 NPM 的成本很高，那我修改 package-lock.json 里 packageA 的版本，就不会影响别的项目了。\n\n缺点：治标不治本，解决得不持久，如果下次再升级 packageC 或者安装依赖了 packageA 的包，那同样的问题又会再次出现。\n\n## 方案三：在项目的 package.json 里将 packageA 作为直接依赖，并约束版本号\n\n修改项目 package.json ，在 dependencies 里增加\n\n```json\n{\n\t\"packageA\": \"~1.0.1\"\n}\n```\n\n只接受修订版本号更新，这样 NPM 6.x 就不会下载 packageA 的 `1.1.0` 版本了。\n\n这三种方案都可以解决问题，但是不推荐使用第二种方案，这种方案会降低项目的稳定性，下次换个人又会一脸蒙圈了。\n\n至于方案一和方案三，就结合实际情况选择即可。\n\n## 方案零：使用 PNPM\n\n这种方案适用于包与包之间的不兼容导致的项目报错：\n\n例如项目无法启动是由于 `1.1.0` 的 packageA 和 packageB 的内部逻辑冲突而导致的无法启动，使用 pnpm 之后，packageB 和 packageC 使引用的 packageA 就是隔离开的了，更新 packageC 并不会影响 packageB 中 packageA 的版本。\n\n但是，同事的项目无法启动，是由于 `1.1.0` 版本的 packageA 与**项目自身的脚手架不兼容**，属于语法层面的不兼容，并不是由于 packageB 和 packageC 引用了同一份 packageA 导致的，所以用不用 pnpm 不是重点。\n"},"catalogue":{"title":"NPM 依赖更新策略引起的问题排查","json-path":"前端开发/前端工程化/2023-02-18-NPM 依赖更新策略引起的问题排查.json","mdate":"2023-02-18","cover":"https://i.328888.xyz/2023/01/01/tZa8k.jpeg","icon":"🦉","visible":true,"tags":["前端","NodeJS","NPM"]}}