{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '散列表'\ntags: ['数据结构','散列表','查找']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,46],"raw":"---\ntitle: '散列表'\ntags: ['数据结构','散列表','查找']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"散列表","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":5}},"range":[49,52],"raw":"散列表"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":5}},"range":[47,52],"raw":"# 散列表"},{"type":"Paragraph","children":[{"type":"Str","value":"散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。","loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":45}},"range":[54,99],"raw":"散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":45}},"range":[54,99],"raw":"散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"1. 散列函数","loc":{"start":{"line":9,"column":3},"end":{"line":9,"column":10}},"range":[104,111],"raw":"1. 散列函数"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":10}},"range":[101,111],"raw":"## 1. 散列函数"},{"type":"Paragraph","children":[{"type":"Str","value":"散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。","loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":30}},"range":[113,143],"raw":"散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":30}},"range":[113,143],"raw":"散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"1.1 散列函数的要求","loc":{"start":{"line":13,"column":4},"end":{"line":13,"column":15}},"range":[149,160],"raw":"1.1 散列函数的要求"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":15}},"range":[145,160],"raw":"### 1.1 散列函数的要求"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。","loc":{"start":{"line":15,"column":3},"end":{"line":15,"column":48}},"range":[165,210],"raw":"散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。"}],"loc":{"start":{"line":15,"column":3},"end":{"line":15,"column":48}},"range":[165,210],"raw":"散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":48}},"range":[162,210],"raw":"1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。","loc":{"start":{"line":16,"column":3},"end":{"line":16,"column":44}},"range":[214,255],"raw":"散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。"}],"loc":{"start":{"line":16,"column":3},"end":{"line":16,"column":44}},"range":[214,255],"raw":"散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":44}},"range":[211,255],"raw":"2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址","loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":36}},"range":[259,292],"raw":"散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址"}],"loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":36}},"range":[259,292],"raw":"散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":36}},"range":[256,292],"raw":"3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址"}],"loc":{"start":{"line":15,"column":0},"end":{"line":17,"column":36}},"range":[162,292],"raw":"1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。\n3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"1.2 散列函数的构造方法","loc":{"start":{"line":19,"column":4},"end":{"line":19,"column":17}},"range":[298,311],"raw":"1.2 散列函数的构造方法"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":17}},"range":[294,311],"raw":"### 1.2 散列函数的构造方法"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.1 直接定址法","loc":{"start":{"line":21,"column":5},"end":{"line":21,"column":16}},"range":[318,329],"raw":"1.2.1 直接定址法"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":16}},"range":[313,329],"raw":"#### 1.2.1 直接定址法"},{"type":"Paragraph","children":[{"type":"Str","value":"直接取关键字的某个线性函数的散列地址","loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":18}},"range":[331,349],"raw":"直接取关键字的某个线性函数的散列地址"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":18}},"range":[331,349],"raw":"直接取关键字的某个线性函数的散列地址"},{"type":"Paragraph","children":[{"type":"Str","value":"优点：","loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":3}},"range":[351,354],"raw":"优点："}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":3}},"range":[351,354],"raw":"优点："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"方法简单，不会产生冲突","loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":13}},"range":[358,369],"raw":"方法简单，不会产生冲突"}],"loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":13}},"range":[358,369],"raw":"方法简单，不会产生冲突"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":13}},"range":[356,369],"raw":"- 方法简单，不会产生冲突"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":13}},"range":[356,369],"raw":"- 方法简单，不会产生冲突"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：","loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":3}},"range":[371,374],"raw":"缺点："}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":3}},"range":[371,374],"raw":"缺点："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"关键字分布不连续的时候会浪费空间","loc":{"start":{"line":31,"column":2},"end":{"line":31,"column":18}},"range":[378,394],"raw":"关键字分布不连续的时候会浪费空间"}],"loc":{"start":{"line":31,"column":2},"end":{"line":31,"column":18}},"range":[378,394],"raw":"关键字分布不连续的时候会浪费空间"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":18}},"range":[376,394],"raw":"- 关键字分布不连续的时候会浪费空间"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":18}},"range":[376,394],"raw":"- 关键字分布不连续的时候会浪费空间"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.2 除留取余法","loc":{"start":{"line":33,"column":5},"end":{"line":33,"column":16}},"range":[401,412],"raw":"1.2.2 除留取余法"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":16}},"range":[396,412],"raw":"#### 1.2.2 除留取余法"},{"type":"Paragraph","children":[{"type":"Str","value":"$Hash(key)=key%p$，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。","loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":56}},"range":[414,470],"raw":"$Hash(key)=key\\%p$，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。"}],"loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":56}},"range":[414,470],"raw":"$Hash(key)=key\\%p$，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.3 数字分析法","loc":{"start":{"line":37,"column":5},"end":{"line":37,"column":16}},"range":[477,488],"raw":"1.2.3 数字分析法"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":16}},"range":[472,488],"raw":"#### 1.2.3 数字分析法"},{"type":"Paragraph","children":[{"type":"Str","value":"选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":60}},"range":[490,550],"raw":"选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":60}},"range":[490,550],"raw":"选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.4 平方取中法","loc":{"start":{"line":41,"column":5},"end":{"line":41,"column":16}},"range":[557,568],"raw":"1.2.4 平方取中法"}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":16}},"range":[552,568],"raw":"#### 1.2.4 平方取中法"},{"type":"Paragraph","children":[{"type":"Str","value":"取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。","loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":50}},"range":[570,620],"raw":"取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":50}},"range":[570,620],"raw":"取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"1.2.5 折叠法","loc":{"start":{"line":45,"column":5},"end":{"line":45,"column":14}},"range":[627,636],"raw":"1.2.5 折叠法"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":14}},"range":[622,636],"raw":"#### 1.2.5 折叠法"},{"type":"Paragraph","children":[{"type":"Str","value":"将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":36}},"range":[638,674],"raw":"将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。"}],"loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":36}},"range":[638,674],"raw":"将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于关键字的位数多，且关键字每位数分布均匀的情况。","loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":26}},"range":[676,702],"raw":"适用于关键字的位数多，且关键字每位数分布均匀的情况。"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":26}},"range":[676,702],"raw":"适用于关键字的位数多，且关键字每位数分布均匀的情况。"},{"type":"HorizontalRule","loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":5}},"range":[704,709],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"2. 冲突","loc":{"start":{"line":53,"column":3},"end":{"line":53,"column":8}},"range":[714,719],"raw":"2. 冲突"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":8}},"range":[711,719],"raw":"## 2. 冲突"},{"type":"Paragraph","children":[{"type":"Str","value":"冲突：散列函数可能存在把多个值映射到同一个地址的可能。","loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":27}},"range":[721,748],"raw":"冲突：散列函数可能存在把多个值映射到同一个地址的可能。"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":27}},"range":[721,748],"raw":"冲突：散列函数可能存在把多个值映射到同一个地址的可能。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"2.1 开放定址法","loc":{"start":{"line":57,"column":4},"end":{"line":57,"column":13}},"range":[754,763],"raw":"2.1 开放定址法"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":13}},"range":[750,763],"raw":"### 2.1 开放定址法"},{"type":"Paragraph","children":[{"type":"Str","value":"可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。","loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":34}},"range":[765,799],"raw":"可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。"}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":34}},"range":[765,799],"raw":"可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。"},{"type":"Paragraph","children":[{"type":"Str","value":"$H_{i}=(H(key)+d_{i})%m,i=0,1,2,...,k(k \\leq m-1)$; m为散列表表长，$d_{i}$为增量序列。","loc":{"start":{"line":61,"column":0},"end":{"line":61,"column":74}},"range":[801,875],"raw":"$H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)$; m为散列表表长，$d_{i}$为增量序列。"}],"loc":{"start":{"line":61,"column":0},"end":{"line":61,"column":74}},"range":[801,875],"raw":"$H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)$; m为散列表表长，$d_{i}$为增量序列。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"2.1.1 增量序列的计算方法","loc":{"start":{"line":63,"column":5},"end":{"line":63,"column":20}},"range":[882,897],"raw":"2.1.1 增量序列的计算方法"}],"loc":{"start":{"line":63,"column":0},"end":{"line":63,"column":20}},"range":[877,897],"raw":"#### 2.1.1 增量序列的计算方法"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.1 线性探查法","loc":{"start":{"line":65,"column":6},"end":{"line":65,"column":19}},"range":[905,918],"raw":"2.1.1.1 线性探查法"}],"loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":19}},"range":[899,918],"raw":"##### 2.1.1.1 线性探查法"},{"type":"Paragraph","children":[{"type":"Str","value":"$d_{i} = 0,1,2,3,...,m-1$","loc":{"start":{"line":67,"column":0},"end":{"line":67,"column":25}},"range":[920,945],"raw":"$d_{i} = 0,1,2,3,...,m-1$"}],"loc":{"start":{"line":67,"column":0},"end":{"line":67,"column":25}},"range":[920,945],"raw":"$d_{i} = 0,1,2,3,...,m-1$"},{"type":"Paragraph","children":[{"type":"Str","value":"存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。","loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":48}},"range":[947,995],"raw":"存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。"}],"loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":48}},"range":[947,995],"raw":"存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。"},{"type":"Paragraph","children":[{"type":"Str","value":"查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。","loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":83}},"range":[997,1080],"raw":"查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。"}],"loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":83}},"range":[997,1080],"raw":"查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。"},{"type":"Header","depth":6,"children":[{"type":"Str","value":"缺点","loc":{"start":{"line":73,"column":7},"end":{"line":73,"column":9}},"range":[1089,1091],"raw":"缺点"}],"loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":9}},"range":[1082,1091],"raw":"###### 缺点"},{"type":"Paragraph","children":[{"type":"Str","value":"存在堆积现象，大大降低查找效率","loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":15}},"range":[1093,1108],"raw":"存在堆积现象，大大降低查找效率"}],"loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":15}},"range":[1093,1108],"raw":"存在堆积现象，大大降低查找效率"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.2 平方探测法","loc":{"start":{"line":77,"column":6},"end":{"line":77,"column":19}},"range":[1116,1129],"raw":"2.1.1.2 平方探测法"}],"loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":19}},"range":[1110,1129],"raw":"##### 2.1.1.2 平方探测法"},{"type":"Paragraph","children":[{"type":"Str","value":"$d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$，其中$k \\leq m/2$","loc":{"start":{"line":79,"column":0},"end":{"line":79,"column":77}},"range":[1131,1208],"raw":"$d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$，其中$k \\leq m/2$"}],"loc":{"start":{"line":79,"column":0},"end":{"line":79,"column":77}},"range":[1131,1208],"raw":"$d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$，其中$k \\leq m/2$"},{"type":"Paragraph","children":[{"type":"Str","value":"可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）","loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":39}},"range":[1210,1249],"raw":"可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）"}],"loc":{"start":{"line":81,"column":0},"end":{"line":81,"column":39}},"range":[1210,1249],"raw":"可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.3 再散列法","loc":{"start":{"line":83,"column":6},"end":{"line":83,"column":18}},"range":[1257,1269],"raw":"2.1.1.3 再散列法"}],"loc":{"start":{"line":83,"column":0},"end":{"line":83,"column":18}},"range":[1251,1269],"raw":"##### 2.1.1.3 再散列法"},{"type":"Paragraph","children":[{"type":"Str","value":"$d_{i}=i*Hash2(key)$","loc":{"start":{"line":85,"column":0},"end":{"line":85,"column":20}},"range":[1271,1291],"raw":"$d_{i}=i*Hash2(key)$"}],"loc":{"start":{"line":85,"column":0},"end":{"line":85,"column":20}},"range":[1271,1291],"raw":"$d_{i}=i*Hash2(key)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"2.1.1.4 伪随机序列法","loc":{"start":{"line":87,"column":6},"end":{"line":87,"column":20}},"range":[1299,1313],"raw":"2.1.1.4 伪随机序列法"}],"loc":{"start":{"line":87,"column":0},"end":{"line":87,"column":20}},"range":[1293,1313],"raw":"##### 2.1.1.4 伪随机序列法"},{"type":"Paragraph","children":[{"type":"Str","value":"$d_{i}=伪随机序列$","loc":{"start":{"line":89,"column":0},"end":{"line":89,"column":13}},"range":[1315,1328],"raw":"$d_{i}=伪随机序列$"}],"loc":{"start":{"line":89,"column":0},"end":{"line":89,"column":13}},"range":[1315,1328],"raw":"$d_{i}=伪随机序列$"},{"type":"Paragraph","children":[{"type":"Html","value":"<font color=\"red\">","loc":{"start":{"line":91,"column":0},"end":{"line":91,"column":18}},"range":[1330,1348],"raw":"<font color=\"red\">"},{"type":"Str","value":"开放定址法不能随意删除表项，否则可能造成其他表项查找失败。","loc":{"start":{"line":91,"column":18},"end":{"line":91,"column":47}},"range":[1348,1377],"raw":"开放定址法不能随意删除表项，否则可能造成其他表项查找失败。"},{"type":"Html","value":"</font>","loc":{"start":{"line":91,"column":47},"end":{"line":91,"column":54}},"range":[1377,1384],"raw":"</font>"}],"loc":{"start":{"line":91,"column":0},"end":{"line":91,"column":54}},"range":[1330,1384],"raw":"<font color=\"red\">开放定址法不能随意删除表项，否则可能造成其他表项查找失败。</font>"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"2.2 拉链法","loc":{"start":{"line":93,"column":4},"end":{"line":93,"column":11}},"range":[1390,1397],"raw":"2.2 拉链法"}],"loc":{"start":{"line":93,"column":0},"end":{"line":93,"column":11}},"range":[1386,1397],"raw":"### 2.2 拉链法"},{"type":"Paragraph","children":[{"type":"Str","value":"把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。","loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":51}},"range":[1399,1450],"raw":"把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。"}],"loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":51}},"range":[1399,1450],"raw":"把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于经常插入和删除的情况，会增加指针域，占用空间。","loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":26}},"range":[1452,1478],"raw":"适用于经常插入和删除的情况，会增加指针域，占用空间。"}],"loc":{"start":{"line":97,"column":0},"end":{"line":97,"column":26}},"range":[1452,1478],"raw":"适用于经常插入和删除的情况，会增加指针域，占用空间。"},{"type":"HorizontalRule","loc":{"start":{"line":99,"column":0},"end":{"line":99,"column":5}},"range":[1480,1485],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"3 查找","loc":{"start":{"line":101,"column":3},"end":{"line":101,"column":7}},"range":[1490,1494],"raw":"3 查找"}],"loc":{"start":{"line":101,"column":0},"end":{"line":101,"column":7}},"range":[1487,1494],"raw":"## 3 查找"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"3.1 查找效率","loc":{"start":{"line":103,"column":4},"end":{"line":103,"column":12}},"range":[1500,1508],"raw":"3.1 查找效率"}],"loc":{"start":{"line":103,"column":0},"end":{"line":103,"column":12}},"range":[1496,1508],"raw":"### 3.1 查找效率"},{"type":"Paragraph","children":[{"type":"Str","value":"与散列函数、处理冲突和填装因子有关","loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":17}},"range":[1510,1527],"raw":"与散列函数、处理冲突和填装因子有关"}],"loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":17}},"range":[1510,1527],"raw":"与散列函数、处理冲突和填装因子有关"},{"type":"Paragraph","children":[{"type":"Str","value":"填装因子$\\alpha = \\frac{表中记录数n}{散列表长度m}$","loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":36}},"range":[1529,1565],"raw":"填装因子$\\alpha = \\frac{表中记录数n}{散列表长度m}$"}],"loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":36}},"range":[1529,1565],"raw":"填装因子$\\alpha = \\frac{表中记录数n}{散列表长度m}$"}],"loc":{"start":{"line":1,"column":0},"end":{"line":108,"column":0}},"range":[0,1566],"raw":"---\ntitle: '散列表'\ntags: ['数据结构','散列表','查找']\n---\n# 散列表\n\n散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。\n\n## 1. 散列函数\n\n散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。\n\n### 1.1 散列函数的要求\n\n1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。\n3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址\n\n### 1.2 散列函数的构造方法\n\n#### 1.2.1 直接定址法\n\n直接取关键字的某个线性函数的散列地址\n\n优点：\n\n- 方法简单，不会产生冲突\n\n缺点：\n\n- 关键字分布不连续的时候会浪费空间\n\n#### 1.2.2 除留取余法\n\n$Hash(key)=key\\%p$，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。\n\n#### 1.2.3 数字分析法\n\n选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。\n\n#### 1.2.4 平方取中法\n\n取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。\n\n#### 1.2.5 折叠法\n\n将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。\n\n适用于关键字的位数多，且关键字每位数分布均匀的情况。\n\n*****\n\n## 2. 冲突\n\n冲突：散列函数可能存在把多个值映射到同一个地址的可能。\n\n### 2.1 开放定址法\n\n可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。\n\n$H_{i}=(H(key)+d_{i})\\%m,i=0,1,2,...,k(k \\leq m-1)$; m为散列表表长，$d_{i}$为增量序列。\n\n#### 2.1.1 增量序列的计算方法\n\n##### 2.1.1.1 线性探查法\n\n$d_{i} = 0,1,2,3,...,m-1$\n\n存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。\n\n查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。\n\n###### 缺点\n\n存在堆积现象，大大降低查找效率\n\n##### 2.1.1.2 平方探测法\n\n$d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$，其中$k \\leq m/2$\n\n可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）\n\n##### 2.1.1.3 再散列法\n\n$d_{i}=i*Hash2(key)$\n\n##### 2.1.1.4 伪随机序列法\n\n$d_{i}=伪随机序列$\n\n<font color=\"red\">开放定址法不能随意删除表项，否则可能造成其他表项查找失败。</font>\n\n### 2.2 拉链法\n\n把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。\n\n适用于经常插入和删除的情况，会增加指针域，占用空间。\n\n*****\n\n## 3 查找\n\n### 3.1 查找效率\n\n与散列函数、处理冲突和填装因子有关\n\n填装因子$\\alpha = \\frac{表中记录数n}{散列表长度m}$\n"},"catalogue":{"title":"散列表","json-path":"2020-08-08-散列表.json","mdate":"2022-08-30T17:05:29.124Z","tags":["数据结构","散列表","查找"]}}