{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '内存分配与回收'\ntags: ['操作系统','内存']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,44],"raw":"---\ntitle: '内存分配与回收'\ntags: ['操作系统','内存']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"内存分配与回收","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":9}},"range":[47,54],"raw":"内存分配与回收"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":9}},"range":[45,54],"raw":"# 内存分配与回收"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"连续分配","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":7}},"range":[59,63],"raw":"连续分配"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":7}},"range":[56,63],"raw":"## 连续分配"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"单一连续分配","loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":10}},"range":[69,75],"raw":"单一连续分配"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":10}},"range":[65,75],"raw":"### 单一连续分配"},{"type":"Paragraph","children":[{"type":"Str","value":"内存分为“系统区”和“用户区”，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。 用户区存放用户进程相关的数据，","loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":62}},"range":[77,139],"raw":"内存分为“系统区”和“用户区”，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。 用户区存放用户进程相关的数据，"},{"type":"Strong","children":[{"type":"Str","value":"内存中只有一道用户程序","loc":{"start":{"line":11,"column":64},"end":{"line":11,"column":75}},"range":[141,152],"raw":"内存中只有一道用户程序"}],"loc":{"start":{"line":11,"column":62},"end":{"line":11,"column":77}},"range":[139,154],"raw":"**内存中只有一道用户程序**"},{"type":"Str","value":"，用户程序独占整个用户区。","loc":{"start":{"line":11,"column":77},"end":{"line":11,"column":90}},"range":[154,167],"raw":"，用户程序独占整个用户区。"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":90}},"range":[77,167],"raw":"内存分为“系统区”和“用户区”，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。 用户区存放用户进程相关的数据，**内存中只有一道用户程序**，用户程序独占整个用户区。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":38}},"range":[171,207],"raw":"优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":38}},"range":[171,207],"raw":"优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":38}},"range":[169,207],"raw":"- 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。","loc":{"start":{"line":14,"column":2},"end":{"line":14,"column":60}},"range":[210,268],"raw":"缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。"}],"loc":{"start":{"line":14,"column":2},"end":{"line":14,"column":60}},"range":[210,268],"raw":"缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":60}},"range":[208,268],"raw":"- 缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。"}],"loc":{"start":{"line":13,"column":0},"end":{"line":14,"column":60}},"range":[169,268],"raw":"- 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护\n- 缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。"},{"type":"HorizontalRule","loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":5}},"range":[270,275],"raw":"*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"固定分区分配","loc":{"start":{"line":18,"column":4},"end":{"line":18,"column":10}},"range":[281,287],"raw":"固定分区分配"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":10}},"range":[277,287],"raw":"### 固定分区分配"},{"type":"Paragraph","children":[{"type":"Str","value":"为了可以在内存中装入多道程序，而且这些程序不会相互干扰，将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，就形成了最早的、最简单的一种可运行多道程序的内存管理方式。","loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":92}},"range":[289,381],"raw":"为了可以在内存中装入多道程序，而且这些程序不会相互干扰，将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，就形成了最早的、最简单的一种可运行多道程序的内存管理方式。"}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":92}},"range":[289,381],"raw":"为了可以在内存中装入多道程序，而且这些程序不会相互干扰，将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，就形成了最早的、最简单的一种可运行多道程序的内存管理方式。"},{"type":"Paragraph","children":[{"type":"Str","value":"分区说明表：","loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":6}},"range":[383,389],"raw":"分区说明表："}],"loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":6}},"range":[383,389],"raw":"分区说明表："},{"type":"Paragraph","children":[{"type":"Str","value":"操作系统维护和更新一个分区说明表，实现对各个分区的分配和回收","loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":30}},"range":[391,421],"raw":"操作系统维护和更新一个分区说明表，实现对各个分区的分配和回收"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":30}},"range":[391,421],"raw":"操作系统维护和更新一个分区说明表，实现对各个分区的分配和回收"},{"type":"Table","align":[null,null,null,null],"children":[{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"分区号","loc":{"start":{"line":26,"column":2},"end":{"line":26,"column":5}},"range":[425,428],"raw":"分区号"}],"loc":{"start":{"line":26,"column":0},"end":{"line":26,"column":7}},"range":[423,430],"raw":"| 分区号 |"},{"type":"TableCell","children":[{"type":"Str","value":"大小","loc":{"start":{"line":26,"column":8},"end":{"line":26,"column":10}},"range":[431,433],"raw":"大小"}],"loc":{"start":{"line":26,"column":7},"end":{"line":26,"column":12}},"range":[430,435],"raw":" 大小 |"},{"type":"TableCell","children":[{"type":"Str","value":"起始地址","loc":{"start":{"line":26,"column":13},"end":{"line":26,"column":17}},"range":[436,440],"raw":"起始地址"}],"loc":{"start":{"line":26,"column":12},"end":{"line":26,"column":19}},"range":[435,442],"raw":" 起始地址 |"},{"type":"TableCell","children":[{"type":"Str","value":"状态","loc":{"start":{"line":26,"column":20},"end":{"line":26,"column":22}},"range":[443,445],"raw":"状态"}],"loc":{"start":{"line":26,"column":19},"end":{"line":26,"column":26}},"range":[442,449],"raw":" 状态   |"}],"loc":{"start":{"line":26,"column":0},"end":{"line":26,"column":26}},"range":[423,449],"raw":"| 分区号 | 大小 | 起始地址 | 状态   |"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"1","loc":{"start":{"line":28,"column":2},"end":{"line":28,"column":3}},"range":[490,491],"raw":"1"}],"loc":{"start":{"line":28,"column":0},"end":{"line":28,"column":10}},"range":[488,498],"raw":"| 1      |"},{"type":"TableCell","children":[{"type":"Str","value":"2","loc":{"start":{"line":28,"column":11},"end":{"line":28,"column":12}},"range":[499,500],"raw":"2"}],"loc":{"start":{"line":28,"column":10},"end":{"line":28,"column":17}},"range":[498,505],"raw":" 2    |"},{"type":"TableCell","children":[{"type":"Str","value":"8","loc":{"start":{"line":28,"column":18},"end":{"line":28,"column":19}},"range":[506,507],"raw":"8"}],"loc":{"start":{"line":28,"column":17},"end":{"line":28,"column":28}},"range":[505,516],"raw":" 8        |"},{"type":"TableCell","children":[{"type":"Str","value":"未分配","loc":{"start":{"line":28,"column":29},"end":{"line":28,"column":32}},"range":[517,520],"raw":"未分配"}],"loc":{"start":{"line":28,"column":28},"end":{"line":28,"column":34}},"range":[516,522],"raw":" 未分配 |"}],"loc":{"start":{"line":28,"column":0},"end":{"line":28,"column":34}},"range":[488,522],"raw":"| 1      | 2    | 8        | 未分配 |"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"2","loc":{"start":{"line":29,"column":2},"end":{"line":29,"column":3}},"range":[525,526],"raw":"2"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":10}},"range":[523,533],"raw":"| 2      |"},{"type":"TableCell","children":[{"type":"Str","value":"2","loc":{"start":{"line":29,"column":11},"end":{"line":29,"column":12}},"range":[534,535],"raw":"2"}],"loc":{"start":{"line":29,"column":10},"end":{"line":29,"column":17}},"range":[533,540],"raw":" 2    |"},{"type":"TableCell","children":[{"type":"Str","value":"10","loc":{"start":{"line":29,"column":18},"end":{"line":29,"column":20}},"range":[541,543],"raw":"10"}],"loc":{"start":{"line":29,"column":17},"end":{"line":29,"column":28}},"range":[540,551],"raw":" 10       |"},{"type":"TableCell","children":[{"type":"Str","value":"未分配","loc":{"start":{"line":29,"column":29},"end":{"line":29,"column":32}},"range":[552,555],"raw":"未分配"}],"loc":{"start":{"line":29,"column":28},"end":{"line":29,"column":34}},"range":[551,557],"raw":" 未分配 |"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":34}},"range":[523,557],"raw":"| 2      | 2    | 10       | 未分配 |"}],"loc":{"start":{"line":26,"column":0},"end":{"line":29,"column":34}},"range":[423,557],"raw":"| 分区号 | 大小 | 起始地址 | 状态   |\n| ------ | ---- | -------- | ------ |\n| 1      | 2    | 8        | 未分配 |\n| 2      | 2    | 10       | 未分配 |"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：会产生内部碎片","loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":10}},"range":[559,569],"raw":"缺点：会产生内部碎片"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":10}},"range":[559,569],"raw":"缺点：会产生内部碎片"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"分区大小相等","loc":{"start":{"line":33,"column":5},"end":{"line":33,"column":11}},"range":[576,582],"raw":"分区大小相等"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":11}},"range":[571,582],"raw":"#### 分区大小相等"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"缺点：缺乏灵活性","loc":{"start":{"line":35,"column":2},"end":{"line":35,"column":10}},"range":[586,594],"raw":"缺点：缺乏灵活性"}],"loc":{"start":{"line":35,"column":2},"end":{"line":35,"column":10}},"range":[586,594],"raw":"缺点：缺乏灵活性"}],"loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":10}},"range":[584,594],"raw":"- 缺点：缺乏灵活性"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"优点：适用于一台计算机","loc":{"start":{"line":36,"column":2},"end":{"line":36,"column":13}},"range":[597,608],"raw":"优点：适用于一台计算机"},{"type":"Strong","children":[{"type":"Str","value":"控制多个相同的对象","loc":{"start":{"line":36,"column":15},"end":{"line":36,"column":24}},"range":[610,619],"raw":"控制多个相同的对象"}],"loc":{"start":{"line":36,"column":13},"end":{"line":36,"column":26}},"range":[608,621],"raw":"**控制多个相同的对象**"},{"type":"Str","value":"的场合","loc":{"start":{"line":36,"column":26},"end":{"line":36,"column":29}},"range":[621,624],"raw":"的场合"}],"loc":{"start":{"line":36,"column":2},"end":{"line":36,"column":29}},"range":[597,624],"raw":"优点：适用于一台计算机**控制多个相同的对象**的场合"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":29}},"range":[595,624],"raw":"- 优点：适用于一台计算机**控制多个相同的对象**的场合"}],"loc":{"start":{"line":35,"column":0},"end":{"line":36,"column":29}},"range":[584,624],"raw":"- 缺点：缺乏灵活性\n- 优点：适用于一台计算机**控制多个相同的对象**的场合"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"分区大小不等","loc":{"start":{"line":38,"column":5},"end":{"line":38,"column":11}},"range":[631,637],"raw":"分区大小不等"}],"loc":{"start":{"line":38,"column":0},"end":{"line":38,"column":11}},"range":[626,637],"raw":"#### 分区大小不等"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"优点：增加了灵活性，可以满足不同大小的进程需求","loc":{"start":{"line":40,"column":2},"end":{"line":40,"column":25}},"range":[641,664],"raw":"优点：增加了灵活性，可以满足不同大小的进程需求"}],"loc":{"start":{"line":40,"column":2},"end":{"line":40,"column":25}},"range":[641,664],"raw":"优点：增加了灵活性，可以满足不同大小的进程需求"}],"loc":{"start":{"line":40,"column":0},"end":{"line":40,"column":25}},"range":[639,664],"raw":"- 优点：增加了灵活性，可以满足不同大小的进程需求"}],"loc":{"start":{"line":40,"column":0},"end":{"line":40,"column":25}},"range":[639,664],"raw":"- 优点：增加了灵活性，可以满足不同大小的进程需求"},{"type":"HorizontalRule","loc":{"start":{"line":42,"column":0},"end":{"line":42,"column":5}},"range":[666,671],"raw":"*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"动态分区分配","loc":{"start":{"line":44,"column":4},"end":{"line":44,"column":10}},"range":[677,683],"raw":"动态分区分配"}],"loc":{"start":{"line":44,"column":0},"end":{"line":44,"column":10}},"range":[673,683],"raw":"### 动态分区分配"},{"type":"Paragraph","children":[{"type":"Str","value":"可变分区分配，不会预先划分内存分区，而是在进程装入内存时，","loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":29}},"range":[685,714],"raw":"可变分区分配，不会预先划分内存分区，而是在进程装入内存时，"},{"type":"Strong","children":[{"type":"Str","value":"根据进程的大小动态建立分区","loc":{"start":{"line":46,"column":31},"end":{"line":46,"column":44}},"range":[716,729],"raw":"根据进程的大小动态建立分区"}],"loc":{"start":{"line":46,"column":29},"end":{"line":46,"column":46}},"range":[714,731],"raw":"**根据进程的大小动态建立分区**"},{"type":"Str","value":"，使分区的大小正好满足进程的需要。","loc":{"start":{"line":46,"column":46},"end":{"line":46,"column":63}},"range":[731,748],"raw":"，使分区的大小正好满足进程的需要。"}],"loc":{"start":{"line":46,"column":0},"end":{"line":46,"column":63}},"range":[685,748],"raw":"可变分区分配，不会预先划分内存分区，而是在进程装入内存时，**根据进程的大小动态建立分区**，使分区的大小正好满足进程的需要。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"缺点：动态分区分配没有内部碎片,但是有外部碎片。","loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":26}},"range":[752,776],"raw":"缺点：动态分区分配没有内部碎片,但是有外部碎片。"}],"loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":26}},"range":[752,776],"raw":"缺点：动态分区分配没有内部碎片,但是有外部碎片。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"内部碎片：分配给某进程的内存区域中,如果有些部分没有用上","loc":{"start":{"line":49,"column":4},"end":{"line":49,"column":32}},"range":[781,809],"raw":"内部碎片：分配给某进程的内存区域中,如果有些部分没有用上"}],"loc":{"start":{"line":49,"column":4},"end":{"line":49,"column":32}},"range":[781,809],"raw":"内部碎片：分配给某进程的内存区域中,如果有些部分没有用上"}],"loc":{"start":{"line":49,"column":2},"end":{"line":49,"column":32}},"range":[779,809],"raw":"- 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"外部碎片：是指内存中的某些空闲分区由于太小而难以利用。","loc":{"start":{"line":50,"column":4},"end":{"line":50,"column":31}},"range":[814,841],"raw":"外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"}],"loc":{"start":{"line":50,"column":4},"end":{"line":50,"column":31}},"range":[814,841],"raw":"外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"}],"loc":{"start":{"line":50,"column":2},"end":{"line":50,"column":31}},"range":[812,841],"raw":"- 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"}],"loc":{"start":{"line":49,"column":2},"end":{"line":50,"column":31}},"range":[779,841],"raw":"- 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上\n  - 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"}],"loc":{"start":{"line":48,"column":0},"end":{"line":50,"column":31}},"range":[750,841],"raw":"- 缺点：动态分区分配没有内部碎片,但是有外部碎片。\n  - 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上\n  - 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"}],"loc":{"start":{"line":48,"column":0},"end":{"line":50,"column":31}},"range":[750,841],"raw":"- 缺点：动态分区分配没有内部碎片,但是有外部碎片。\n  - 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上\n  - 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"记录内存的使用情况","loc":{"start":{"line":52,"column":5},"end":{"line":52,"column":14}},"range":[848,857],"raw":"记录内存的使用情况"}],"loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":14}},"range":[843,857],"raw":"#### 记录内存的使用情况"},{"type":"List","ordered":false,"start":null,"spread":true,"children":[{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"空闲分区表","loc":{"start":{"line":54,"column":2},"end":{"line":54,"column":7}},"range":[861,866],"raw":"空闲分区表"}],"loc":{"start":{"line":54,"column":2},"end":{"line":54,"column":7}},"range":[861,866],"raw":"空闲分区表"},{"type":"Paragraph","children":[{"type":"Str","value":"每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息","loc":{"start":{"line":56,"column":2},"end":{"line":56,"column":37}},"range":[870,905],"raw":"每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息"}],"loc":{"start":{"line":56,"column":2},"end":{"line":56,"column":37}},"range":[870,905],"raw":"每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息"}],"loc":{"start":{"line":54,"column":0},"end":{"line":56,"column":37}},"range":[859,905],"raw":"- 空闲分区表\n\n  每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息"},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"空闲分区链","loc":{"start":{"line":58,"column":2},"end":{"line":58,"column":7}},"range":[909,914],"raw":"空闲分区链"}],"loc":{"start":{"line":58,"column":2},"end":{"line":58,"column":7}},"range":[909,914],"raw":"空闲分区链"},{"type":"Paragraph","children":[{"type":"Str","value":"每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息","loc":{"start":{"line":60,"column":2},"end":{"line":60,"column":46}},"range":[918,962],"raw":"每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息"}],"loc":{"start":{"line":60,"column":2},"end":{"line":60,"column":46}},"range":[918,962],"raw":"每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息"}],"loc":{"start":{"line":58,"column":0},"end":{"line":60,"column":46}},"range":[907,962],"raw":"- 空闲分区链\n\n  每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息"}],"loc":{"start":{"line":54,"column":0},"end":{"line":60,"column":46}},"range":[859,962],"raw":"- 空闲分区表\n\n  每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息\n\n- 空闲分区链\n\n  每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息"},{"type":"HorizontalRule","loc":{"start":{"line":62,"column":0},"end":{"line":62,"column":5}},"range":[964,969],"raw":"*****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"空闲分区的分配","loc":{"start":{"line":64,"column":5},"end":{"line":64,"column":12}},"range":[976,983],"raw":"空闲分区的分配"}],"loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":12}},"range":[971,983],"raw":"#### 空闲分区的分配"},{"type":"Paragraph","children":[{"type":"Str","value":"把一个新作业装入内存时,须按照一定的","loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":18}},"range":[985,1003],"raw":"把一个新作业装入内存时,须按照一定的"},{"type":"Strong","children":[{"type":"Str","value":"动态分区分配算法","loc":{"start":{"line":66,"column":20},"end":{"line":66,"column":28}},"range":[1005,1013],"raw":"动态分区分配算法"}],"loc":{"start":{"line":66,"column":18},"end":{"line":66,"column":30}},"range":[1003,1015],"raw":"**动态分区分配算法**"},{"type":"Str","value":",从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究","loc":{"start":{"line":66,"column":30},"end":{"line":66,"column":93}},"range":[1015,1078],"raw":",从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":93}},"range":[985,1078],"raw":"把一个新作业装入内存时,须按照一定的**动态分区分配算法**,从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究"},{"type":"Paragraph","children":[{"type":"Str","value":"动态分区分配算法：","loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":9}},"range":[1080,1089],"raw":"动态分区分配算法："}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":9}},"range":[1080,1089],"raw":"动态分区分配算法："},{"type":"Header","depth":5,"children":[{"type":"Str","value":"首次适应算法","loc":{"start":{"line":70,"column":6},"end":{"line":70,"column":12}},"range":[1097,1103],"raw":"首次适应算法"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":12}},"range":[1091,1103],"raw":"##### 首次适应算法"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想：每一次都从低地址开始查找，找到第一个能满足大小的额空闲分区。","loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":35}},"range":[1105,1140],"raw":"算法思想：每一次都从低地址开始查找，找到第一个能满足大小的额空闲分区。"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":35}},"range":[1105,1140],"raw":"算法思想：每一次都从低地址开始查找，找到第一个能满足大小的额空闲分区。"},{"type":"Paragraph","children":[{"type":"Str","value":"在空闲分区表或者空闲分区链中，空闲分区以","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":20}},"range":[1142,1162],"raw":"在空闲分区表或者空闲分区链中，空闲分区以"},{"type":"Strong","children":[{"type":"Str","value":"地址递增的次序排列","loc":{"start":{"line":74,"column":22},"end":{"line":74,"column":31}},"range":[1164,1173],"raw":"地址递增的次序排列"}],"loc":{"start":{"line":74,"column":20},"end":{"line":74,"column":33}},"range":[1162,1175],"raw":"**地址递增的次序排列**"},{"type":"Str","value":"，每次分配内存的时候，","loc":{"start":{"line":74,"column":33},"end":{"line":74,"column":44}},"range":[1175,1186],"raw":"，每次分配内存的时候，"},{"type":"Strong","children":[{"type":"Str","value":"选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区","loc":{"start":{"line":74,"column":46},"end":{"line":74,"column":74}},"range":[1188,1216],"raw":"选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区"}],"loc":{"start":{"line":74,"column":44},"end":{"line":74,"column":76}},"range":[1186,1218],"raw":"**选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区**"},{"type":"Str","value":"。","loc":{"start":{"line":74,"column":76},"end":{"line":74,"column":77}},"range":[1218,1219],"raw":"。"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":77}},"range":[1142,1219],"raw":"在空闲分区表或者空闲分区链中，空闲分区以**地址递增的次序排列**，每次分配内存的时候，**选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区**。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"最佳适应算法","loc":{"start":{"line":76,"column":6},"end":{"line":76,"column":12}},"range":[1227,1233],"raw":"最佳适应算法"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":12}},"range":[1221,1233],"raw":"##### 最佳适应算法"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想：动态分区分配是一种连续的分配方式，为进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来的时候能有连续的大片空间，可以尽可能多地留下大片空闲区，","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":83}},"range":[1235,1318],"raw":"算法思想：动态分区分配是一种连续的分配方式，为进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来的时候能有连续的大片空间，可以尽可能多地留下大片空闲区，"},{"type":"Strong","children":[{"type":"Str","value":"优先使用更小的空闲区","loc":{"start":{"line":78,"column":85},"end":{"line":78,"column":95}},"range":[1320,1330],"raw":"优先使用更小的空闲区"}],"loc":{"start":{"line":78,"column":83},"end":{"line":78,"column":97}},"range":[1318,1332],"raw":"**优先使用更小的空闲区**"},{"type":"Str","value":"。","loc":{"start":{"line":78,"column":97},"end":{"line":78,"column":98}},"range":[1332,1333],"raw":"。"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":98}},"range":[1235,1333],"raw":"算法思想：动态分区分配是一种连续的分配方式，为进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来的时候能有连续的大片空间，可以尽可能多地留下大片空闲区，**优先使用更小的空闲区**。"},{"type":"Paragraph","children":[{"type":"Str","value":"将空闲分区按照容量递增的次序依次连接，分配内存的时候查找空闲分区链或者空闲分区表，找到第一个代销能满足进程需要的空闲分区。","loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":61}},"range":[1335,1396],"raw":"将空闲分区按照容量递增的次序依次连接，分配内存的时候查找空闲分区链或者空闲分区表，找到第一个代销能满足进程需要的空闲分区。"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":61}},"range":[1335,1396],"raw":"将空闲分区按照容量递增的次序依次连接，分配内存的时候查找空闲分区链或者空闲分区表，找到第一个代销能满足进程需要的空闲分区。"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：使用最佳适应算法，会产生很多外部碎片","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":21}},"range":[1398,1419],"raw":"缺点：使用最佳适应算法，会产生很多外部碎片"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":21}},"range":[1398,1419],"raw":"缺点：使用最佳适应算法，会产生很多外部碎片"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"最坏适应算法","loc":{"start":{"line":84,"column":6},"end":{"line":84,"column":12}},"range":[1427,1433],"raw":"最坏适应算法"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":12}},"range":[1421,1433],"raw":"##### 最坏适应算法"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想：为了解决最佳适应算法留下太多难以利用的小碎片的问题，最坏适应算法每次分配时优先使用最大的连续空间，这样分配后的空间就不会太小，方便使用。","loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":73}},"range":[1435,1508],"raw":"算法思想：为了解决最佳适应算法留下太多难以利用的小碎片的问题，最坏适应算法每次分配时优先使用最大的连续空间，这样分配后的空间就不会太小，方便使用。"}],"loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":73}},"range":[1435,1508],"raw":"算法思想：为了解决最佳适应算法留下太多难以利用的小碎片的问题，最坏适应算法每次分配时优先使用最大的连续空间，这样分配后的空间就不会太小，方便使用。"},{"type":"Paragraph","children":[{"type":"Str","value":"将空闲分区按照容量递减的次序依次连接，分配内存的额时候查找空闲分区表或空闲分区链，找到大小能满足需求的第一个空闲分区。","loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":59}},"range":[1510,1569],"raw":"将空闲分区按照容量递减的次序依次连接，分配内存的额时候查找空闲分区表或空闲分区链，找到大小能满足需求的第一个空闲分区。"}],"loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":59}},"range":[1510,1569],"raw":"将空闲分区按照容量递减的次序依次连接，分配内存的额时候查找空闲分区表或空闲分区链，找到大小能满足需求的第一个空闲分区。"},{"type":"Paragraph","children":[{"type":"Str","value":"缺点：连续的大分区被迅速使用完，如果之后“大进程”到达，就没有可以用的内存分区了。","loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":41}},"range":[1571,1612],"raw":"缺点：连续的大分区被迅速使用完，如果之后“大进程”到达，就没有可以用的内存分区了。"}],"loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":41}},"range":[1571,1612],"raw":"缺点：连续的大分区被迅速使用完，如果之后“大进程”到达，就没有可以用的内存分区了。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"邻近适应算法","loc":{"start":{"line":92,"column":6},"end":{"line":92,"column":12}},"range":[1620,1626],"raw":"邻近适应算法"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":12}},"range":[1614,1626],"raw":"##### 邻近适应算法"},{"type":"Paragraph","children":[{"type":"Str","value":"算法思想：首次适应算法每次都从链头开始查找，可能会导致低地址出现很多小的空闲空间分区，每次分配查找的时候，都要经过这些分区，增加了查找的开销，如果每次都从上次搜索结束的位置开始查找，就可以解决上面的问题。","loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":102}},"range":[1628,1730],"raw":"算法思想：首次适应算法每次都从链头开始查找，可能会导致低地址出现很多小的空闲空间分区，每次分配查找的时候，都要经过这些分区，增加了查找的开销，如果每次都从上次搜索结束的位置开始查找，就可以解决上面的问题。"}],"loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":102}},"range":[1628,1730],"raw":"算法思想：首次适应算法每次都从链头开始查找，可能会导致低地址出现很多小的空闲空间分区，每次分配查找的时候，都要经过这些分区，增加了查找的开销，如果每次都从上次搜索结束的位置开始查找，就可以解决上面的问题。"},{"type":"Paragraph","children":[{"type":"Str","value":"将空闲分区按照起始地址递增的方式排列成一个循环链表，每次分配内存时，从上次检查结果的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。","loc":{"start":{"line":96,"column":0},"end":{"line":96,"column":80}},"range":[1732,1812],"raw":"将空闲分区按照起始地址递增的方式排列成一个循环链表，每次分配内存时，从上次检查结果的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。"}],"loc":{"start":{"line":96,"column":0},"end":{"line":96,"column":80}},"range":[1732,1812],"raw":"将空闲分区按照起始地址递增的方式排列成一个循环链表，每次分配内存时，从上次检查结果的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。"},{"type":"Header","depth":2,"children":[],"loc":{"start":{"line":98,"column":0},"end":{"line":98,"column":3}},"range":[1814,1817],"raw":"## "}],"loc":{"start":{"line":1,"column":0},"end":{"line":100,"column":0}},"range":[0,1819],"raw":"---\ntitle: '内存分配与回收'\ntags: ['操作系统','内存']\n---\n# 内存分配与回收\n\n## 连续分配\n\n### 单一连续分配\n\n内存分为“系统区”和“用户区”，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。 用户区存放用户进程相关的数据，**内存中只有一道用户程序**，用户程序独占整个用户区。\n\n- 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护\n- 缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。\n\n*****\n\n### 固定分区分配\n\n为了可以在内存中装入多道程序，而且这些程序不会相互干扰，将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，就形成了最早的、最简单的一种可运行多道程序的内存管理方式。\n\n分区说明表：\n\n操作系统维护和更新一个分区说明表，实现对各个分区的分配和回收\n\n| 分区号 | 大小 | 起始地址 | 状态   |\n| ------ | ---- | -------- | ------ |\n| 1      | 2    | 8        | 未分配 |\n| 2      | 2    | 10       | 未分配 |\n\n缺点：会产生内部碎片\n\n#### 分区大小相等\n\n- 缺点：缺乏灵活性\n- 优点：适用于一台计算机**控制多个相同的对象**的场合\n\n#### 分区大小不等\n\n- 优点：增加了灵活性，可以满足不同大小的进程需求\n\n*****\n\n### 动态分区分配\n\n可变分区分配，不会预先划分内存分区，而是在进程装入内存时，**根据进程的大小动态建立分区**，使分区的大小正好满足进程的需要。\n\n- 缺点：动态分区分配没有内部碎片,但是有外部碎片。\n  - 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上\n  - 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。\n\n#### 记录内存的使用情况\n\n- 空闲分区表\n\n  每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息\n\n- 空闲分区链\n\n  每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息\n\n*****\n\n#### 空闲分区的分配\n\n把一个新作业装入内存时,须按照一定的**动态分区分配算法**,从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究\n\n动态分区分配算法：\n\n##### 首次适应算法\n\n算法思想：每一次都从低地址开始查找，找到第一个能满足大小的额空闲分区。\n\n在空闲分区表或者空闲分区链中，空闲分区以**地址递增的次序排列**，每次分配内存的时候，**选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区**。\n\n##### 最佳适应算法\n\n算法思想：动态分区分配是一种连续的分配方式，为进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来的时候能有连续的大片空间，可以尽可能多地留下大片空闲区，**优先使用更小的空闲区**。\n\n将空闲分区按照容量递增的次序依次连接，分配内存的时候查找空闲分区链或者空闲分区表，找到第一个代销能满足进程需要的空闲分区。\n\n缺点：使用最佳适应算法，会产生很多外部碎片\n\n##### 最坏适应算法\n\n算法思想：为了解决最佳适应算法留下太多难以利用的小碎片的问题，最坏适应算法每次分配时优先使用最大的连续空间，这样分配后的空间就不会太小，方便使用。\n\n将空闲分区按照容量递减的次序依次连接，分配内存的额时候查找空闲分区表或空闲分区链，找到大小能满足需求的第一个空闲分区。\n\n缺点：连续的大分区被迅速使用完，如果之后“大进程”到达，就没有可以用的内存分区了。\n\n##### 邻近适应算法\n\n算法思想：首次适应算法每次都从链头开始查找，可能会导致低地址出现很多小的空闲空间分区，每次分配查找的时候，都要经过这些分区，增加了查找的开销，如果每次都从上次搜索结束的位置开始查找，就可以解决上面的问题。\n\n将空闲分区按照起始地址递增的方式排列成一个循环链表，每次分配内存时，从上次检查结果的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。\n\n## \n\n"},"catalogue":{"title":"内存分配与回收","json-path":"2020-08-16-内存分配与回收.json","mdate":"2022-08-30T14:19:31.454Z","tags":["操作系统","内存"]}}