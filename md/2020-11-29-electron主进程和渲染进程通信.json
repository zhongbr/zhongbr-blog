{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: 'electron主进程与渲染进程通信'\ntags: ['前端', 'Electron']\nrecommend: 'frontend'","loc":{"start":{"line":1,"column":0},"end":{"line":5,"column":3}},"range":[0,82],"raw":"---\ntitle: 'electron主进程与渲染进程通信'\ntags: ['前端', 'Electron']\nrecommend: 'frontend'\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"Electron主进程与渲染进程通信","loc":{"start":{"line":7,"column":2},"end":{"line":7,"column":20}},"range":[86,104],"raw":"Electron主进程与渲染进程通信"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":20}},"range":[84,104],"raw":"# Electron主进程与渲染进程通信"},{"type":"Paragraph","children":[{"type":"Str","value":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式：","loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":36}},"range":[106,142],"raw":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式："}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":36}},"range":[106,142],"raw":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipc模块","loc":{"start":{"line":11,"column":3},"end":{"line":11,"column":8}},"range":[147,152],"raw":"ipc模块"}],"loc":{"start":{"line":11,"column":3},"end":{"line":11,"column":8}},"range":[147,152],"raw":"ipc模块"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":8}},"range":[144,152],"raw":"1. ipc模块"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"remote模块","loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":11}},"range":[156,164],"raw":"remote模块"}],"loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":11}},"range":[156,164],"raw":"remote模块"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":11}},"range":[153,164],"raw":"2. remote模块"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"webFrame模块","loc":{"start":{"line":13,"column":3},"end":{"line":13,"column":13}},"range":[168,178],"raw":"webFrame模块"}],"loc":{"start":{"line":13,"column":3},"end":{"line":13,"column":13}},"range":[168,178],"raw":"webFrame模块"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":13}},"range":[165,178],"raw":"3. webFrame模块"}],"loc":{"start":{"line":11,"column":0},"end":{"line":13,"column":13}},"range":[144,178],"raw":"1. ipc模块\n2. remote模块\n3. webFrame模块"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"ipc模块","loc":{"start":{"line":15,"column":3},"end":{"line":15,"column":8}},"range":[183,188],"raw":"ipc模块"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":8}},"range":[180,188],"raw":"## ipc模块"},{"type":"Paragraph","children":[{"type":"Str","value":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。","loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":46}},"range":[190,236],"raw":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":46}},"range":[190,236],"raw":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain：从主进程到渲染进程的异步通信","loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":24}},"range":[240,262],"raw":"ipcMain：从主进程到渲染进程的异步通信"}],"loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":24}},"range":[240,262],"raw":"ipcMain：从主进程到渲染进程的异步通信"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":24}},"range":[238,262],"raw":"- ipcMain：从主进程到渲染进程的异步通信"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipcRenderer：从渲染进程到主进程的同步或者异步通信","loc":{"start":{"line":20,"column":2},"end":{"line":20,"column":32}},"range":[265,295],"raw":"ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":20,"column":2},"end":{"line":20,"column":32}},"range":[265,295],"raw":"ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":32}},"range":[263,295],"raw":"- ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":19,"column":0},"end":{"line":20,"column":32}},"range":[238,295],"raw":"- ipcMain：从主进程到渲染进程的异步通信\n- ipcRenderer：从渲染进程到主进程的同步或者异步通信"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程接收并回复来自渲染进程的消息","loc":{"start":{"line":22,"column":4},"end":{"line":22,"column":21}},"range":[301,318],"raw":"主进程接收并回复来自渲染进程的消息"}],"loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":21}},"range":[297,318],"raw":"### 主进程接收并回复来自渲染进程的消息"},{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。","loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":37}},"range":[320,357],"raw":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":37}},"range":[320,357],"raw":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})","loc":{"start":{"line":26,"column":0},"end":{"line":33,"column":3}},"range":[359,532],"raw":"```javascript\nimport {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程发送消息到渲染进程","loc":{"start":{"line":35,"column":4},"end":{"line":35,"column":16}},"range":[538,550],"raw":"主进程发送消息到渲染进程"}],"loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":16}},"range":[534,550],"raw":"### 主进程发送消息到渲染进程"},{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。","loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":72}},"range":[552,624],"raw":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":72}},"range":[552,624],"raw":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})","loc":{"start":{"line":39,"column":0},"end":{"line":53,"column":3}},"range":[626,948],"raw":"```javascript\nimport { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"在渲染进程监听","loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":7}},"range":[950,957],"raw":"在渲染进程监听"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":7}},"range":[950,957],"raw":"在渲染进程监听"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});","loc":{"start":{"line":57,"column":0},"end":{"line":63,"column":3}},"range":[959,1079],"raw":"```javascript\nimport {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});\n```"},{"type":"HorizontalRule","loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":6}},"range":[1081,1087],"raw":"------"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Remote模块","loc":{"start":{"line":67,"column":3},"end":{"line":67,"column":11}},"range":[1092,1100],"raw":"Remote模块"}],"loc":{"start":{"line":67,"column":0},"end":{"line":67,"column":11}},"range":[1089,1100],"raw":"## Remote模块"},{"type":"Paragraph","children":[{"type":"Str","value":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。","loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":68}},"range":[1102,1170],"raw":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。"}],"loc":{"start":{"line":69,"column":0},"end":{"line":69,"column":68}},"range":[1102,1170],"raw":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。"},{"type":"Paragraph","children":[{"type":"Str","value":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为","loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":66}},"range":[1172,1238],"raw":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为"},{"type":"Strong","children":[{"type":"Str","value":"远程对象","loc":{"start":{"line":71,"column":68},"end":{"line":71,"column":72}},"range":[1240,1244],"raw":"远程对象"}],"loc":{"start":{"line":71,"column":66},"end":{"line":71,"column":74}},"range":[1238,1246],"raw":"**远程对象**"},{"type":"Str","value":"。","loc":{"start":{"line":71,"column":74},"end":{"line":71,"column":75}},"range":[1246,1247],"raw":"。"}],"loc":{"start":{"line":71,"column":0},"end":{"line":71,"column":75}},"range":[1172,1247],"raw":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为**远程对象**。"},{"type":"Paragraph","children":[{"type":"Str","value":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。","loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":68}},"range":[1249,1317],"raw":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。"}],"loc":{"start":{"line":73,"column":0},"end":{"line":73,"column":68}},"range":[1249,1317],"raw":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。"},{"type":"Paragraph","children":[{"type":"Str","value":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是","loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":34}},"range":[1319,1353],"raw":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是"},{"type":"Strong","children":[{"type":"Str","value":"可以在进程之间通信的可序列化的内容","loc":{"start":{"line":75,"column":36},"end":{"line":75,"column":53}},"range":[1355,1372],"raw":"可以在进程之间通信的可序列化的内容"}],"loc":{"start":{"line":75,"column":34},"end":{"line":75,"column":55}},"range":[1353,1374],"raw":"**可以在进程之间通信的可序列化的内容**"},{"type":"Str","value":"，渲染进程中的对象或者函数不能作为函数的参数传递。","loc":{"start":{"line":75,"column":55},"end":{"line":75,"column":80}},"range":[1374,1399],"raw":"，渲染进程中的对象或者函数不能作为函数的参数传递。"}],"loc":{"start":{"line":75,"column":0},"end":{"line":75,"column":80}},"range":[1319,1399],"raw":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是**可以在进程之间通信的可序列化的内容**，渲染进程中的对象或者函数不能作为函数的参数传递。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程中定义global对象，从渲染进程访问","loc":{"start":{"line":77,"column":4},"end":{"line":77,"column":26}},"range":[1405,1427],"raw":"主进程中定义global对象，从渲染进程访问"}],"loc":{"start":{"line":77,"column":0},"end":{"line":77,"column":26}},"range":[1401,1427],"raw":"### 主进程中定义global对象，从渲染进程访问"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"// 主进程\nglobal.hello = \"hello world from main process .\"","loc":{"start":{"line":79,"column":0},"end":{"line":82,"column":3}},"range":[1429,1502],"raw":"```javascript\n// 主进程\nglobal.hello = \"hello world from main process .\"\n```"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .","loc":{"start":{"line":84,"column":0},"end":{"line":91,"column":3}},"range":[1504,1661],"raw":"```javascript\n// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"远程对象的垃圾回收","loc":{"start":{"line":93,"column":4},"end":{"line":93,"column":13}},"range":[1667,1676],"raw":"远程对象的垃圾回收"}],"loc":{"start":{"line":93,"column":0},"end":{"line":93,"column":13}},"range":[1663,1676],"raw":"### 远程对象的垃圾回收"},{"type":"Paragraph","children":[{"type":"Str","value":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果","loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":57}},"range":[1678,1735],"raw":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果"},{"type":"Strong","children":[{"type":"Str","value":"远程对象泄露，那么主进程中的对象也会泄露","loc":{"start":{"line":95,"column":59},"end":{"line":95,"column":79}},"range":[1737,1757],"raw":"远程对象泄露，那么主进程中的对象也会泄露"}],"loc":{"start":{"line":95,"column":57},"end":{"line":95,"column":81}},"range":[1735,1759],"raw":"**远程对象泄露，那么主进程中的对象也会泄露**"},{"type":"Str","value":"。","loc":{"start":{"line":95,"column":81},"end":{"line":95,"column":82}},"range":[1759,1760],"raw":"。"}],"loc":{"start":{"line":95,"column":0},"end":{"line":95,"column":82}},"range":[1678,1760],"raw":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果**远程对象泄露，那么主进程中的对象也会泄露**。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":97,"column":0}},"range":[0,1762],"raw":"---\ntitle: 'electron主进程与渲染进程通信'\ntags: ['前端', 'Electron']\nrecommend: 'frontend'\n---\n\n# Electron主进程与渲染进程通信\n\n使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式：\n\n1. ipc模块\n2. remote模块\n3. webFrame模块\n\n## ipc模块\n\nipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。\n\n- ipcMain：从主进程到渲染进程的异步通信\n- ipcRenderer：从渲染进程到主进程的同步或者异步通信\n\n### 主进程接收并回复来自渲染进程的消息\n\nipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。\n\n```javascript\nimport {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})\n```\n\n### 主进程发送消息到渲染进程\n\nipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。\n\n```javascript\nimport { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})\n```\n\n在渲染进程监听\n\n```javascript\nimport {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});\n```\n\n------\n\n## Remote模块\n\nremote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。\n\n所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为**远程对象**。\n\n通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。\n\n通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是**可以在进程之间通信的可序列化的内容**，渲染进程中的对象或者函数不能作为函数的参数传递。\n\n### 主进程中定义global对象，从渲染进程访问\n\n```javascript\n// 主进程\nglobal.hello = \"hello world from main process .\"\n```\n\n```javascript\n// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .\n```\n\n### 远程对象的垃圾回收\n\n只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果**远程对象泄露，那么主进程中的对象也会泄露**。\n\n"},"catalogue":{"title":"electron主进程与渲染进程通信","json-path":"2020-11-29-electron主进程和渲染进程通信.json","mdate":"2020-11-29","cover":"https://i.328888.xyz/2023/01/01/tZTfx.jpeg","icon":"🦉","tags":["前端","Electron"],"recommend":"frontend"}}