{"ast":{"type":"Document","children":[{"type":"Yaml","value":"'title': 'electron主进程与渲染进程通信'\n'tags': ['前端', 'Electron']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,64],"raw":"---\n'title': 'electron主进程与渲染进程通信'\n'tags': ['前端', 'Electron']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"Electron主进程与渲染进程通信","loc":{"start":{"line":6,"column":2},"end":{"line":6,"column":20}},"range":[68,86],"raw":"Electron主进程与渲染进程通信"}],"loc":{"start":{"line":6,"column":0},"end":{"line":6,"column":20}},"range":[66,86],"raw":"# Electron主进程与渲染进程通信"},{"type":"Paragraph","children":[{"type":"Str","value":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式：","loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":36}},"range":[88,124],"raw":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式："}],"loc":{"start":{"line":8,"column":0},"end":{"line":8,"column":36}},"range":[88,124],"raw":"使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipc模块","loc":{"start":{"line":10,"column":3},"end":{"line":10,"column":8}},"range":[129,134],"raw":"ipc模块"}],"loc":{"start":{"line":10,"column":3},"end":{"line":10,"column":8}},"range":[129,134],"raw":"ipc模块"}],"loc":{"start":{"line":10,"column":0},"end":{"line":10,"column":8}},"range":[126,134],"raw":"1. ipc模块"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"remote模块","loc":{"start":{"line":11,"column":3},"end":{"line":11,"column":11}},"range":[138,146],"raw":"remote模块"}],"loc":{"start":{"line":11,"column":3},"end":{"line":11,"column":11}},"range":[138,146],"raw":"remote模块"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":11}},"range":[135,146],"raw":"2. remote模块"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"webFrame模块","loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":13}},"range":[150,160],"raw":"webFrame模块"}],"loc":{"start":{"line":12,"column":3},"end":{"line":12,"column":13}},"range":[150,160],"raw":"webFrame模块"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":13}},"range":[147,160],"raw":"3. webFrame模块"}],"loc":{"start":{"line":10,"column":0},"end":{"line":12,"column":13}},"range":[126,160],"raw":"1. ipc模块\n2. remote模块\n3. webFrame模块"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"ipc模块","loc":{"start":{"line":14,"column":3},"end":{"line":14,"column":8}},"range":[165,170],"raw":"ipc模块"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":8}},"range":[162,170],"raw":"## ipc模块"},{"type":"Paragraph","children":[{"type":"Str","value":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。","loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":46}},"range":[172,218],"raw":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":46}},"range":[172,218],"raw":"ipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain：从主进程到渲染进程的异步通信","loc":{"start":{"line":18,"column":2},"end":{"line":18,"column":24}},"range":[222,244],"raw":"ipcMain：从主进程到渲染进程的异步通信"}],"loc":{"start":{"line":18,"column":2},"end":{"line":18,"column":24}},"range":[222,244],"raw":"ipcMain：从主进程到渲染进程的异步通信"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":24}},"range":[220,244],"raw":"- ipcMain：从主进程到渲染进程的异步通信"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"ipcRenderer：从渲染进程到主进程的同步或者异步通信","loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":32}},"range":[247,277],"raw":"ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":19,"column":2},"end":{"line":19,"column":32}},"range":[247,277],"raw":"ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":32}},"range":[245,277],"raw":"- ipcRenderer：从渲染进程到主进程的同步或者异步通信"}],"loc":{"start":{"line":18,"column":0},"end":{"line":19,"column":32}},"range":[220,277],"raw":"- ipcMain：从主进程到渲染进程的异步通信\n- ipcRenderer：从渲染进程到主进程的同步或者异步通信"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程接收并回复来自渲染进程的消息","loc":{"start":{"line":21,"column":4},"end":{"line":21,"column":21}},"range":[283,300],"raw":"主进程接收并回复来自渲染进程的消息"}],"loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":21}},"range":[279,300],"raw":"### 主进程接收并回复来自渲染进程的消息"},{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。","loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":37}},"range":[302,339],"raw":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":37}},"range":[302,339],"raw":"ipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})","loc":{"start":{"line":25,"column":0},"end":{"line":32,"column":3}},"range":[341,514],"raw":"```javascript\nimport {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程发送消息到渲染进程","loc":{"start":{"line":34,"column":4},"end":{"line":34,"column":16}},"range":[520,532],"raw":"主进程发送消息到渲染进程"}],"loc":{"start":{"line":34,"column":0},"end":{"line":34,"column":16}},"range":[516,532],"raw":"### 主进程发送消息到渲染进程"},{"type":"Paragraph","children":[{"type":"Str","value":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。","loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":72}},"range":[534,606],"raw":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":72}},"range":[534,606],"raw":"ipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})","loc":{"start":{"line":38,"column":0},"end":{"line":52,"column":3}},"range":[608,930],"raw":"```javascript\nimport { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"在渲染进程监听","loc":{"start":{"line":54,"column":0},"end":{"line":54,"column":7}},"range":[932,939],"raw":"在渲染进程监听"}],"loc":{"start":{"line":54,"column":0},"end":{"line":54,"column":7}},"range":[932,939],"raw":"在渲染进程监听"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"import {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});","loc":{"start":{"line":56,"column":0},"end":{"line":62,"column":3}},"range":[941,1061],"raw":"```javascript\nimport {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});\n```"},{"type":"HorizontalRule","loc":{"start":{"line":64,"column":0},"end":{"line":64,"column":6}},"range":[1063,1069],"raw":"------"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"Remote模块","loc":{"start":{"line":66,"column":3},"end":{"line":66,"column":11}},"range":[1074,1082],"raw":"Remote模块"}],"loc":{"start":{"line":66,"column":0},"end":{"line":66,"column":11}},"range":[1071,1082],"raw":"## Remote模块"},{"type":"Paragraph","children":[{"type":"Str","value":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。","loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":68}},"range":[1084,1152],"raw":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。"}],"loc":{"start":{"line":68,"column":0},"end":{"line":68,"column":68}},"range":[1084,1152],"raw":"remote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。"},{"type":"Paragraph","children":[{"type":"Str","value":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为","loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":66}},"range":[1154,1220],"raw":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为"},{"type":"Strong","children":[{"type":"Str","value":"远程对象","loc":{"start":{"line":70,"column":68},"end":{"line":70,"column":72}},"range":[1222,1226],"raw":"远程对象"}],"loc":{"start":{"line":70,"column":66},"end":{"line":70,"column":74}},"range":[1220,1228],"raw":"**远程对象**"},{"type":"Str","value":"。","loc":{"start":{"line":70,"column":74},"end":{"line":70,"column":75}},"range":[1228,1229],"raw":"。"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":75}},"range":[1154,1229],"raw":"所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为**远程对象**。"},{"type":"Paragraph","children":[{"type":"Str","value":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。","loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":68}},"range":[1231,1299],"raw":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":68}},"range":[1231,1299],"raw":"通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。"},{"type":"Paragraph","children":[{"type":"Str","value":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":34}},"range":[1301,1335],"raw":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是"},{"type":"Strong","children":[{"type":"Str","value":"可以在进程之间通信的可序列化的内容","loc":{"start":{"line":74,"column":36},"end":{"line":74,"column":53}},"range":[1337,1354],"raw":"可以在进程之间通信的可序列化的内容"}],"loc":{"start":{"line":74,"column":34},"end":{"line":74,"column":55}},"range":[1335,1356],"raw":"**可以在进程之间通信的可序列化的内容**"},{"type":"Str","value":"，渲染进程中的对象或者函数不能作为函数的参数传递。","loc":{"start":{"line":74,"column":55},"end":{"line":74,"column":80}},"range":[1356,1381],"raw":"，渲染进程中的对象或者函数不能作为函数的参数传递。"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":80}},"range":[1301,1381],"raw":"通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是**可以在进程之间通信的可序列化的内容**，渲染进程中的对象或者函数不能作为函数的参数传递。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"主进程中定义global对象，从渲染进程访问","loc":{"start":{"line":76,"column":4},"end":{"line":76,"column":26}},"range":[1387,1409],"raw":"主进程中定义global对象，从渲染进程访问"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":26}},"range":[1383,1409],"raw":"### 主进程中定义global对象，从渲染进程访问"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"// 主进程\nglobal.hello = \"hello world from main process .\"","loc":{"start":{"line":78,"column":0},"end":{"line":81,"column":3}},"range":[1411,1484],"raw":"```javascript\n// 主进程\nglobal.hello = \"hello world from main process .\"\n```"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .","loc":{"start":{"line":83,"column":0},"end":{"line":90,"column":3}},"range":[1486,1643],"raw":"```javascript\n// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"远程对象的垃圾回收","loc":{"start":{"line":92,"column":4},"end":{"line":92,"column":13}},"range":[1649,1658],"raw":"远程对象的垃圾回收"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":13}},"range":[1645,1658],"raw":"### 远程对象的垃圾回收"},{"type":"Paragraph","children":[{"type":"Str","value":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果","loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":57}},"range":[1660,1717],"raw":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果"},{"type":"Strong","children":[{"type":"Str","value":"远程对象泄露，那么主进程中的对象也会泄露","loc":{"start":{"line":94,"column":59},"end":{"line":94,"column":79}},"range":[1719,1739],"raw":"远程对象泄露，那么主进程中的对象也会泄露"}],"loc":{"start":{"line":94,"column":57},"end":{"line":94,"column":81}},"range":[1717,1741],"raw":"**远程对象泄露，那么主进程中的对象也会泄露**"},{"type":"Str","value":"。","loc":{"start":{"line":94,"column":81},"end":{"line":94,"column":82}},"range":[1741,1742],"raw":"。"}],"loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":82}},"range":[1660,1742],"raw":"只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果**远程对象泄露，那么主进程中的对象也会泄露**。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":96,"column":0}},"range":[0,1744],"raw":"---\n'title': 'electron主进程与渲染进程通信'\n'tags': ['前端', 'Electron']\n---\n\n# Electron主进程与渲染进程通信\n\n使用electron时，要实现主进程和渲染进程之间的通信主要有三种方式：\n\n1. ipc模块\n2. remote模块\n3. webFrame模块\n\n## ipc模块\n\nipc模块是EventEmiter的实例，可以在主进程和渲染之间发送消息以及接受对方的回复。\n\n- ipcMain：从主进程到渲染进程的异步通信\n- ipcRenderer：从渲染进程到主进程的同步或者异步通信\n\n### 主进程接收并回复来自渲染进程的消息\n\nipcMain在主进程中接收来自渲染进程传递来的消息，处理并回复渲染进程。\n\n```javascript\nimport {ipcMain} from 'electron';\n\nipcMain.on('channel-name', (event, args)=>{\n  console.log(args);\n  event.reply('reply-channel-name', 'reply-values');\n})\n```\n\n### 主进程发送消息到渲染进程\n\nipcMain对象并未提供send方法，如果要从主进程发送消息到渲染进程，可以使用webContents对象的send方法，向渲染进程发送消息。\n\n```javascript\nimport { app, BrowserWindow } from 'electron';\n\nlet win = null;\n\napp.whenReady().then(()=>{\n  \n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n  \n})\n```\n\n在渲染进程监听\n\n```javascript\nimport {ipcRenderer} from 'electron';\n\nipcRenderer.on('ping',(event, args)=>{\n  console.log(args);\n});\n```\n\n------\n\n## Remote模块\n\nremote模块返回的每一个对象都表示一个远程对象，调用远程对象的方法、调用远程函数或者调用远程构造函数，本质上都是在进程之间传递消息。\n\n所以调用remote模块返回的构造函数构造对象时，该对象实际上还是在主进程中，渲染进程中的对象实际上只是一个主进程对象的映射，称之为**远程对象**。\n\n通过远程对象访问数组等对象时，访问的是其在IPC上的复制，如果对其进行修改，修改的只是复制的一份，主进程的对象中对应的值并不会发生改变。\n\n通过remote模块调用主进程中的函数或者方法的时候，可以传递的只是**可以在进程之间通信的可序列化的内容**，渲染进程中的对象或者函数不能作为函数的参数传递。\n\n### 主进程中定义global对象，从渲染进程访问\n\n```javascript\n// 主进程\nglobal.hello = \"hello world from main process .\"\n```\n\n```javascript\n// 渲染进程\nimport {remote} from 'electron';\n\nlet hello = remote.getGlobal('hello');\nconsole.log(hello);\n// 输出: hello world from main process .\n```\n\n### 远程对象的垃圾回收\n\n只要渲染进程中的远程对象没有被垃圾回收，仍然存在，那么其在主进程中对应的对象也不会被解除引用，会一直存在，所以如果**远程对象泄露，那么主进程中的对象也会泄露**。\n\n"},"catalogue":{"title":"electron主进程与渲染进程通信","json-path":"2020-11-29-electron主进程和渲染进程通信.json","mdate":"2022-08-30T16:51:04.367Z","tags":["前端","Electron"]}}