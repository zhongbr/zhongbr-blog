{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','广义表']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,28],"raw":"---\ntags: ['数据结构','广义表']\n---"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"广义表的递归算法","loc":{"start":{"line":5,"column":3},"end":{"line":5,"column":11}},"range":[33,41],"raw":"广义表的递归算法"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":11}},"range":[30,41],"raw":"## 广义表的递归算法"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Strong","children":[{"type":"Str","value":"递归：","loc":{"start":{"line":7,"column":4},"end":{"line":7,"column":7}},"range":[47,50],"raw":"递归："}],"loc":{"start":{"line":7,"column":2},"end":{"line":7,"column":9}},"range":[45,52],"raw":"**递归：**"}],"loc":{"start":{"line":7,"column":2},"end":{"line":7,"column":9}},"range":[45,52],"raw":"**递归：**"},{"type":"Paragraph","children":[{"type":"Str","value":"递归算法是一种结构清晰、程序易读且容易验证正确性的函数，是程序设计时的有力工具。","loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":42}},"range":[57,97],"raw":"递归算法是一种结构清晰、程序易读且容易验证正确性的函数，是程序设计时的有力工具。"}],"loc":{"start":{"line":9,"column":2},"end":{"line":9,"column":42}},"range":[57,97],"raw":"递归算法是一种结构清晰、程序易读且容易验证正确性的函数，是程序设计时的有力工具。"},{"type":"Paragraph","children":[{"type":"Str","value":"使用递归解决问题时，对原问题进行分解，分解成为若干和原问题性质相同的子问题，自然地得到一个递归算法。","loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":52}},"range":[103,153],"raw":"使用递归解决问题时，对原问题进行分解，分解成为若干和原问题性质相同的子问题，自然地得到一个递归算法。"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":52}},"range":[103,153],"raw":"使用递归解决问题时，对原问题进行分解，分解成为若干和原问题性质相同的子问题，自然地得到一个递归算法。"},{"type":"Paragraph","children":[{"type":"Str","value":"在任何实际应用中，要求递归算法除错误的情况外，可以在有限层次递归后终止，即达到可以不需要递归而可以直接求解的状态。","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":59}},"range":[158,215],"raw":"在任何实际应用中，要求递归算法除错误的情况外，可以在有限层次递归后终止，即达到可以不需要递归而可以直接求解的状态。"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":59}},"range":[158,215],"raw":"在任何实际应用中，要求递归算法除错误的情况外，可以在有限层次递归后终止，即达到可以不需要递归而可以直接求解的状态。"}],"loc":{"start":{"line":7,"column":0},"end":{"line":13,"column":59}},"range":[43,215],"raw":"> **递归：**\n>\n> 递归算法是一种结构清晰、程序易读且容易验证正确性的函数，是程序设计时的有力工具。\n> \n> 使用递归解决问题时，对原问题进行分解，分解成为若干和原问题性质相同的子问题，自然地得到一个递归算法。\n>\n> 在任何实际应用中，要求递归算法除错误的情况外，可以在有限层次递归后终止，即达到可以不需要递归而可以直接求解的状态。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"1.求广义表的深度","loc":{"start":{"line":15,"column":4},"end":{"line":15,"column":13}},"range":[221,230],"raw":"1.求广义表的深度"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":13}},"range":[217,230],"raw":"### 1.求广义表的深度"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"广义表深度：广义表的括号的重(chóng)数。","loc":{"start":{"line":17,"column":2},"end":{"line":17,"column":25}},"range":[234,257],"raw":"广义表深度：广义表的括号的重(chóng)数。"}],"loc":{"start":{"line":17,"column":2},"end":{"line":17,"column":25}},"range":[234,257],"raw":"广义表深度：广义表的括号的重(chóng)数。"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":25}},"range":[232,257],"raw":"> 广义表深度：广义表的括号的重(chóng)数。"},{"type":"CodeBlock","lang":"python","meta":null,"value":"def get_depth(lists: list, depth=0) -> int:\n    \"\"\"\n    获取列表的深度\n    \"\"\"\n    if lists is None:\n        return depth\n    result = depth + 1\n    for item in lists:\n        if type(item) != type([]):\n            d = depth\n        else:\n            d = get_depth(item, depth+1)\n        result = d if d > result else result\n    return result","loc":{"start":{"line":19,"column":0},"end":{"line":34,"column":3}},"range":[259,608],"raw":"```python\ndef get_depth(lists: list, depth=0) -> int:\n    \"\"\"\n    获取列表的深度\n    \"\"\"\n    if lists is None:\n        return depth\n    result = depth + 1\n    for item in lists:\n        if type(item) != type([]):\n            d = depth\n        else:\n            d = get_depth(item, depth+1)\n        result = d if d > result else result\n    return result\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"2.复制广义表","loc":{"start":{"line":36,"column":4},"end":{"line":36,"column":11}},"range":[614,621],"raw":"2.复制广义表"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":11}},"range":[610,621],"raw":"### 2.复制广义表"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"任意非空的广义表均可以分解成表头和表尾，复制广义表分别复制其表头和表尾，然后合成即可。","loc":{"start":{"line":38,"column":2},"end":{"line":38,"column":45}},"range":[625,668],"raw":"任意非空的广义表均可以分解成表头和表尾，复制广义表分别复制其表头和表尾，然后合成即可。"}],"loc":{"start":{"line":38,"column":2},"end":{"line":38,"column":45}},"range":[625,668],"raw":"任意非空的广义表均可以分解成表头和表尾，复制广义表分别复制其表头和表尾，然后合成即可。"}],"loc":{"start":{"line":38,"column":0},"end":{"line":38,"column":45}},"range":[623,668],"raw":"> 任意非空的广义表均可以分解成表头和表尾，复制广义表分别复制其表头和表尾，然后合成即可。"},{"type":"CodeBlock","lang":"python","meta":null,"value":"def deep_copy(lists: list, res=[]) -> list:\n    \"\"\"\n    递归复制列表\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        return lists\n    res = [lists[0]]\n    for item in lists[1:]:\n        res.append(deep_copy(item, res))\n    return res","loc":{"start":{"line":40,"column":0},"end":{"line":51,"column":3}},"range":[670,947],"raw":"```python\ndef deep_copy(lists: list, res=[]) -> list:\n    \"\"\"\n    递归复制列表\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        return lists\n    res = [lists[0]]\n    for item in lists[1:]:\n        res.append(deep_copy(item, res))\n    return res\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"3.建立广义表的存储结构","loc":{"start":{"line":53,"column":4},"end":{"line":53,"column":16}},"range":[953,965],"raw":"3.建立广义表的存储结构"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":16}},"range":[949,965],"raw":"### 3.建立广义表的存储结构"},{"type":"BlockQuote","children":[{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"把广义表分解成表头和表尾两部分","loc":{"start":{"line":55,"column":4},"end":{"line":55,"column":19}},"range":[971,986],"raw":"把广义表分解成表头和表尾两部分"}],"loc":{"start":{"line":55,"column":4},"end":{"line":55,"column":19}},"range":[971,986],"raw":"把广义表分解成表头和表尾两部分"}],"loc":{"start":{"line":55,"column":2},"end":{"line":55,"column":19}},"range":[969,986],"raw":"- 把广义表分解成表头和表尾两部分"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"把广义表看成n个并列的子表（原子也视作子表）","loc":{"start":{"line":56,"column":4},"end":{"line":56,"column":26}},"range":[991,1013],"raw":"把广义表看成n个并列的子表（原子也视作子表）"}],"loc":{"start":{"line":56,"column":4},"end":{"line":56,"column":26}},"range":[991,1013],"raw":"把广义表看成n个并列的子表（原子也视作子表）"}],"loc":{"start":{"line":56,"column":2},"end":{"line":56,"column":26}},"range":[989,1013],"raw":"- 把广义表看成n个并列的子表（原子也视作子表）"}],"loc":{"start":{"line":55,"column":2},"end":{"line":56,"column":26}},"range":[969,1013],"raw":"- 把广义表分解成表头和表尾两部分\n> - 把广义表看成n个并列的子表（原子也视作子表）"}],"loc":{"start":{"line":55,"column":0},"end":{"line":56,"column":26}},"range":[967,1013],"raw":"> - 把广义表分解成表头和表尾两部分\n> - 把广义表看成n个并列的子表（原子也视作子表）"},{"type":"CodeBlock","lang":"python","meta":null,"value":"def storage_lists_1(lists: list, s='')->str:\n    \"\"\"\n    存储到字符串中\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        s += '{},'.format(str(lists))\n        return s\n    s += '['\n    for item in lists:\n        s = storage_lists_1(item, s)\n    s += ']'\n    return s","loc":{"start":{"line":58,"column":0},"end":{"line":71,"column":3}},"range":[1015,1323],"raw":"```python\ndef storage_lists_1(lists: list, s='')->str:\n    \"\"\"\n    存储到字符串中\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        s += '{},'.format(str(lists))\n        return s\n    s += '['\n    for item in lists:\n        s = storage_lists_1(item, s)\n    s += ']'\n    return s\n```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":71,"column":3}},"range":[0,1323],"raw":"---\ntags: ['数据结构','广义表']\n---\n\n## 广义表的递归算法\n\n> **递归：**\n>\n> 递归算法是一种结构清晰、程序易读且容易验证正确性的函数，是程序设计时的有力工具。\n> \n> 使用递归解决问题时，对原问题进行分解，分解成为若干和原问题性质相同的子问题，自然地得到一个递归算法。\n>\n> 在任何实际应用中，要求递归算法除错误的情况外，可以在有限层次递归后终止，即达到可以不需要递归而可以直接求解的状态。\n\n### 1.求广义表的深度\n\n> 广义表深度：广义表的括号的重(chóng)数。\n\n```python\ndef get_depth(lists: list, depth=0) -> int:\n    \"\"\"\n    获取列表的深度\n    \"\"\"\n    if lists is None:\n        return depth\n    result = depth + 1\n    for item in lists:\n        if type(item) != type([]):\n            d = depth\n        else:\n            d = get_depth(item, depth+1)\n        result = d if d > result else result\n    return result\n```\n\n### 2.复制广义表\n\n> 任意非空的广义表均可以分解成表头和表尾，复制广义表分别复制其表头和表尾，然后合成即可。\n\n```python\ndef deep_copy(lists: list, res=[]) -> list:\n    \"\"\"\n    递归复制列表\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        return lists\n    res = [lists[0]]\n    for item in lists[1:]:\n        res.append(deep_copy(item, res))\n    return res\n```\n\n### 3.建立广义表的存储结构\n\n> - 把广义表分解成表头和表尾两部分\n> - 把广义表看成n个并列的子表（原子也视作子表）\n\n```python\ndef storage_lists_1(lists: list, s='')->str:\n    \"\"\"\n    存储到字符串中\n    \"\"\"\n    if type(lists) != type([]) or lists is None or len(lists) == 0:\n        s += '{},'.format(str(lists))\n        return s\n    s += '['\n    for item in lists:\n        s = storage_lists_1(item, s)\n    s += ']'\n    return s\n```"},"catalogue":{"title":"2020-07-25-广义表的递归算法","json-path":"2020-07-25-广义表的递归算法.json","mdate":"2022-08-30T16:38:35.770Z","tags":["数据结构","广义表"]}}