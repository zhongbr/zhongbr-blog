{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','树']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','树']\n---"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"树的存储结构","loc":{"start":{"line":5,"column":3},"end":{"line":5,"column":9}},"range":[31,37],"raw":"树的存储结构"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":9}},"range":[28,37],"raw":"## 树的存储结构"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"一、双亲表示法","loc":{"start":{"line":7,"column":4},"end":{"line":7,"column":11}},"range":[43,50],"raw":"一、双亲表示法"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":11}},"range":[39,50],"raw":"### 一、双亲表示法"},{"type":"Paragraph","children":[{"type":"Str","value":"使用一组连续的存储空间表示树的结点，每个结点中设置一个指示器知识其双亲结点的位置。","loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":41}},"range":[52,93],"raw":"使用一组连续的存储空间表示树的结点，每个结点中设置一个指示器知识其双亲结点的位置。"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":41}},"range":[52,93],"raw":"使用一组连续的存储空间表示树的结点，每个结点中设置一个指示器知识其双亲结点的位置。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define MAX_TREE_SIZE 100\n\ntypedef struct PTNode {\n    TElemType data;\n    int parent;\n} PTNode;\n\ntypedef struct {\n    PTNode nodes[MAX-TREE_SIZE];\n    int r,n;\n} PTree;","loc":{"start":{"line":11,"column":0},"end":{"line":23,"column":3}},"range":[95,273],"raw":"```c\n#define MAX_TREE_SIZE 100\n\ntypedef struct PTNode {\n    TElemType data;\n    int parent;\n} PTNode;\n\ntypedef struct {\n    PTNode nodes[MAX-TREE_SIZE];\n    int r,n;\n} PTree;\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"利用了每个结点（除了根结点）只有一个双亲结点的特性。","loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":26}},"range":[274,300],"raw":"利用了每个结点（除了根结点）只有一个双亲结点的特性。"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":26}},"range":[274,300],"raw":"利用了每个结点（除了根结点）只有一个双亲结点的特性。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可","loc":{"start":{"line":26,"column":2},"end":{"line":26,"column":38}},"range":[304,340],"raw":"获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可"}],"loc":{"start":{"line":26,"column":2},"end":{"line":26,"column":38}},"range":[304,340],"raw":"获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可"}],"loc":{"start":{"line":26,"column":0},"end":{"line":26,"column":38}},"range":[302,340],"raw":"- 获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点","loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":34}},"range":[343,375],"raw":"通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点"}],"loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":34}},"range":[343,375],"raw":"通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":34}},"range":[341,375],"raw":"- 通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"获取结点的孩子需要","loc":{"start":{"line":28,"column":2},"end":{"line":28,"column":11}},"range":[378,387],"raw":"获取结点的孩子需要"},{"type":"Strong","children":[{"type":"Str","value":"遍历整棵树","loc":{"start":{"line":28,"column":13},"end":{"line":28,"column":18}},"range":[389,394],"raw":"遍历整棵树"}],"loc":{"start":{"line":28,"column":11},"end":{"line":28,"column":20}},"range":[387,396],"raw":"**遍历整棵树**"}],"loc":{"start":{"line":28,"column":2},"end":{"line":28,"column":20}},"range":[378,396],"raw":"获取结点的孩子需要**遍历整棵树**"}],"loc":{"start":{"line":28,"column":0},"end":{"line":28,"column":20}},"range":[376,396],"raw":"- 获取结点的孩子需要**遍历整棵树**"}],"loc":{"start":{"line":26,"column":0},"end":{"line":28,"column":20}},"range":[302,396],"raw":"- 获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可\n- 通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点\n- 获取结点的孩子需要**遍历整棵树**"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"二、孩子表示法","loc":{"start":{"line":30,"column":4},"end":{"line":30,"column":11}},"range":[402,409],"raw":"二、孩子表示法"}],"loc":{"start":{"line":30,"column":0},"end":{"line":30,"column":11}},"range":[398,409],"raw":"### 二、孩子表示法"},{"type":"Paragraph","children":[{"type":"Str","value":"使用多重链表，每一个指针域指向结点的一个孩子结点","loc":{"start":{"line":32,"column":0},"end":{"line":32,"column":24}},"range":[411,435],"raw":"使用多重链表，每一个指针域指向结点的一个孩子结点"}],"loc":{"start":{"line":32,"column":0},"end":{"line":32,"column":24}},"range":[411,435],"raw":"使用多重链表，每一个指针域指向结点的一个孩子结点"},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/07/28/Lz32Gno1tVEcYNm.png","alt":"????(C???).???_???.png","loc":{"start":{"line":34,"column":0},"end":{"line":34,"column":76}},"range":[437,513],"raw":"![????(C???).???_???.png](https://i.loli.net/2020/07/28/Lz32Gno1tVEcYNm.png)"}],"loc":{"start":{"line":34,"column":0},"end":{"line":34,"column":76}},"range":[437,513],"raw":"![????(C???).???_???.png](https://i.loli.net/2020/07/28/Lz32Gno1tVEcYNm.png)"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域","loc":{"start":{"line":36,"column":2},"end":{"line":36,"column":50}},"range":[517,565],"raw":"如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域"}],"loc":{"start":{"line":36,"column":2},"end":{"line":36,"column":50}},"range":[517,565],"raw":"如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域"}],"loc":{"start":{"line":36,"column":0},"end":{"line":36,"column":50}},"range":[515,565],"raw":"- 如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便","loc":{"start":{"line":37,"column":2},"end":{"line":37,"column":61}},"range":[568,627],"raw":"如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便"}],"loc":{"start":{"line":37,"column":2},"end":{"line":37,"column":61}},"range":[568,627],"raw":"如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":61}},"range":[566,627],"raw":"- 如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便"}],"loc":{"start":{"line":36,"column":0},"end":{"line":37,"column":61}},"range":[515,627],"raw":"- 如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域\n- 如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便"},{"type":"Paragraph","children":[{"type":"Str","value":"可以将每个结点的孩子排列起来，看做一个线性表，以单链表的形式存储，则n个结点的树则有n个孩子链表，然后将n个结点组成一个线性表。","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":64}},"range":[629,693],"raw":"可以将每个结点的孩子排列起来，看做一个线性表，以单链表的形式存储，则n个结点的树则有n个孩子链表，然后将n个结点组成一个线性表。"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":64}},"range":[629,693],"raw":"可以将每个结点的孩子排列起来，看做一个线性表，以单链表的形式存储，则n个结点的树则有n个孩子链表，然后将n个结点组成一个线性表。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"typedef struct CTNode {\n    int child;\n    struct CTNode *next;\n} *ChildPtr;\ntypedef struct {\n    TElemType *data;\n    ChildPtr firstchild;\n} CTBox;\ntypedef struct {\n    CTBox nodes[MAX_TREE_SIZE];\n    int n,r; // 结点数和根结点位置\n}","loc":{"start":{"line":41,"column":0},"end":{"line":54,"column":3}},"range":[695,929],"raw":"```c\ntypedef struct CTNode {\n    int child;\n    struct CTNode *next;\n} *ChildPtr;\ntypedef struct {\n    TElemType *data;\n    ChildPtr firstchild;\n} CTBox;\ntypedef struct {\n    CTBox nodes[MAX_TREE_SIZE];\n    int n,r; // 结点数和根结点位置\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"与双亲表示法相反，孩子表示法适合涉及孩子操作的实现，却不是用于寻找孩子双亲结点实现。","loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":42}},"range":[931,973],"raw":"与双亲表示法相反，孩子表示法适合涉及孩子操作的实现，却不是用于寻找孩子双亲结点实现。"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":42}},"range":[931,973],"raw":"与双亲表示法相反，孩子表示法适合涉及孩子操作的实现，却不是用于寻找孩子双亲结点实现。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"孩子兄弟表示法（二叉树表示法、二叉链表表示法）","loc":{"start":{"line":58,"column":4},"end":{"line":58,"column":27}},"range":[979,1002],"raw":"孩子兄弟表示法（二叉树表示法、二叉链表表示法）"}],"loc":{"start":{"line":58,"column":0},"end":{"line":58,"column":27}},"range":[975,1002],"raw":"### 孩子兄弟表示法（二叉树表示法、二叉链表表示法）"},{"type":"Paragraph","children":[{"type":"Str","value":"以二叉链表作为树的存储结构，链表结点的两个指针域分别指向该节点的第一个孩子结点(firstchild)和该节点的第一个兄弟结点(nextsibling)。","loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":77}},"range":[1004,1081],"raw":"以二叉链表作为树的存储结构，链表结点的两个指针域分别指向该节点的第一个孩子结点(firstchild)和该节点的第一个兄弟结点(nextsibling)。"}],"loc":{"start":{"line":60,"column":0},"end":{"line":60,"column":77}},"range":[1004,1081],"raw":"以二叉链表作为树的存储结构，链表结点的两个指针域分别指向该节点的第一个孩子结点(firstchild)和该节点的第一个兄弟结点(nextsibling)。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"typedef struct CSNode {\n    TElemType *data;\n    CSNode * firstchild, nextsibling;\n    /* CSNode *parent (增加这个结点可以方便查找双亲结点)*/\n} CSNode, *CSTree;","loc":{"start":{"line":62,"column":0},"end":{"line":68,"column":3}},"range":[1083,1236],"raw":"```c\ntypedef struct CSNode {\n    TElemType *data;\n    CSNode * firstchild, nextsibling;\n    /* CSNode *parent (增加这个结点可以方便查找双亲结点)*/\n} CSNode, *CSTree;\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"便于实现各种树的操作，例如易于实现查找结点孩子的方法，增加指向结点双亲的指针域，也易于实现查找结点双亲的操作。","loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":55}},"range":[1238,1293],"raw":"便于实现各种树的操作，例如易于实现查找结点孩子的方法，增加指向结点双亲的指针域，也易于实现查找结点双亲的操作。"}],"loc":{"start":{"line":70,"column":0},"end":{"line":70,"column":55}},"range":[1238,1293],"raw":"便于实现各种树的操作，例如易于实现查找结点孩子的方法，增加指向结点双亲的指针域，也易于实现查找结点双亲的操作。"}],"loc":{"start":{"line":1,"column":0},"end":{"line":70,"column":55}},"range":[0,1293],"raw":"---\ntags: ['数据结构','树']\n---\n\n## 树的存储结构\n\n### 一、双亲表示法\n\n使用一组连续的存储空间表示树的结点，每个结点中设置一个指示器知识其双亲结点的位置。\n\n```c\n#define MAX_TREE_SIZE 100\n\ntypedef struct PTNode {\n    TElemType data;\n    int parent;\n} PTNode;\n\ntypedef struct {\n    PTNode nodes[MAX-TREE_SIZE];\n    int r,n;\n} PTree;\n```\n利用了每个结点（除了根结点）只有一个双亲结点的特性。\n\n- 获取结点双亲可以在常量时间内完成，直接调用PARENT(T,x)操作即可\n- 通过反复调用PARENT操作，知道结点没有双亲时就可以找到根结点\n- 获取结点的孩子需要**遍历整棵树**\n\n### 二、孩子表示法\n\n使用多重链表，每一个指针域指向结点的一个孩子结点\n\n![????(C???).???_???.png](https://i.loli.net/2020/07/28/Lz32Gno1tVEcYNm.png)\n\n- 如果所有结点是同构的，如上图第一种结构，d是树的度，由于存在很多结点的度小于d，就会有很多空链域\n- 如果按照上图下面的结构，$$\\bar{d}$$是树的度，degree是结点的度，则可以节省很多空的链域，但是操作不方便\n\n可以将每个结点的孩子排列起来，看做一个线性表，以单链表的形式存储，则n个结点的树则有n个孩子链表，然后将n个结点组成一个线性表。\n\n```c\ntypedef struct CTNode {\n    int child;\n    struct CTNode *next;\n} *ChildPtr;\ntypedef struct {\n    TElemType *data;\n    ChildPtr firstchild;\n} CTBox;\ntypedef struct {\n    CTBox nodes[MAX_TREE_SIZE];\n    int n,r; // 结点数和根结点位置\n}\n```\n\n与双亲表示法相反，孩子表示法适合涉及孩子操作的实现，却不是用于寻找孩子双亲结点实现。\n\n### 孩子兄弟表示法（二叉树表示法、二叉链表表示法）\n\n以二叉链表作为树的存储结构，链表结点的两个指针域分别指向该节点的第一个孩子结点(firstchild)和该节点的第一个兄弟结点(nextsibling)。\n\n```c\ntypedef struct CSNode {\n    TElemType *data;\n    CSNode * firstchild, nextsibling;\n    /* CSNode *parent (增加这个结点可以方便查找双亲结点)*/\n} CSNode, *CSTree;\n```\n\n便于实现各种树的操作，例如易于实现查找结点孩子的方法，增加指向结点双亲的指针域，也易于实现查找结点双亲的操作。"},"catalogue":{"title":"2020-07-28-树的存储结构","json-path":"2020-07-28-树的存储结构.json","mdate":"2022-08-30T14:19:31.448Z","tags":["数据结构","树"]}}