{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '经典同步问题'\ntags: ['操作系统','进程同步']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,45],"raw":"---\ntitle: '经典同步问题'\ntags: ['操作系统','进程同步']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"经典同步问题","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":8}},"range":[48,54],"raw":"经典同步问题"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":8}},"range":[46,54],"raw":"# 经典同步问题"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"生产者消费者问题","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":11}},"range":[59,67],"raw":"生产者消费者问题"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":11}},"range":[56,67],"raw":"## 生产者消费者问题"},{"type":"Paragraph","children":[{"type":"Str","value":"系统中有一组生产者进程和一组消费者进程，生产者每一次放一个产品到缓冲区，消费者每一次从缓冲区取出一个产品。生产者和消费者进程共享一个初始为空，长度为n的缓冲区。","loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":80}},"range":[69,149],"raw":"系统中有一组生产者进程和一组消费者进程，生产者每一次放一个产品到缓冲区，消费者每一次从缓冲区取出一个产品。生产者和消费者进程共享一个初始为空，长度为n的缓冲区。"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":80}},"range":[69,149],"raw":"系统中有一组生产者进程和一组消费者进程，生产者每一次放一个产品到缓冲区，消费者每一次从缓冲区取出一个产品。生产者和消费者进程共享一个初始为空，长度为n的缓冲区。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品","loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":30}},"range":[153,181],"raw":"只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":30}},"range":[153,181],"raw":"只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":30}},"range":[151,181],"raw":"- 只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品","loc":{"start":{"line":12,"column":2},"end":{"line":12,"column":30}},"range":[184,212],"raw":"只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品"}],"loc":{"start":{"line":12,"column":2},"end":{"line":12,"column":30}},"range":[184,212],"raw":"只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":30}},"range":[182,212],"raw":"- 只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"缓冲区属于临界资源，各个进程的访问应该是互斥的","loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":25}},"range":[215,238],"raw":"缓冲区属于临界资源，各个进程的访问应该是互斥的"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":25}},"range":[215,238],"raw":"缓冲区属于临界资源，各个进程的访问应该是互斥的"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":25}},"range":[213,238],"raw":"- 缓冲区属于临界资源，各个进程的访问应该是互斥的"}],"loc":{"start":{"line":11,"column":0},"end":{"line":13,"column":25}},"range":[151,238],"raw":"- 只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品\n- 只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品\n- 缓冲区属于临界资源，各个进程的访问应该是互斥的"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"使用信号量机制来解决生产者和消费者问题","loc":{"start":{"line":15,"column":4},"end":{"line":15,"column":23}},"range":[244,263],"raw":"使用信号量机制来解决生产者和消费者问题"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":23}},"range":[240,263],"raw":"### 使用信号量机制来解决生产者和消费者问题"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semphore SemCache = 1; // 缓冲区互斥访问\nsemphore SemRead = 0; // 读信号量\nsemphore SemWrite = n; // 写信号量，n为缓冲区大小\n\n// 生产者的逻辑\nvoid Productor(){\n    // code... 生产者生产产品\n    P(SemWrite); // wait原语，等待缓冲区空闲\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到写入缓冲区的权限之后，否则会产生死锁\n    // code... 生产者写入产品的语句\n    V(SemCache); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    V(SemRead); // signal原语，唤醒一个读缓冲区的消费者进程\n}\n// 消费者的逻辑\nvoid Consumer(){\n    P(SemRead); // wait原语，等待读缓冲区\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到读取缓冲区的权限之后，否则会产生死锁\n    // code... 消费者读取产品的语句\n    V(SemCache); // signal原语，唤醒一个等待要读取缓冲区的消费者进程\n    V(SemWrite); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    // code... 消费者使用产品\n}","loc":{"start":{"line":17,"column":0},"end":{"line":40,"column":3}},"range":[265,907],"raw":"```c\nsemphore SemCache = 1; // 缓冲区互斥访问\nsemphore SemRead = 0; // 读信号量\nsemphore SemWrite = n; // 写信号量，n为缓冲区大小\n\n// 生产者的逻辑\nvoid Productor(){\n    // code... 生产者生产产品\n    P(SemWrite); // wait原语，等待缓冲区空闲\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到写入缓冲区的权限之后，否则会产生死锁\n    // code... 生产者写入产品的语句\n    V(SemCache); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    V(SemRead); // signal原语，唤醒一个读缓冲区的消费者进程\n}\n// 消费者的逻辑\nvoid Consumer(){\n    P(SemRead); // wait原语，等待读缓冲区\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到读取缓冲区的权限之后，否则会产生死锁\n    // code... 消费者读取产品的语句\n    V(SemCache); // signal原语，唤醒一个等待要读取缓冲区的消费者进程\n    V(SemWrite); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    // code... 消费者使用产品\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"生产者生产产品和消费者使用产品的代码最好放在临界区外，这样可以减少临界区的代码量，缩短临界区执行时间，提高系统资源的利用率和并发度。","loc":{"start":{"line":42,"column":0},"end":{"line":42,"column":66}},"range":[909,975],"raw":"生产者生产产品和消费者使用产品的代码最好放在临界区外，这样可以减少临界区的代码量，缩短临界区执行时间，提高系统资源的利用率和并发度。"}],"loc":{"start":{"line":42,"column":0},"end":{"line":42,"column":66}},"range":[909,975],"raw":"生产者生产产品和消费者使用产品的代码最好放在临界区外，这样可以减少临界区的代码量，缩短临界区执行时间，提高系统资源的利用率和并发度。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"多（类）生产者多（类）消费者模型","loc":{"start":{"line":44,"column":4},"end":{"line":44,"column":20}},"range":[981,997],"raw":"多（类）生产者多（类）消费者模型"}],"loc":{"start":{"line":44,"column":0},"end":{"line":44,"column":20}},"range":[977,997],"raw":"### 多（类）生产者多（类）消费者模型"},{"type":"Paragraph","children":[{"type":"Str","value":"生产者、消费者问题中存在不同的生产者生产不同的产品，不同的消费者使用不同的产品的时候就是","loc":{"start":{"line":46,"column":1},"end":{"line":46,"column":45}},"range":[1000,1044],"raw":"生产者、消费者问题中存在不同的生产者生产不同的产品，不同的消费者使用不同的产品的时候就是"},{"type":"Strong","children":[{"type":"Str","value":"多生产者多消费者问题","loc":{"start":{"line":46,"column":47},"end":{"line":46,"column":57}},"range":[1046,1056],"raw":"多生产者多消费者问题"}],"loc":{"start":{"line":46,"column":45},"end":{"line":46,"column":59}},"range":[1044,1058],"raw":"**多生产者多消费者问题**"},{"type":"Str","value":"。","loc":{"start":{"line":46,"column":59},"end":{"line":46,"column":60}},"range":[1058,1059],"raw":"。"}],"loc":{"start":{"line":46,"column":1},"end":{"line":46,"column":60}},"range":[1000,1059],"raw":"生产者、消费者问题中存在不同的生产者生产不同的产品，不同的消费者使用不同的产品的时候就是**多生产者多消费者问题**。"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"eg. 桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。","loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":132}},"range":[1063,1193],"raw":"eg. 桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。"}],"loc":{"start":{"line":48,"column":2},"end":{"line":48,"column":132}},"range":[1063,1193],"raw":"eg. 桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。"}],"loc":{"start":{"line":48,"column":0},"end":{"line":48,"column":132}},"range":[1061,1193],"raw":"> eg. 桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore apple = 0; // 盘子里的苹果数量\nsemaphore orange = 0; // 盘子里的橘子数量\nsemaphore saucer = 1; // 盘子的剩余容量\nsemaphore mutex = 0; // 正在有人访问盘子\n\n// 妈妈向盘子里放橘子\nvoid mother(){\n    while(true){\n        // code... 剥橘子\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // 放橘子\n        V(mutex); // 离开盘子\n        V(orange); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 爸爸向盘子里放苹果\nvoid mother(){\n    while(true){\n        // code... 削苹果\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // code... 放苹果\n        V(mutex); // 离开盘子\n        V(apple); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 儿子取橘子\nvoid son(){\n    while(true){\n        P(orange); // 等待一个橘子\n        P(mutex); // 等待其他人离开盘子\n        // code... 取橘子\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃橘子\n    }\n}\n\n// 女儿取苹果\nvoid daughter(){\n    while(true){\n        P(apple); // 等待一个苹果\n        P(mutex); // 等待其他人离开盘子\n        // code... 取苹果\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃苹果\n    }\n}","loc":{"start":{"line":50,"column":0},"end":{"line":103,"column":3}},"range":[1195,2205],"raw":"```c\nsemaphore apple = 0; // 盘子里的苹果数量\nsemaphore orange = 0; // 盘子里的橘子数量\nsemaphore saucer = 1; // 盘子的剩余容量\nsemaphore mutex = 0; // 正在有人访问盘子\n\n// 妈妈向盘子里放橘子\nvoid mother(){\n    while(true){\n        // code... 剥橘子\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // 放橘子\n        V(mutex); // 离开盘子\n        V(orange); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 爸爸向盘子里放苹果\nvoid mother(){\n    while(true){\n        // code... 削苹果\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // code... 放苹果\n        V(mutex); // 离开盘子\n        V(apple); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 儿子取橘子\nvoid son(){\n    while(true){\n        P(orange); // 等待一个橘子\n        P(mutex); // 等待其他人离开盘子\n        // code... 取橘子\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃橘子\n    }\n}\n\n// 女儿取苹果\nvoid daughter(){\n    while(true){\n        P(apple); // 等待一个苹果\n        P(mutex); // 等待其他人离开盘子\n        // code... 取苹果\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃苹果\n    }\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"如果盘子的容量小于等于1，可以不用设置专门的互斥信号量，也不会出现父亲和母亲同时往盘子里放水果的情况。如果盘子的容量大于1，则一定需要设置专门的互斥信号量，保证父亲和目前不会同时向盘子里放水果发生覆盖的情况。","loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":104}},"range":[2207,2311],"raw":"如果盘子的容量小于等于1，可以不用设置专门的互斥信号量，也不会出现父亲和母亲同时往盘子里放水果的情况。如果盘子的容量大于1，则一定需要设置专门的互斥信号量，保证父亲和目前不会同时向盘子里放水果发生覆盖的情况。"}],"loc":{"start":{"line":105,"column":0},"end":{"line":105,"column":104}},"range":[2207,2311],"raw":"如果盘子的容量小于等于1，可以不用设置专门的互斥信号量，也不会出现父亲和母亲同时往盘子里放水果的情况。如果盘子的容量大于1，则一定需要设置专门的互斥信号量，保证父亲和目前不会同时向盘子里放水果发生覆盖的情况。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"吸烟者问题","loc":{"start":{"line":107,"column":3},"end":{"line":107,"column":8}},"range":[2316,2321],"raw":"吸烟者问题"}],"loc":{"start":{"line":107,"column":0},"end":{"line":107,"column":8}},"range":[2313,2321],"raw":"## 吸烟者问题"},{"type":"Paragraph","children":[{"type":"Str","value":"eg. 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)","loc":{"start":{"line":109,"column":0},"end":{"line":109,"column":207}},"range":[2323,2530],"raw":"eg. 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)"}],"loc":{"start":{"line":109,"column":0},"end":{"line":109,"column":207}},"range":[2323,2530],"raw":"eg. 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore smoke_complete = 1; // 抽烟动作已经完成了\nsemaphore tobacco = 0; // 有烟草的消费者信号量\nsemaphore paper = 0; // 有纸的消费者信号量\nsemaphore glue = 0; // 有胶水的消费者信号量\nsemaphore mutex = 1; // 互斥信号量\n\n// 供应者\nvoid Provider(){\n    int type = 0;\n    while(true){\n        P(smoke_complete); // 等待抽烟完成\n        switch(type){\n            case 0:{\n                // code... 生产纸和胶水\n                P(mutex);\n                // code... 放入纸和胶水\n                V(tobacco); // 提醒有烟草的消费者\n                break;\n            };\n            case 1:{\n                // code... 生产烟草和胶水\n                P(mutex);\n                // code... 放入烟草和胶水\n                V(paper); // 提醒有纸的消费者\n                break;\n            };\n            case 2:{\n                // code... 生产纸和烟草\n                P(mutex);\n                // code... 放入纸和烟草\n                V(glue); // 提醒有胶水的消费者\n                break;\n            }\n        }\n        V(mutex);\n        type = (type+1)%3;\n    }\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithTabacco(){\n    P(tobacco); // 供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出胶水和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有纸的消费者\nvoid ConsumerWithPaper(){\n    P(paper); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出烟草和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithGlue(){\n    P(glue); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}","loc":{"start":{"line":111,"column":0},"end":{"line":180,"column":3}},"range":[2532,4071],"raw":"```c\nsemaphore smoke_complete = 1; // 抽烟动作已经完成了\nsemaphore tobacco = 0; // 有烟草的消费者信号量\nsemaphore paper = 0; // 有纸的消费者信号量\nsemaphore glue = 0; // 有胶水的消费者信号量\nsemaphore mutex = 1; // 互斥信号量\n\n// 供应者\nvoid Provider(){\n    int type = 0;\n    while(true){\n        P(smoke_complete); // 等待抽烟完成\n        switch(type){\n            case 0:{\n                // code... 生产纸和胶水\n                P(mutex);\n                // code... 放入纸和胶水\n                V(tobacco); // 提醒有烟草的消费者\n                break;\n            };\n            case 1:{\n                // code... 生产烟草和胶水\n                P(mutex);\n                // code... 放入烟草和胶水\n                V(paper); // 提醒有纸的消费者\n                break;\n            };\n            case 2:{\n                // code... 生产纸和烟草\n                P(mutex);\n                // code... 放入纸和烟草\n                V(glue); // 提醒有胶水的消费者\n                break;\n            }\n        }\n        V(mutex);\n        type = (type+1)%3;\n    }\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithTabacco(){\n    P(tobacco); // 供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出胶水和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有纸的消费者\nvoid ConsumerWithPaper(){\n    P(paper); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出烟草和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithGlue(){\n    P(glue); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n```"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"读者写者问题","loc":{"start":{"line":182,"column":3},"end":{"line":182,"column":9}},"range":[4076,4082],"raw":"读者写者问题"}],"loc":{"start":{"line":182,"column":0},"end":{"line":182,"column":9}},"range":[4073,4082],"raw":"## 读者写者问题"},{"type":"Paragraph","children":[{"type":"Str","value":"有读者和写者两组并发进程,共享一个文件","loc":{"start":{"line":184,"column":0},"end":{"line":184,"column":19}},"range":[4084,4103],"raw":"有读者和写者两组并发进程,共享一个文件"}],"loc":{"start":{"line":184,"column":0},"end":{"line":184,"column":19}},"range":[4084,4103],"raw":"有读者和写者两组并发进程,共享一个文件"},{"type":"Paragraph","children":[{"type":"Str","value":"当两个或两个以上的读进程同时访问共享数据时不会产生副作用","loc":{"start":{"line":186,"column":0},"end":{"line":186,"column":28}},"range":[4105,4133],"raw":"当两个或两个以上的读进程同时访问共享数据时不会产生副作用"}],"loc":{"start":{"line":186,"column":0},"end":{"line":186,"column":28}},"range":[4105,4133],"raw":"当两个或两个以上的读进程同时访问共享数据时不会产生副作用"},{"type":"Paragraph","children":[{"type":"Str","value":"但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。","loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":44}},"range":[4135,4179],"raw":"但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。"}],"loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":44}},"range":[4135,4179],"raw":"但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。"},{"type":"Paragraph","children":[{"type":"Str","value":"因此要求:","loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":5}},"range":[4181,4186],"raw":"因此要求:"}],"loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":5}},"range":[4181,4186],"raw":"因此要求:"},{"type":"Paragraph","children":[{"type":"Str","value":"① 允许多个读者可以同时对文件执行读操作;","loc":{"start":{"line":192,"column":0},"end":{"line":192,"column":21}},"range":[4188,4209],"raw":"① 允许多个读者可以同时对文件执行读操作;"}],"loc":{"start":{"line":192,"column":0},"end":{"line":192,"column":21}},"range":[4188,4209],"raw":"① 允许多个读者可以同时对文件执行读操作;"},{"type":"Paragraph","children":[{"type":"Str","value":"② 只允许一个写者往文件中写信息;","loc":{"start":{"line":194,"column":0},"end":{"line":194,"column":17}},"range":[4211,4228],"raw":"② 只允许一个写者往文件中写信息;"}],"loc":{"start":{"line":194,"column":0},"end":{"line":194,"column":17}},"range":[4211,4228],"raw":"② 只允许一个写者往文件中写信息;"},{"type":"Paragraph","children":[{"type":"Str","value":"③ 任一写者在完成写操作之前不允许其他读者或写者工作;","loc":{"start":{"line":196,"column":0},"end":{"line":196,"column":27}},"range":[4230,4257],"raw":"③ 任一写者在完成写操作之前不允许其他读者或写者工作;"}],"loc":{"start":{"line":196,"column":0},"end":{"line":196,"column":27}},"range":[4230,4257],"raw":"③ 任一写者在完成写操作之前不允许其他读者或写者工作;"},{"type":"Paragraph","children":[{"type":"Str","value":"④ 写者执行写操作前,应让已有的读者和写者全部退出","loc":{"start":{"line":198,"column":0},"end":{"line":198,"column":25}},"range":[4259,4284],"raw":"④ 写者执行写操作前,应让已有的读者和写者全部退出"}],"loc":{"start":{"line":198,"column":0},"end":{"line":198,"column":25}},"range":[4259,4284],"raw":"④ 写者执行写操作前,应让已有的读者和写者全部退出"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"读写公平法","loc":{"start":{"line":200,"column":4},"end":{"line":200,"column":9}},"range":[4290,4295],"raw":"读写公平法"}],"loc":{"start":{"line":200,"column":0},"end":{"line":200,"column":9}},"range":[4286,4295],"raw":"### 读写公平法"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int read_processes = 0; // 记录读进程的数量\nsemaphore rw = 1; // 对文件的互斥访问\nsemaphore mutex = 1; // 对read_processes互斥访问\nsemaphore w = 1; // 防止源源不断有读进程，导致写进程饿死\n\nvoid writer(){\n    while(true){\n        P(w); // 阻塞在这个写进程之后进入的读进程，防止这个进程被饿死\n        P(rw);\n        // 写文件...\n        V(rw);\n        V(w);\n    }\n}\n\nvoid reader(){\n    while(true){\n        P(w);\n        P(mutex);\n        if(read_processes==0) {\n            P(rw); // 第一个读\n        }\n        read_processes ++;\n        V(mutex);\n        V(w);\n        // 读文件...\n        P(mutex);\n        read_processes --;\n        if(read_processes==0) {\n            V(rw);\n        }\n        V(mutex);\n    }\n}","loc":{"start":{"line":202,"column":0},"end":{"line":237,"column":3}},"range":[4297,4944],"raw":"```c\nint read_processes = 0; // 记录读进程的数量\nsemaphore rw = 1; // 对文件的互斥访问\nsemaphore mutex = 1; // 对read_processes互斥访问\nsemaphore w = 1; // 防止源源不断有读进程，导致写进程饿死\n\nvoid writer(){\n    while(true){\n        P(w); // 阻塞在这个写进程之后进入的读进程，防止这个进程被饿死\n        P(rw);\n        // 写文件...\n        V(rw);\n        V(w);\n    }\n}\n\nvoid reader(){\n    while(true){\n        P(w);\n        P(mutex);\n        if(read_processes==0) {\n            P(rw); // 第一个读\n        }\n        read_processes ++;\n        V(mutex);\n        V(w);\n        // 读文件...\n        P(mutex);\n        read_processes --;\n        if(read_processes==0) {\n            V(rw);\n        }\n        V(mutex);\n    }\n}\n```"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"哲学家进餐问题","loc":{"start":{"line":239,"column":3},"end":{"line":239,"column":10}},"range":[4949,4956],"raw":"哲学家进餐问题"}],"loc":{"start":{"line":239,"column":0},"end":{"line":239,"column":10}},"range":[4946,4956],"raw":"## 哲学家进餐问题"},{"type":"Paragraph","children":[{"type":"Str","value":"eg. 圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。","loc":{"start":{"line":241,"column":0},"end":{"line":241,"column":164}},"range":[4958,5122],"raw":"eg. 圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。"}],"loc":{"start":{"line":241,"column":0},"end":{"line":241,"column":164}},"range":[4958,5122],"raw":"eg. 圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。"},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/15/TM1Rpi9Can5LWch.png","alt":"quicker_f8c93648-0bde-4db7-b210-1cdec60dee47.png","loc":{"start":{"line":243,"column":0},"end":{"line":243,"column":102}},"range":[5124,5226],"raw":"![quicker_f8c93648-0bde-4db7-b210-1cdec60dee47.png](https://i.loli.net/2020/08/15/TM1Rpi9Can5LWch.png)"}],"loc":{"start":{"line":243,"column":0},"end":{"line":243,"column":102}},"range":[5124,5226],"raw":"![quicker_f8c93648-0bde-4db7-b210-1cdec60dee47.png](https://i.loli.net/2020/08/15/TM1Rpi9Can5LWch.png)"},{"type":"Paragraph","children":[{"type":"Emphasis","children":[{"type":"Str","value":"如果每个哲学家都拿起了左边的一根筷子，可能会导致所有哲学家都在等自己右边的哲学家放下筷子，","loc":{"start":{"line":245,"column":1},"end":{"line":245,"column":46}},"range":[5229,5274],"raw":"如果每个哲学家都拿起了左边的一根筷子，可能会导致所有哲学家都在等自己右边的哲学家放下筷子，"},{"type":"Strong","children":[{"type":"Str","value":"导致死锁","loc":{"start":{"line":245,"column":48},"end":{"line":245,"column":52}},"range":[5276,5280],"raw":"导致死锁"}],"loc":{"start":{"line":245,"column":46},"end":{"line":245,"column":54}},"range":[5274,5282],"raw":"**导致死锁**"}],"loc":{"start":{"line":245,"column":0},"end":{"line":245,"column":55}},"range":[5228,5283],"raw":"*如果每个哲学家都拿起了左边的一根筷子，可能会导致所有哲学家都在等自己右边的哲学家放下筷子，**导致死锁***"}],"loc":{"start":{"line":245,"column":0},"end":{"line":245,"column":55}},"range":[5228,5283],"raw":"*如果每个哲学家都拿起了左边的一根筷子，可能会导致所有哲学家都在等自己右边的哲学家放下筷子，**导致死锁***"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"为了解决这个问题，可以规定","loc":{"start":{"line":247,"column":2},"end":{"line":247,"column":15}},"range":[5287,5300],"raw":"为了解决这个问题，可以规定"},{"type":"Strong","children":[{"type":"Str","value":"同时只有四个哲学家可以拿筷子","loc":{"start":{"line":247,"column":17},"end":{"line":247,"column":31}},"range":[5302,5316],"raw":"同时只有四个哲学家可以拿筷子"}],"loc":{"start":{"line":247,"column":15},"end":{"line":247,"column":33}},"range":[5300,5318],"raw":"**同时只有四个哲学家可以拿筷子**"},{"type":"Str","value":"，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。","loc":{"start":{"line":247,"column":33},"end":{"line":247,"column":98}},"range":[5318,5383],"raw":"，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。"}],"loc":{"start":{"line":247,"column":2},"end":{"line":247,"column":98}},"range":[5287,5383],"raw":"为了解决这个问题，可以规定**同时只有四个哲学家可以拿筷子**，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。"}],"loc":{"start":{"line":247,"column":0},"end":{"line":247,"column":98}},"range":[5285,5383],"raw":"- 为了解决这个问题，可以规定**同时只有四个哲学家可以拿筷子**，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。"}],"loc":{"start":{"line":247,"column":0},"end":{"line":247,"column":98}},"range":[5285,5383],"raw":"- 为了解决这个问题，可以规定**同时只有四个哲学家可以拿筷子**，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore eating_philosopher = 4; // 可以吃饭的哲学家数量\n\nvoid philosopher(int i){ // i代表哲学家的编号\n    P(eating_philosopher); // 等待取筷子的权限\n    P(chopsticks[i]); // 等待取左边的筷子\n    P(chopsticks[(i+1)%5]); // 等待取右边的筷子\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]); // 放下筷子\n    V(eating_philosopher); // 放弃吃饭的权限，让给其他哲学家\n    // code... 思考\n}","loc":{"start":{"line":249,"column":0},"end":{"line":263,"column":3}},"range":[5385,5788],"raw":"```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore eating_philosopher = 4; // 可以吃饭的哲学家数量\n\nvoid philosopher(int i){ // i代表哲学家的编号\n    P(eating_philosopher); // 等待取筷子的权限\n    P(chopsticks[i]); // 等待取左边的筷子\n    P(chopsticks[(i+1)%5]); // 等待取右边的筷子\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]); // 放下筷子\n    V(eating_philosopher); // 放弃吃饭的权限，让给其他哲学家\n    // code... 思考\n}\n```"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。","loc":{"start":{"line":267,"column":2},"end":{"line":267,"column":91}},"range":[5794,5883],"raw":"对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。"}],"loc":{"start":{"line":267,"column":2},"end":{"line":267,"column":91}},"range":[5794,5883],"raw":"对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。"}],"loc":{"start":{"line":267,"column":0},"end":{"line":267,"column":91}},"range":[5792,5883],"raw":"- 对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。"}],"loc":{"start":{"line":267,"column":0},"end":{"line":267,"column":91}},"range":[5792,5883],"raw":"- 对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量 \n\nvoid philosopher(int i){\n    if(i%2==0){\n        P(chopsticks[i]);\n        P(chopsticks[(i+1)%5]);\n    }\n    else{\n        P(chopsticks[(i+1)%5]);\n        P(chopsticks[i]);\n    }\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n}","loc":{"start":{"line":269,"column":0},"end":{"line":285,"column":3}},"range":[5885,6197],"raw":"```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量 \n\nvoid philosopher(int i){\n    if(i%2==0){\n        P(chopsticks[i]);\n        P(chopsticks[(i+1)%5]);\n    }\n    else{\n        P(chopsticks[(i+1)%5]);\n        P(chopsticks[i]);\n    }\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n}\n```"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁","loc":{"start":{"line":287,"column":2},"end":{"line":287,"column":38}},"range":[6201,6237],"raw":"只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁"}],"loc":{"start":{"line":287,"column":2},"end":{"line":287,"column":38}},"range":[6201,6237],"raw":"只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁"}],"loc":{"start":{"line":287,"column":0},"end":{"line":287,"column":38}},"range":[6199,6237],"raw":"- 只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁"}],"loc":{"start":{"line":287,"column":0},"end":{"line":287,"column":38}},"range":[6199,6237],"raw":"- 只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁"},{"type":"CodeBlock","lang":"c","meta":null,"value":"semaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore mutex = 1; // 只有一个哲学家拿到两根筷子，其他哲学家才能开始拿筷子\n\nvoid philosopher(int i){\n    P(mutex);\n    P(chopsticks[i]);\n    P(chopsticks[(i+1)%5]);\n    V(mutex);\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n    // code... 思考\n}","loc":{"start":{"line":289,"column":0},"end":{"line":303,"column":3}},"range":[6239,6543],"raw":"```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore mutex = 1; // 只有一个哲学家拿到两根筷子，其他哲学家才能开始拿筷子\n\nvoid philosopher(int i){\n    P(mutex);\n    P(chopsticks[i]);\n    P(chopsticks[(i+1)%5]);\n    V(mutex);\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n    // code... 思考\n}\n```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":305,"column":0}},"range":[0,6545],"raw":"---\ntitle: '经典同步问题'\ntags: ['操作系统','进程同步']\n---\n# 经典同步问题\n\n## 生产者消费者问题\n\n系统中有一组生产者进程和一组消费者进程，生产者每一次放一个产品到缓冲区，消费者每一次从缓冲区取出一个产品。生产者和消费者进程共享一个初始为空，长度为n的缓冲区。\n\n- 只有缓冲区没有满的时候，生产者进程才可以向缓冲区放如产品\n- 只有缓冲区不为空的时候，消费者进程才可以从缓冲区取出产品\n- 缓冲区属于临界资源，各个进程的访问应该是互斥的\n\n### 使用信号量机制来解决生产者和消费者问题\n\n```c\nsemphore SemCache = 1; // 缓冲区互斥访问\nsemphore SemRead = 0; // 读信号量\nsemphore SemWrite = n; // 写信号量，n为缓冲区大小\n\n// 生产者的逻辑\nvoid Productor(){\n    // code... 生产者生产产品\n    P(SemWrite); // wait原语，等待缓冲区空闲\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到写入缓冲区的权限之后，否则会产生死锁\n    // code... 生产者写入产品的语句\n    V(SemCache); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    V(SemRead); // signal原语，唤醒一个读缓冲区的消费者进程\n}\n// 消费者的逻辑\nvoid Consumer(){\n    P(SemRead); // wait原语，等待读缓冲区\n    P(SemCache); // wait原语，等待访问缓冲区，只能放在得到读取缓冲区的权限之后，否则会产生死锁\n    // code... 消费者读取产品的语句\n    V(SemCache); // signal原语，唤醒一个等待要读取缓冲区的消费者进程\n    V(SemWrite); // signal原语，唤醒一个等待写入缓冲区的生产者进程\n    // code... 消费者使用产品\n}\n```\n\n生产者生产产品和消费者使用产品的代码最好放在临界区外，这样可以减少临界区的代码量，缩短临界区执行时间，提高系统资源的利用率和并发度。\n\n### 多（类）生产者多（类）消费者模型\n\n 生产者、消费者问题中存在不同的生产者生产不同的产品，不同的消费者使用不同的产品的时候就是**多生产者多消费者问题**。\n\n> eg. 桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。\n\n```c\nsemaphore apple = 0; // 盘子里的苹果数量\nsemaphore orange = 0; // 盘子里的橘子数量\nsemaphore saucer = 1; // 盘子的剩余容量\nsemaphore mutex = 0; // 正在有人访问盘子\n\n// 妈妈向盘子里放橘子\nvoid mother(){\n    while(true){\n        // code... 剥橘子\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // 放橘子\n        V(mutex); // 离开盘子\n        V(orange); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 爸爸向盘子里放苹果\nvoid mother(){\n    while(true){\n        // code... 削苹果\n        P(saucer); // 等待盘子空\n        P(mutex); // 等待其他人离开盘子\n        // code... 放苹果\n        V(mutex); // 离开盘子\n        V(apple); // 告诉消费者橘子的数量增加了一个\n    }\n}\n\n// 儿子取橘子\nvoid son(){\n    while(true){\n        P(orange); // 等待一个橘子\n        P(mutex); // 等待其他人离开盘子\n        // code... 取橘子\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃橘子\n    }\n}\n\n// 女儿取苹果\nvoid daughter(){\n    while(true){\n        P(apple); // 等待一个苹果\n        P(mutex); // 等待其他人离开盘子\n        // code... 取苹果\n        V(mutex); // 离开盘子\n        V(saucer); // 告诉生产者盘子现在是空的\n        // code... 吃苹果\n    }\n}\n```\n\n如果盘子的容量小于等于1，可以不用设置专门的互斥信号量，也不会出现父亲和母亲同时往盘子里放水果的情况。如果盘子的容量大于1，则一定需要设置专门的互斥信号量，保证父亲和目前不会同时向盘子里放水果发生覆盖的情况。\n\n## 吸烟者问题\n\neg. 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它,但是要卷起并抽掉一支烟,抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中,第一个拥有烟草第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料,供应者每次将两种材料放桌子上,拥有剩下那种材料的抽烟者卷一根烟并抽掉它,并给供应者进程一个信号告诉完成了,供应者就会放另外两种材料再桌上,这个过程一直重复(让三个抽烟者轮流地抽烟)\n\n```c\nsemaphore smoke_complete = 1; // 抽烟动作已经完成了\nsemaphore tobacco = 0; // 有烟草的消费者信号量\nsemaphore paper = 0; // 有纸的消费者信号量\nsemaphore glue = 0; // 有胶水的消费者信号量\nsemaphore mutex = 1; // 互斥信号量\n\n// 供应者\nvoid Provider(){\n    int type = 0;\n    while(true){\n        P(smoke_complete); // 等待抽烟完成\n        switch(type){\n            case 0:{\n                // code... 生产纸和胶水\n                P(mutex);\n                // code... 放入纸和胶水\n                V(tobacco); // 提醒有烟草的消费者\n                break;\n            };\n            case 1:{\n                // code... 生产烟草和胶水\n                P(mutex);\n                // code... 放入烟草和胶水\n                V(paper); // 提醒有纸的消费者\n                break;\n            };\n            case 2:{\n                // code... 生产纸和烟草\n                P(mutex);\n                // code... 放入纸和烟草\n                V(glue); // 提醒有胶水的消费者\n                break;\n            }\n        }\n        V(mutex);\n        type = (type+1)%3;\n    }\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithTabacco(){\n    P(tobacco); // 供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出胶水和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有纸的消费者\nvoid ConsumerWithPaper(){\n    P(paper); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出烟草和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n\n// 拥有烟草的消费者\nvoid ConsumerWithGlue(){\n    P(glue); // 等待供应者提醒\n    P(mutex); // 等待其他人离开缓冲区\n    // code... 取出和纸\n    V(smoke_complete); // 告诉供应者产品已经被取走\n    V(mutex); // 离开缓冲区\n    // code... 卷烟、吸烟\n}\n```\n\n## 读者写者问题\n\n有读者和写者两组并发进程,共享一个文件\n\n当两个或两个以上的读进程同时访问共享数据时不会产生副作用\n\n但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。\n\n因此要求:\n\n① 允许多个读者可以同时对文件执行读操作;\n\n② 只允许一个写者往文件中写信息;\n\n③ 任一写者在完成写操作之前不允许其他读者或写者工作;\n\n④ 写者执行写操作前,应让已有的读者和写者全部退出\n\n### 读写公平法\n\n```c\nint read_processes = 0; // 记录读进程的数量\nsemaphore rw = 1; // 对文件的互斥访问\nsemaphore mutex = 1; // 对read_processes互斥访问\nsemaphore w = 1; // 防止源源不断有读进程，导致写进程饿死\n\nvoid writer(){\n    while(true){\n        P(w); // 阻塞在这个写进程之后进入的读进程，防止这个进程被饿死\n        P(rw);\n        // 写文件...\n        V(rw);\n        V(w);\n    }\n}\n\nvoid reader(){\n    while(true){\n        P(w);\n        P(mutex);\n        if(read_processes==0) {\n            P(rw); // 第一个读\n        }\n        read_processes ++;\n        V(mutex);\n        V(w);\n        // 读文件...\n        P(mutex);\n        read_processes --;\n        if(read_processes==0) {\n            V(rw);\n        }\n        V(mutex);\n    }\n}\n```\n\n## 哲学家进餐问题\n\neg. 圆桌上坐着5名哲学家,每两个哲学家之间的桌上摆一根筷子,桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐,哲学家在思考时,并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子(一根一根地拿起)。如果筷子已在他人手上,则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐,当进餐完毕后,放下筷子继续思考。\n\n![quicker_f8c93648-0bde-4db7-b210-1cdec60dee47.png](https://i.loli.net/2020/08/15/TM1Rpi9Can5LWch.png)\n\n*如果每个哲学家都拿起了左边的一根筷子，可能会导致所有哲学家都在等自己右边的哲学家放下筷子，**导致死锁***\n\n- 为了解决这个问题，可以规定**同时只有四个哲学家可以拿筷子**，这样就可以保证至少有一个哲学家可以拿到两根筷子开始吃饭，吃完饭之后，它左边的哲学家就可以开始吃饭，最后所有的哲学家都可以吃到饭。\n\n```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore eating_philosopher = 4; // 可以吃饭的哲学家数量\n\nvoid philosopher(int i){ // i代表哲学家的编号\n    P(eating_philosopher); // 等待取筷子的权限\n    P(chopsticks[i]); // 等待取左边的筷子\n    P(chopsticks[(i+1)%5]); // 等待取右边的筷子\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]); // 放下筷子\n    V(eating_philosopher); // 放弃吃饭的权限，让给其他哲学家\n    // code... 思考\n}\n```\n\n\n\n- 对于奇数号的哲学家，优先拿自己左边的筷子，偶数号的哲学家优先拿右边的筷子，这样相邻的两个哲学家会争抢同一根筷子，没有抢到筷子的哲学家会直接阻塞。避免了占有一致后等待另一支的情况。\n\n```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量 \n\nvoid philosopher(int i){\n    if(i%2==0){\n        P(chopsticks[i]);\n        P(chopsticks[(i+1)%5]);\n    }\n    else{\n        P(chopsticks[(i+1)%5]);\n        P(chopsticks[i]);\n    }\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n}\n```\n\n- 只有一个哲学家拿到两根筷子之后，才会允许其他哲学家拿起筷子，避免产生死锁\n\n```c\nsemaphore chopsticks[5] = {1,1,1,1,1}; // 对5根筷子设置信号量\nsemaphore mutex = 1; // 只有一个哲学家拿到两根筷子，其他哲学家才能开始拿筷子\n\nvoid philosopher(int i){\n    P(mutex);\n    P(chopsticks[i]);\n    P(chopsticks[(i+1)%5]);\n    V(mutex);\n    // code... 吃饭\n    V(chopsticks[i]);\n    V(chopsticks[(i+1)%5]);\n    // code... 思考\n}\n```\n\n"},"catalogue":{"title":"经典同步问题","json-path":"2020-08-15-经典同步问题.json","mdate":"2022-08-30T14:19:31.454Z","tags":["操作系统","进程同步"]}}