---
tags: ['数据结构','图']
---
# 最短路径

## Dijkstra算法（带权图单源最短路径）

主要的思想也是**贪心算法**。

需要如下的三个辅助数组：

- s[]: 用于标记已经计算完成的顶点。
  数组中值全部初始化为0，已经完成计算的顶带你对应下表的值标记为1
- dist[]: 记录从源点  $v_{0}$  到其他各个顶点的最短路径的长度。
  数组中的值全部初始化为源点到各个顶点边的权值，即 $dist[i]=arcs[0][i]$ 
- path[]: 记录从最短路径中顶点的前驱顶点，即path[i]为 $v \rightarrow v_{i}$ 
最短路径上 $v_{i}$ 的前驱顶点。
  初始化：若源点 $v_{0}$ 到该顶点 $v_{i}$ 有一条有向边（无向边），令path[i]=0；否则令path[i]=-1。

算法步骤：

1. 初始化数组，集合S初始化为{0};
2. 从未计算过的顶点集V-S中选出 $V_{j}$ 满足： $dist[j] = Min\{dist[i] \lvert v_{i} \in V-S\}$ ， $v_{j}$ 就是当前求得的最短路径的终点，使 $S = S \cup \{j\}$ ;
3. 修改此时从 $v_{0}$ 出发到集合V-S上各个顶点 $v_{k}$ 最短路径的长度：若 $dist[j]+arcs[j][k]<dist[k]$ ，则令 $dist[k] = dist[j] + arcs[j][k]$ ;  $path[k] = j$ 。

```c
#define MAX 999999 // MAX代表无穷大

void Dijkstra(Graph G, int v){
    // 初始化辅助数组
    int s[G.vexnum], path[G.vexnum], dist[G.vexnum];
    for(int i=0; i<G.vexnum; i++){
        s[i] = 0;
        dist[i] = G.Edge[v][i];
        path[i] = G.Edge[v][i] < MAX ? v : -1;
    }
    s[v] = 1;
    path[v] = -1;
    // 在未计算过的顶点中寻找路径最短的顶点
    for(int i=0; i<G.vexnum; i++){
        int min = MAX, u;
        for(int j=0; j<G.vexnum; j++){
            if(s[j]==0 && dist[j] < min){
                min = dist[j];
                u = j;
            }
        }
        s[u] = 1; // 标记未已经计算过的顶点
        // 修改从源点到其他各个顶点的路径长度
        for(int j=0; j<G.vexnum; j++){
            if(s[j]==0&&dist[u]+G.Edge[u][j]<dist[j]){
                dist[j]=dist[u]+G.Edge[u][i];
                path[j]=u;
            }
        }
    }
}
```

代码中由两个次数均为图G的顶点数目嵌套的二重循环构成，所以Dijkstra算法的时间复杂度是 $O(\lvert V \rvert ^ {2})$ 。

由于Dijkstra算法是每一步都选择路径最短的顶点，**只适用于随着路径上顶点数目变多，路径长度越长的图（即所有边的权值都为正值）**，如果图中含有权值为负值的边，则可能不适用此算法。

例如如下的图， $0 \rightarrow 1 \rightarrow 2$  路径长度就比  $0 \rightarrow 2$ 的路径短，但是第一步时算法就会选择 $2$ ，根本无法得到路径  $0 \rightarrow 1 \rightarrow 2$ ：

![PNG图像.png](https://i.loli.net/2020/08/03/PF8gDAwTuaJrzI9.png)

## Floyd（各顶点之间的最短路径）

算法思想（动态规划）：

递推产生一个n阶方阵序列 $A^{(-1)}, A^{(0)}, ... , A^{(k)}, ... , A^{(n-1)} $ ，

 $A^{(k)}[i][j]$ : 顶点 $v_{i}$ 到 $v_{j}$ 的最短路径长度，且该路径经过的顶点编号不大于k。

递推公式：

初始化： $A^{(-1)}[i][j]=arcs[i][j]$ 

递推方法： $A^{(k)}[i][j]=min\\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\\}, k=0,1,...,n-1$ ，其中 $A^{(k-1)}[i][k]$ 就是从起始顶点到顶点k的路径， $A^{(k-1)}[k][j]$ 就是从顶点k到目标顶点j的路径长度，二者相加就是加入顶点k后，从起始顶点到顶点k再到顶点j的路径长度，将其与原来从起始顶点到顶点j的路径相比较，取较小的那一个。

```c
#define VEXNUM 10

void Floyd(Graph G){
    int A[VEXNUM][VEXNUM];
    // 初始化
    for(int i=0; i<VEXNUM; i++){
        for(int j=0; i<VEXNUM; j++){
            A[i][j] = G.Edge[i][j];
        }
    }
    // 递推
    for(int k=0; k<VEXNUM; k++){
        for(int i=0; i<VEXNUM; i++){
            for(int j=0; j<VEXNUM; j++){
                if(A[i][j] > A[i][k] + A[k][j]) A[i][j] = A[i][k] + A[k][j];
            }
        }
    }
}
```

Floyd算法的时间复杂度是 $O(\lvert V \rvert ^ {3})$ ，可以算出任意两个结点之间的最短路径，且可以包含负值。
