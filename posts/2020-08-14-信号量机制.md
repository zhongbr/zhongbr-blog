---
title: '信号量机制'
tags: ['操作系统','信号量']
---
# 信号量机制

进程互斥的四种软件实现方式（单标志法、双标志法、双标志后检查法、Peterson算法）和三种硬件实现方式（中断屏蔽、TSL指令和SWAP指令）。

以上的所有方式都没有遵循“让权等待”原则，在无法进入临界区时，也不会把CPU资源让给其他进程。

- 信号量机制：用户进程可以通过**操作系统提供的一对原语**，来对信号量进行操作，方便地实现了进程之间地互斥和同步。

  信号量其实是一个变量，可以用一个信号量来描述系统中某种资源地数量（比如一台打印机就可以设置一个初值为1地信号量）。

wait(S)原语和signal(S)原语，两个操作可以分别写为P(S)和V(s)。

## 整型信号量

用一个整数来表示系统某种资源的数量。

与普通的整型变量相比，整型信号量只能进行初始化、P操作和V操作。

```c
int S=1; // 系统中某种资源数

// wait原语的逻辑
void wait(int S){
    while(S<=0);
    S--;
}
// signal原语的逻辑
void signal(int S){
    S++;
}

// 使用信号量的逻辑
// 进程P0
wait(S); // 进入区
// 临界区代码
signal(S); // 退出区
```

 缺点：不满足“让权等待”原则

## 记录型信号量

用记录型数据解雇表示信号量，可以解决整型信号量存在的“忙等”的问题。

```c
//记录型信号量
typedef struct {
    int value;	// 剩余资源数
    struct process *L; // 等待的资源
} semphore;
// wait原语
void wait(semaphore S){
    S.value --;
    if(S.value < 0) block(S.L); // 剩余的资源数不够，使用block原语把当前的进程阻塞
}
void signal(semaphore S){
    s.value++;
    if(S.value <= 0) wakeup(S.L); // 说明在释放资源之前，还有进程在等待使用这个资源
}
```

优点：遵循了“让权等待”原则

## 信号量进制实现进程互斥

1. 分析并发进程的关键活动、划定临界区
2. 设置互斥信号量mutex，初始值为1
3. 在临界区之前对信号量mutex执行P操作
4. 在临界区之后对信号量mutex执行V操作

对于不同的临界资源，需要设置**不同的互斥信号量**

## 信号量机制实现进程同步

进程同步：让各个进程有序地推进

1. 分析需要实现同步关系的位置
2. 设置同步信号量S，初始值为0
3. 在“前操作”之后执行V操作（前操作执行完成，唤醒后操作）
4. 在“后操作”之前执行P操作（前操作还未执行就会将后操作阻塞）

```c
semaphore S=0;

// 前操作
P1(){
    // 前操作代码
    V(S); // signal原语，唤醒后操作进程
    // 剩余代码
}

// 后操作
P2(){
    P(S); // wait原语，检查前操作是否完成了
    // 后操作代码
   	// 剩余代码
}
```

## 信号量机制实现进程的前驱关系

![quicker_283a6535-3b5b-4f96-a2ae-42da1a3153bd.png](https://i.loli.net/2020/08/14/61DyjLnH9xqXtP2.png)

各个进程要按照如上图所示的顺序来执行。其中每一对前驱关系都是一种进程同步关系，所以：

1. 为每一对前驱关系各设置一个同步信号量
2. 在“前操作”之后对相应的同步信号量执行V操作
3. 在“后操作”之前对相应的同步信号量执行P操作

```c
// 定义信号量
semaphore s1s2 = 0;
semaphore s1s3 = 0;
semaphore s2s4 = 0;
semaphore s2s5 = 0;
semaphore s3s6 = 0;
semaphore s4s6 = 0;
semaphore s5s6 = 0;

P1(){
    S1;
    V(s1s2);
    V(s1s3);
}
P2(){
    P(s1s2);
    S2;
    V(s2s4);
    V(s2s5);
}
P3(){
    P(s1s3);
    S3;
    V(s3s6);
}
P4(){
    P(s2s4);
    S4;
    V(s4s6);
}
P5(){
    P(s2s5);
    S5;
    V(s5s6);
}
P6(){
    P(s5s6);
    P(s3s6);
    P(s4s6);
    S6;
}
```

