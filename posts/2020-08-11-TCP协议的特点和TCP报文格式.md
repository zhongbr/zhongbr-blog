---
title: 'TCP协议'
tags: ['计算机网路','传输层','TCP']
---
# TCP协议的特点和TCP报文格式

*****

## 特点

1. 面向连接（虚连接）的传输层协议
2. 每一条TCP连接只能是点对点的
3. TCP可以提供可靠的交付服务，无差错，不丢失、不重复、按照顺序到达
4. 可以提供全双工通信
   - 发送缓存：准备发送的数据 & 已发送但尚未收到确认的数据 的队列
   - 接收缓存：按序到达但未被接收应用程序读取的数据 & 不按序到达的数据
5. 面向字节流：TCP把应用程序交下来的数据仅仅看成是一连串无结构的字节流

### RTT估计方法

 $新估计RTT=(1-\alpha) * (旧RTT) + \alpha*新RTT样本$ 

*****

## 首部格式

![截屏 2020-08-11 下午4.11.16.png](https://i.loli.net/2020/08/11/YzRPSbdorQX2fsy.png)

- 源端口、目的端口：一个占用两个字节
- 序号：在一个TCP连接中，传送的字节流中的每一个字节都按照顺序编号，本字段表示本报文段所发送的数据的第一个字节的序号。
- 确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，证明到序号N-1为止的数据都已经正确接收。
- 数据便宜（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4字节为单位，即1个数为4字节。
- 控制位：
  - URG紧急位：URG=1时，表明此报文段有紧急数据，是高优先级的数据，应该尽快传送，不用在缓存里排队，配合紧急指针字段使用
  - ACK确认位：ACK=1时确认号有效，在连接建立后所有的传送都必须把ACK置位1
  - PSH推送位：PSH=1时接收方应该尽快交付给接收应用进程，不再等到缓存填满再向上交付
  - RST复位：RST=1时表明TCP连接中出现严重的差错，必须释放连接，然后重新建立传输连接
  - SYN同步位：SYN=1时，表明是一个连接请求/连接接受报文
  - FIN终止位：FIN=1时，表明此报文段发送方的数据已经发送完，要求释放连接
- 窗口：指的是发送本报文段的一方的接收窗口（自己的接收窗口），即现在允许接收的数据量
- 检验和：检验首部+数据部分，检验时要加上12B的伪首部，第四个字段为6
- 紧急指针：URG紧急位=1时才有意义，指出本报文段中紧急数据的字节数，从数据部分开始位到紧急指针的位是紧急数据，剩下的数据是普通数据。
- 选项：最大报文段长度MSS、窗口扩大、时间戳、选择确认等

*****

## TCP连接管理

TCP建立连接的三个阶段：

### 连接建立

TCP连接的建立采用客户服务器方式，主动发起连接的应用进程叫做客户端，被动等待连接的应用进程叫做服务器。

![截屏 2020-08-11 下午5.08.44.png](https://i.loli.net/2020/08/11/H2YG8nSjok7PZs5.png)

1. 客户端发送连接请求报文段，无应用层数据

   SYN = 1, 序号seq = x[随机]

2. 服务器端为该TCP连接分配缓存和变量，并向客户端回复确认报文段，允许连接，无应用层数据。

   SYN = 1, ACK=1, seq=y[随机], ack=x+1

3. 客户端为该TCP连接分配缓存和变量，并向服务器端回复确认的确认，可以携带数据。

   ACK = 1, seq=x+1, ack=y+1

#### SYN洪泛攻击

SYN洪泛攻击发生在OSI第四层,这种方式利用TCP协议的特性,就是三次握手。攻击者发送TCP SYN,SYN是TCP三次握手中的**第一个数据包**，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上,这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。

解决SYN洪泛攻击的方法是设置SYN cookie

### 连接释放

参与一条TCP连接的两个进程中的任何一个都能终止该进程，连接结束后，主机中的资源（缓存和变量）将被释放。

![截屏 2020-08-11 下午5.21.08.png](https://i.loli.net/2020/08/11/RmExnKFqW15vsc2.png)

- 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接
  
  FIN = 1, seq = u

- 服务器回送一个确认报文段，客户端服务器这个方向的连接就释放了，处于半关闭的状态

  ACK = 1, seq = v, ack = u+1

- 服务器端发完数据，就发出连接释放报文段，主动关闭TCP连接

  FIN = 1, ACK = 1, seq = w, ack = u+1

- 客户端回复一个确认报文段，等到等待倒计时设置的2MSL（最长报文段寿命）后，连接彻底关闭（避免本报文段丢失导致服务器端连接一直得不到释放）
  
  ACK = 1, seq = u+1, ack = w+1

### 数据传送

#### TCP 可靠传输

可靠：保证接收方进程从缓存中读取的字节流于发送方发出的字节流完全一样

##### TCP实现可靠传输的机制

###### 校验

与UDP校验相同，引入了伪首部

###### 序号

序号字段指的是一个报文段中第一个字节的序号。

###### 确认

采用累积确认机制，确认报文段内的确认号字段为接收方期待的下一个字节的序号

冗余ACK：每当收到比期望序号大的报文段时，发送一个冗余ACK，指明下一个希望收到的字节的序号

###### 重传

超时重传：确认和重传是不分家的，TCP在**规定的时间（重传时间）**内没有收到确认，就会重传已发送但是未确认的报文段。

TCP采用自适应算法，动态确定重传时间RTTs（加权平均往返时间）。

快速重传：发送方收到**冗余ACK**之后，重新发送丢失的报文段

*****

## TCP流量控制

让发送方发慢点，使接收方可以来得及接收，使用**滑动窗口的机制**来实现流量控制。

通信过程中，接收方根据自己的接收缓存大小，动态调整发送方发送窗口的大小，发送方的发送窗口大小取接收方接收窗口rwnd和拥塞窗口的最小值。

TCP为每一个连接都设有持续计时器，只要TCP连接一方接收到另一方零窗口通知，就会启动持续计时器。

如果持续计时器到期，就发送一个零窗口探测报文段，接收方收到探测报文段后，就会回复当前接收方的接收窗口的值。如果窗口值仍然是0，发送方就重新设置持续计时器，否则发送方继续发送数据。

*****

## TCP拥塞控制

出现拥塞的条件：

对资源需求的总和 > 可以用的资源

网路中资源呈现供应不足  $\Rrightarrow$  网路性能变坏  $\Rrightarrow$  由于重发等引起网络的负荷增大  $\Rrightarrow$  网络吞吐量下降   $\Rrightarrow$  网络资源供应更加不足。

### 拥塞控制的四种算法

假定:
1. 数据单方向传送,而另一个方向只传送确认
2. 接收方总是有足够大的缓存空间,因而发送窗口大小取决于拥塞程度
   

发送窗口=Min{接收窗口rwnd,拥塞窗口cwnd}

接收窗口：接收方根据接受缓存设置的值,并告知给发送方,反映接收方容量。
拥塞窗口：发送方根据自己估算的网络拥塞程度而设置的窗口值,反映网络当前容量。

*****

#### 慢开始和 拥塞避免

![截屏 2020-08-11 下午8.20.00.png](https://i.loli.net/2020/08/11/tYRL6yS1vHOUB5P.png)

开始时采用指数增长注入数据报的数量，达到ssthresh时，为了避免网络拥塞，使用“假发增大”，发生网络拥塞的时候，将当前的窗口数量除以2，作为新的门限值ssthresh，将拥塞窗口调整到1，继续执行慢开始。

调整拥塞窗口数量的时机：收到接收方的确认的时候，调整拥塞窗口的数量

*****

#### 快重传和快恢复

![截屏 2020-08-11 下午8.28.31.png](https://i.loli.net/2020/08/11/NKETm21jwAVsDUo.png)

在收到接收方的冗余ACK时，不用将拥塞窗口降到1，而是降到新的门限值。
