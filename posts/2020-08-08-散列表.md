---
title: '散列表'
tags: ['数据结构','散列表','查找']
---
# 散列表

散列表：根据关键字直接进行访问的数据结构。它建立了关键字与存储地址之间的一种直接映射关系。

## 1. 散列函数

散列函数：把查找表中的关键字映射成该关键字对应的地址的函数。

### 1.1 散列函数的要求

1. 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。
2. 散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的产生。
3. 散列函数应该尽量简单，能够在短时间内计算出任何一个关键字对应的地址

### 1.2 散列函数的构造方法

#### 1.2.1 直接定址法

直接取关键字的某个线性函数的散列地址

优点：

- 方法简单，不会产生冲突

缺点：

- 关键字分布不连续的时候会浪费空间

#### 1.2.2 除留取余法

$Hash(key)=key\%p$，选p是除留取余法的关键，选取一个大于或等于散列表表长m的最大的质数作为p。

#### 1.2.3 数字分析法

选取关键字中等概率均匀出现的一位或者多位作为散列函数的依据，适用于关键字已知的集合，若更换关键字就需要重新设计散列函数。

#### 1.2.4 平方取中法

取关键字的平方的中间几位数作为散列地址，适用于关键字的每位取值不均匀或均小于散列地址所需要的位数时。

#### 1.2.5 折叠法

将关键字分割为位数相同的几个部分，然后取这几个部分的叠加和作为散列地址。

适用于关键字的位数多，且关键字每位数分布均匀的情况。

*****

## 2. 冲突

冲突：散列函数可能存在把多个值映射到同一个地址的可能。

### 2.1 开放定址法

可存放新表项的空闲地址既向它的同义词表开放，又向它的非同义词表开放。

$H_{i}=(H(key)+d_{i})\%m,i=0,1,2,...,k(k \leq m-1)$; m为散列表表长，$d_{i}$为增量序列。

#### 2.1.1 增量序列的计算方法

##### 2.1.1.1 线性探查法

$d_{i} = 0,1,2,3,...,m-1$

存储时：使用散列函数对关键字计算地址后，如果对应的位置上已经存放了值，尝试下一个地址，以此类推。

查找时：用散列函数计算要查找的关键字的散列值，查看散列表对应的值是否是要查找的关键字，如果不是就比较下一个，以此类推，直到于要查找的关键字相等或者查找到空闲位置为止。

###### 缺点

存在堆积现象，大大降低查找效率

##### 2.1.1.2 平方探测法

$d_{i}=0^{2}, 1^{2}, -1^{2}, 2^{2}, -2^{2},..., k^{2}, -k^{2}$，其中$k \leq m/2$

可以避免堆积问题，缺点是不能探测到散列表的所有单元（至少可以探测到一半的单元）

##### 2.1.1.3 再散列法

$d_{i}=i*Hash2(key)$

##### 2.1.1.4 伪随机序列法

$d_{i}=伪随机序列$

<font color="red">开放定址法不能随意删除表项，否则可能造成其他表项查找失败。</font>

### 2.2 拉链法

把所有的同义词存放在一个线性链表中，这个线性链表由地址唯一标识，即散列表中的每个单元存放该链表头指针。

适用于经常插入和删除的情况，会增加指针域，占用空间。

*****

## 3 查找

### 3.1 查找效率

与散列函数、处理冲突和填装因子有关

填装因子$\alpha = \frac{表中记录数n}{散列表长度m}$
