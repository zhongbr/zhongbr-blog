---
title: '线程、多线程模型'
tags: ['操作系统','线程']
---
# 线程、多线程模型

引入线程之前，进程是程序流执行的最小单位

引入线程之后，进程中的线程就成为了操作系统程序执行流的最小单位

线程可以理解为“轻量级的进程”。线程是基本的CPU执行单元，也是程序执行流的最小单位。引入线程后，不仅是进程之间可以并发，进程内的各个线程也可以并发，提高了系统的并发度，使得**每一个进程内也能并发处理各种任务**。

引入线程后，进程只作为除了CPU之外的系统资源的分配单元（如打印机、内存地址空间等是分配给进程的）。

*****

## 引入线程带来的变化

### 资源分配、调度

在传统的进程机制中，进程是资源分配、调度的基本单位
引入线程后，进程是资源分配的基本单位，线程是调度的基本的单位

### 并发性

传统的进程机制中，只能在进程间并发
引入线程后，各线程之间也可以并发，提高了并发度

### 系统开销

传统进程机制中，切换进程需要切换进程的运行环境，系统的开销是比较大的
引入线程之后，如果是同一进程的线程之间切换，不需要切换进程的环境，系统的开销比较小，所以引入线程之后，系统并发所带来的系统开销比较小。

*****

## 线程的属性

- 线程是处理机调度的基本单位
- 多CPU计算机中，各个线程可以占用不同的CPU
- 每个线程都有一个线程ID、线程控制块（TCB，Thread Control Block）
- 线程也有就绪、阻塞和运行三种状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程共享进程的资源
- 同一进程的不同线程之间通信无需系统干预
- 同一进程的线程切换不会引起进程的切换
- 不同进程的线程切换会引起进程的切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统的开销较大

*****

## 线程的实现方式

### 用户级线程(User-Level Thread)

用户级线程通过线程库实现，所有的线程管理工作都由应用程序来实现（包括线程切换）。

用户级线程中，线程的切换可以在用户态下直接完成，不需要操作系统的干预。在用户看来是有多个线程在运行，但是在操作系统看来，并不能意识到线程的存在，只能看到一整个进程。（对用户不透明，对操作系统透明）

### 内核级进程(Kernal-Level Thread)

内核级线程的管理工作是由操作系统完成的，线程的调度、切换等工作都由内核负责，因此内核级线程的切换必须在核心态下才能完成。

内核级线程是从操作系统的视角能看到的线程。

操作系统只能看到内核级线程，因此<font color="red">只有内核级线程才是处理机分配的单位</font>！

*****

## 多线程模型

### 多对一模型

多个用户级线程映射到一个内核级线程，每个用户进程只对应一个内核级线程

优点：用户级线程的切换在用户空间就可以完成，不需要切换到核心态，线程管理的开销小，效率高。

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。而且多个线程不能在多个核心上并行运行。

### 一对一模型

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同的内核级线程数量。

优点：一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多个核心上并发执行。

缺点：一个用户进程会占用多个内核级进程，线程的切换由操作系统内核完成，需要切换到核心态才可以完成，线程管理的成本较高，开销较大。

### 多对多模型

n个用户级线程映射到m个内核级线程（$n \geq m$）。每个用户进程对应了m个内核级线程。

优点：克服了一对一模型的并发度不高的缺点，也克服了一对一模型中一个用户进程占用太多内核级线程，开销大的缺点。
