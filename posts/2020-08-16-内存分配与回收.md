---
title: '内存分配与回收'
tags: ['操作系统','内存']
---
# 内存分配与回收

## 连续分配

### 单一连续分配

内存分为“系统区”和“用户区”，系统区通常位于内存的低地址部分，用于存放操作系统的相关数据。 用户区存放用户进程相关的数据，**内存中只有一道用户程序**，用户程序独占整个用户区。

- 优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定采取内存保护
- 缺点：只适用于单用户、单任务的操作系统；由内部碎片，分配给某些进程的内存区中，如果有部分没有用上，就是“内部碎片”。

*****

### 固定分区分配

为了可以在内存中装入多道程序，而且这些程序不会相互干扰，将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

分区说明表：

操作系统维护和更新一个分区说明表，实现对各个分区的分配和回收

| 分区号 | 大小 | 起始地址 | 状态   |
| ------ | ---- | -------- | ------ |
| 1      | 2    | 8        | 未分配 |
| 2      | 2    | 10       | 未分配 |

缺点：会产生内部碎片

#### 分区大小相等

- 缺点：缺乏灵活性
- 优点：适用于一台计算机**控制多个相同的对象**的场合

#### 分区大小不等

- 优点：增加了灵活性，可以满足不同大小的进程需求

*****

### 动态分区分配

可变分区分配，不会预先划分内存分区，而是在进程装入内存时，**根据进程的大小动态建立分区**，使分区的大小正好满足进程的需要。

- 缺点：动态分区分配没有内部碎片,但是有外部碎片。
  - 内部碎片：分配给某进程的内存区域中,如果有些部分没有用上
  - 外部碎片：是指内存中的某些空闲分区由于太小而难以利用。

#### 记录内存的使用情况

- 空闲分区表

  每个空闲分区对应一个表项，表项包含分区号、分区大小、分区起始地址等信息

- 空闲分区链

  每个分区的起始部分和末尾部分设置前指向指针和后指向指针，起始部分还可以记录分区大小等信息

*****

#### 空闲分区的分配

把一个新作业装入内存时,须按照一定的**动态分区分配算法**,从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响,因此人们对它进行了广泛的研究

动态分区分配算法：

##### 首次适应算法

算法思想：每一次都从低地址开始查找，找到第一个能满足大小的额空闲分区。

在空闲分区表或者空闲分区链中，空闲分区以**地址递增的次序排列**，每次分配内存的时候，**选择空闲分区表或者空闲分区链中第一个大小能满足的空闲分区**。

##### 最佳适应算法

算法思想：动态分区分配是一种连续的分配方式，为进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来的时候能有连续的大片空间，可以尽可能多地留下大片空闲区，**优先使用更小的空闲区**。

将空闲分区按照容量递增的次序依次连接，分配内存的时候查找空闲分区链或者空闲分区表，找到第一个代销能满足进程需要的空闲分区。

缺点：使用最佳适应算法，会产生很多外部碎片

##### 最坏适应算法

算法思想：为了解决最佳适应算法留下太多难以利用的小碎片的问题，最坏适应算法每次分配时优先使用最大的连续空间，这样分配后的空间就不会太小，方便使用。

将空闲分区按照容量递减的次序依次连接，分配内存的额时候查找空闲分区表或空闲分区链，找到大小能满足需求的第一个空闲分区。

缺点：连续的大分区被迅速使用完，如果之后“大进程”到达，就没有可以用的内存分区了。

##### 邻近适应算法

算法思想：首次适应算法每次都从链头开始查找，可能会导致低地址出现很多小的空闲空间分区，每次分配查找的时候，都要经过这些分区，增加了查找的开销，如果每次都从上次搜索结束的位置开始查找，就可以解决上面的问题。

将空闲分区按照起始地址递增的方式排列成一个循环链表，每次分配内存时，从上次检查结果的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。

## 

