---
tags: ['操作系统','进程']
---
# 进程控制

进程控制是进程管理中的基本功能：

- 创建一个新进程
- 终止一个已完成的进程
- 终止一个因某事件不能继续运行的进程
- 进程运行中的状态转换

进程控制一般由OS内的**原语**实现

> 原子操作：只一个操作的所有动作要么都做，要么都不做，是不可分割的基本单位，在执行的过程中**不允许被中断**，原子操作在管态下执行，常驻内存。
>
> 原语： 由若干条语句组成，用于完成某一功能的一个过程，它们是“原子操作”，原语的作用是实现进程的通信和控制，避免造成其状态的不确定性

## 进程的创建

### 进程图（Process Graph）

用于描述一个进程的家族关系的**有向树**（有向树是有向图，不是树）。用一条从父进程指向子进程的有向边来描述它们之间的父子关系。创建父进程的进程被成为祖先进程，树根代表的进程作为家族的祖先。

子进程可以继承父进程所有的资源：父进程打开的文件、分配到的缓冲区等。

- 如果子进程被撤销，应该将从父进程获得的资源归还给父进程。
- 如果父进程被撤销，也必须同时撤销所有的子进程。

为了表示进程之间的家族关系，在PCB内都设置了家族关系表，标明自己的父进程及所有的子进程。

![PNG??.png](https://i.loli.net/2020/07/31/nasX4Sj9vtpdqPc.png)

### 引起创建进程的事件

一个进程去创建另一个进程的典型事件有以下四个类型：

1. 用户登录：为终端建立进程
2. 作业调度：作业调度程序按照一定的算法调度到某个作业时为该作业创建进程
3. 提供服务：运行中的用户程序向操作系统提出请求，系统专门创建的进程来提供用户程序需要的服务
4. 应用请求：由应用本身为自己创建一个新的进程，以期完成一个并发的特定任务

### 进程的创建(Creation Of Process)

调用进程创建原语Create()创建一个新的进程：

1. 申请空白的PCB：申请一个唯一的数字标识符，在PCB集合内索取一个空白的PCB
2. 为新进程分配资源：为新进程的程序和数据以及用户栈分配必要的内存空间。操作系统必须知道新的进程需要的内存大小。
   - 对于批处理作业或者为应用创建子进程，用户需要在提出创建进程请求的时候提供所需要的内存大小
   - 对于交互性作业，创建进程时可以不指定需要的内存大小，由操作系统分配一定的空间
3. 初始化PCB：
     - 初始化标识信息，将系统分配的标识符和父进程的标识符填入到PCB中
     - 初始化处理机状态：将程序计数器指向程序的入口，栈指针指向栈顶
     - 初始化处理机控制信息：将进程的状态设置为就绪状态或者静止就绪状态，设置优先级
4. 将进程插入就绪队列。如果就绪队列可以接受新进程，就将进程插入就绪队列

### 进程终止

#### 引起终止的事件

##### 正常终止

任何计算机系统中都有一个表示程序已经运行完的指示，当程序运行到这个指示时，会产生一个中断通知操作系统这个进程已经运行完毕了，

##### 异常终止

进程运行期间出现某种错误导致的进程终止

- 越界错误：访问的存储区超出该进程的区域
- 保错误：试图访问受保护的不允许访问的资源或文件
- 非法指令：试图执行一条不存在的指令
- 特权指令错：试图执行只允许OS执行的指令
- 运行超时：进程的执行时间超过指定的最大值
- 等待超时：进程等待某个事件的时间超过最大值
- 算数运算错：试图执行一个被禁止的运算
- I/O故障：在I/O过程中发生错误

##### 外界干预

- 操作员或者操作系统干预
- 父进程请求
- 父进程终止

#### 进程终止的过程

OS调用终止原语时：

- 根据要终止的进程的标识符，从PCB集合里找出要终止的PCB，读取要终止的进程的状态
- 如果要被终止的进程处于执行状态，应该立即终止进程的执行，将调度标志置为真，指示改进程被终止后应该重新被调度
- 如果要被终止的进程由子孙进程，应该将子孙进程终止，防止它们成为不可控的进程
- 被终止的进程的所有资源，应该归还给其父进程，或者操作系统
- 将被终止的进程（PCB）从所在队列（或链表）移除，等待其他的程序搜集信息

### 进程的阻塞与唤醒

#### 引起进程阻塞和唤醒的事件

##### 请求系统服务

请求系统的服务，但是系统不能马上满足时

##### 启动某种操作

进程在启动某种操作后，必须要等到该操作结束后才能继续执行时

##### 新数据尚未到达

对于相互合作的进程，如果其中的一个进程需要先获得合作的另一进程的数据才能继续执行，对数据进行处理时

##### 无新工作可做

某些具有特殊功能的进程，在完成任务后，将自己阻塞起来，等待下一个任务的到来

#### 进程阻塞的过程

阻塞时进程主动的行为，调用系统的Block原语，进入Block状态，此时进程还处于执行状态，应该把PCB中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。

调度程序进行重新调度，将处理机分配给其他的进程并进行切换，保存被阻塞的进程的处理机状态到PCB中，再按新进程的PCB设置处理机的环境。

#### 进程唤醒的过程

被阻塞的进程所期待的事件发生时，被阻塞的进程将被唤醒。即将被唤醒的进程从阻塞队列中移出，将其PCB的现行状态改为“就绪”，插入到就绪队列中，等待调度。

block原语和wakeup原语是一对作用相反的原语，如果再某一进程内调用了block原语，则必须再另一个与之合作的进程或者其他进程内调用与之对应的wakeup原语，否则该进程会长久进入阻塞状态，没有机会执行。

### 进程挂起和激活

#### 引起进程挂起的事件

##### 进程主动请求

用户进程主动请求将自己挂起

##### 父进程请求

父进程请求将自己的某个子线程挂起

#### 进程挂起的过程

- 活动就绪(Readya) $\overset{Suspend}{\rightarrow}$ 静止就绪(Readys)
  
- 活动阻塞(Blockeda) $\overset{Suspend}{\rightarrow}$ 静止阻塞(Blockeds)
  
#### 进程激活的过程

- 静止就绪(Readys) $\overset{Active}{\rightarrow}$ 活动就绪(Readya)
- 静止阻塞(Blockeds) $\overset{Active}{\rightarrow}$ 活动阻塞(Blockeda)
