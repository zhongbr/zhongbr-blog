---
title: '进程同步和进程互斥'
tags: ['操作系统','进程']
---
# 进程同步和进程互斥

## 进程同步

进程具有异步性的特征。各个并发的进程以各自独立、不可预知的速度向前推进。

同步亦称直接制约关系，指为完成某种任务而建立的两个多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。

*****

## 进程互斥

进程“并发”需要“共享”的支持。各个并发执行的进程不可避免地需要共享一些系统资源（比如内存、打印机、摄像头类地i/o设备）。

临界资源：在系统中的某些资源可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源，这些资源被称为临界资源。

### 对临界资源的互斥访问，在逻辑上可以分为四个部分

1. 进入区：检查是否可以进入临界区。如果可以进入，应设置正在访问临界资源的标志（上锁），阻止其他的进程进入该临界区；如果有其他进程正在使用临界区，则需要等待该进程退出临界区之后才能进入临界区（忙则等待）；操作系统需要保证请求访问临界区的进程可以在**等待有限时间内进入临界区**（优先等待）；进程在不能进入临界区的时候，应该立即释放处理机，防止进程忙等待（让权等待）。
2. 临界区（临界段）：访问临界资源的代码
3. 退出区：负责解除正在访问临界资源的标志（解锁）
4. 剩余区：其他处理

### 进程互斥的软件实现方法

#### 单标志法

算法思想：两个进程在访问完临界区之后，把临界区的访问权限转交给另一个进程。每个进程进入临界区的权限只能由另一个进程赋予。

```c
int turn = 0;
while(turn != Process);
// 访问临界区的代码
turn = AnotherProcess; // 将临界区的访问权限交给另一个进程
// 其他的处理的代码
```

缺点：turn表示当前可以进入临界区的进程号，而且只有当前的进程访问了临界区之后，才会修改turn的值。也就述说对于临界区的访问一定是轮流的。如果当前允许访问的进程是P0，但是P0一直不访问临界区，那么虽然此时临界区是空闲的，P1也不能访问。

#### 双标志法

算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各个进程的意愿。每个进程在进入临界区之前，把自身对应的标志位flag[i]置为true，然后开始访问临界区。

```c
int flags[2];
flag[0] = false;
flag[1] = false;
// P0进程:
while(flag[1]);
// 如果这里放生了进程的切换，可能导致多个进程同时访问临界区
flag[0] = true;
// 访问临界区的代码
flag[0] = false;
// 其他处理的代码
```

缺点：由于进程之间的执行存在异步性，可能导致多个进程都会跳过等待的while循环，同时访问临界区。违背了临界区的“**忙则等待**”原则。

#### 双标志后检查

算法思想：是双标志法的优化版。解决了双标志法的检查和上锁操作可能不能一气呵成导致多个进程同时进入临界区的问题。所以人们想到了**先上锁后检查**的方法。

```c
int flags[2];
flag[0] = false;
flag[1] = false;
// P0进程:
flag[0] = true; //如果在这里发生了进程切换，切换到P1，会导致两个进程都卡在下面的while循环中
while(flag[1]); 
// 访问临界区的代码 
flag[0] = false;
// 其他处理的代码
```

缺点：双标志后检查法虽然解决了“忙则等待”问题，但是又违背了“空闲让进”和“有限等待”的原则，会因为进程长期无法访问临界资源产生饥饿的现象。

#### Peterson方法

算法思想：在双标志后检查法中，可能产生因为两个进程都想进入临界区而导致都无法进入的情况。如果两个进程都想进入临界区可以尝试主动让对方先进入临界区。

```c
int flags[2]; // 表明各个进程想进入临界区的意愿
int turn = 0;
flag[0] = false;
flag[1] = false;
// P0进程:
flag[0] = true; //如果在这里发生了进程切换，切换到P1，会导致两个进程都卡在下面的while循环中
turn = 1; // 主动让对方使用临界资源
while(flag[1] && turn == 1); 
// 访问临界区的代码 
flag[0] = false;
// 其他处理的代码
```

优点：解决了进程互斥的问题，遵循了“空闲让进”、“忙则等待”、“有限等待”三个原则，但是没有满足“让权等待”

*****

### 进程同步的硬件实现方法

#### 中断屏蔽方法

利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止，都不允许被中断，所以不会发生进程的切换，也不可能发生两个进程同时访问临界区的情况）。

优点：简单、高效

缺点：不适用于多处理机，只适用于操作系统内核，不适用于用户进程（**开关中断的指令只能在核心态下运行**）。

#### TestAndSet指令

简称TS指令，也称为TestAndSetLock指令，或TSL指令。该指令是用硬件实现的，执行过程不允许被总段，只能一气呵成。

```c
// lock表示当前临界区是否被加锁
// true表示枷锁 false表示未加锁
// 真实情况下，下面的这个TestAndSet函数是用硬件实现的，不会被中断，是一气呵成的
bool TestAndSet(bool *lock){
    bool old = *lock;
    *lock = true; // 无论之前是否加锁，都将锁设为true
    return old; // 返回原来锁的状态
}

int main(){
    // 使用TS实现互斥的算法逻辑
	while(TestAndSet(&lock));
    // 访问临界区的代码
    lock = false; // 解锁
    // 剩余的其他代码
}
```

硬件实现的TSL操作是**原子性**的

优点：实现简单，不需要像软件实现方法那样检查是否会有逻辑漏洞

缺点：即使无法进入临界区，也会一直占用CPU执行while循环，不满足“让权等待”原则



#### SWAP指令

也称为Exchage指令或者简称XGHG指令，是靠硬件实现的，执行过程不允许被中断，只能一气呵成，其逻辑使用C描述如下：

```c
// 交换两个变量的值
void Swap(bool *a, bool *b){
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
// 使用Swap指令的算法逻辑
int main(){
    //lock表示临界区是否加锁
    bool old = true;
    while(old) Swap(&lock, &old);
    //临界区代码
    lock = false;
	//剩余代码
}
```

逻辑上于TSL指令是一样的，所以优点和缺点也是相同的。