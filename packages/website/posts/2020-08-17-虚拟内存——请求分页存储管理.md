---
title: '虚拟内存——请求分页存储管理'
tags: ['操作系统','虚拟内存','内存']
---
# 虚拟内存——请求分页存储管理

## 请求分页存储管理

请求分页与基本分页的区别：

在程序执行的过程中，

请求调页：由操作系统负责将苏需要的信息从外存调入到内存，然后继续执行程序；

页面置换：内存空间不够的时候，由操作系统将暂时用不到的信息换出到外存。

### 页表机制

与基本分页相比，请求分页存储管理为了实现“请求调页”功能，操作系统需要知道：

- 每个页面是否已经调入了内存
- 没有调入内存的页面在外存中的位置

为了实现“页面置换”功能，决定将那些页面置换，需要知道：

- 页面是否被修改过

#### 请求分页存储管理的页表

![quicker_9aa32b9d-efac-44fb-8837-74a558cb0a0a.png](https://i.loli.net/2020/08/17/rqN73oBKjXDdctP.png)

- 状态位：标记页面是否在内存中
- 访问字段：记录最近该页面被访问的次数，供置换时参考
- 修改位：标记页面是否被修改过
- 外存地址：各个页面在外存中的存储位置

### 缺页中断机构

缺页中断属于**内中断中的故障(falut)**

在请求分页系统中，当要访问的页面不在内存中的时候，会产生一个**缺页中断信号**，然后由操作系统的缺页中断处理程序处理中断。

操作系统缺页中断处理程序处理时，缺页的进程进入组赛状态，调页完成后将其唤醒，放回就绪队列。

如果此时内存中有空闲的块，位进程分配一个空闲的块，将所缺的页面装入该块，并修改页表中对应的页表项；

如果此时内存中没有空闲的块，由置换算法选择一个页面置换到外存中，将调入的页面装到被置换的页面处，修改页表中对应的项。

### 地址变换机构

与基础分页相比，请求分页存储管理的地址转换增加了如下的三个步骤：

1. 请求调页：查到页表项时需要根据其是否在内存中来决定是否要请求调页
2. 页面置换：需要调入页面时，没有空闲内存块时进行
3. 修改请求页表中的表项

## 页面置换算法

### 最佳置换（OPT，Optional）

每次选择淘汰的页面是以后永不使用，或者**长时间不会再被访问的页面**，这样可以保证最低的缺页率。

> **缺页率 = 缺页中断的次数/访问页面的次数**

最佳置换算法可以保证最低的缺页率，但是实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面，所以操作系统**无法提前预判页面的访问序列**。所以，**最佳置换算法是无法实现的**。

### 先进先出置换算法（FIFO）

每次选择淘汰的页面是**最早进入内存**的页面

实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要置换页面的时候，选择队头的页面即可。**队列的长度取决于系统为进程分配的内存块的数目**。

> Belady异常：为进程分配的内存块数增多时，缺页的次数不减反增的现象称为**Belady异常**

只有FIFO算法会产生Belady异常。

优点：实现简单

缺点：算法与进程实际运行规律不适应，先进入的页面可能经常被访问，算法的性能差。

### 最近最久未使用置换算法（LRU, Latest Recently Used）

每次淘汰的页面时最近最久未使用的页面。

实现方法：在每个页面对应的页表项中，用访问字段记录上次被访问以来所经历的时间t。当需要淘汰一个页面的时候，选择所有的页表项中t值最大的，即最近最久未使用的页面。

优点：算法性能好

缺点：实现需要专门的硬件支持，实现的难度大、开销大

### 时钟置换算法（CLOCK）

时钟置换算法是性能和开销比较均衡的算法，也被称为**最近未使用算法(NRU, Not Recently Used)**。

#### 简单时钟置换算法

为每个页面设置一个访问位，将内存中的页面通过链接指针链接成一个循环队列。页面被访问的时候，其访问位 置为1.当需要淘汰一个页面的时候，检查其访问位，如果是0就将这个页面置换出；如果是1就将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有的页面都是1，则进行第二轮扫描（一定会访问到访问位为0的页面），将第一个访问位位0的页面置换出。简单时钟置换算法淘汰页面**最多会经历两次扫描**。

#### 改进型时钟置换算法

**算法思想**：考虑一个页面最近有没有被访问过之外,操作系统还考虑页面有没有被修改过。在其他条件都相同时,应优先淘汰没有修改过的页面,避免I/O操作。这就是改进型的时钟置换算法的思想。
修改位=0,表示页面没有被修改过:修改位=1,表示页面被修改过。

**算法规则**：将所有可能被置换的页面排成一个循环队列

第一轮：从当前位置开始扫描到第一个(0,0)【没有被修改过，也没有被访问过的页面】的帧用于替换，本轮扫描不修改任何标志位

第二轮：如果第一轮扫描失败，重新扫描，查找第一个(0,1)【没有被访问过，但是被修改过的页面】的帧用于替换，本轮扫描将所有扫描过的帧的访问位设为0

第三轮：如果第二轮扫描失败，重新扫描，查找第一个(0,0)【没有被修改过，也没有被访问过的页面】的帧用于替换，本轮扫描不修改任何标志位。

第四轮：如果第三轮扫描失败，重新扫描，查找第一个(0,1)【没有被访问过，但是被修改过的页面】的帧用于替换。

