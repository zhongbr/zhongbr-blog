---
title: '查找的基本概念'
tags: ['数据结构','查找']
---
# 查找的基本概念

## 查找

在数据集合中查找满足某种条件的数据元素的过程

> 查找表：用于查找的数据集合由同一种数据类型（或记录）组成，可以用一个数组或者一个链表等数据类型。
> 操作：
>
> - 查询某个特定的数据元素是否在查找表中
> - 检索满足条件的某个特定元素的各种属性
> - 在查找表中插入一个数据元素
> - 从查找表中删除一个数据元素
>
> 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。
>
> 平均查找长度(成功时的平均查找长度)：查找时关键字比较次数的平均值 $ASL=\sum_{i=1}^{n}{P_{i}C_{i}}$，其中$P_{i}$是查找数据元素i的概率，通常取$\frac{1}{n}$

**********************

## 顺序查找

又称线性查找，主要用于在线性表中进行查找。

### 对于无序线性表

对无序线性表进行顺序查找，查找失败时要遍历整个线性表

### 对于有序线性表

对有序线性表进行顺序查找，查询失败时仅需要找到比关键字大（降序时为比关键字小）的元素就可以说明要查找的元素不存在了。

$ASL_{失败} = \sum_{i=1}^{n}P_{i}C_{i} = \sum_{i=1}^{n}\frac{1}{n+1}(l_{j}-1)=\frac{1+2+...+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$

**********************

## 折半查找（二分查找）

仅适用于有序的顺序表

### 算法思想

首先将给定值key与表中中间位置元素进行关键字比较

- 若相等，返回该元素的位置

- 若不等，则在前半部分或者后半部分查找

- 递归重复上述过程，直至查询完毕

### 实现

```c
int BinarySearch(SeqList L, ElemType key){
    int low=0, high=L.length-1, mid;
    while(low <= high){
        mid = (low+high)/2;
        if(L.Elems[mid]==key) return mid;
        else if(L.Elems[mid] > key) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}
```

平均查找长度 $ASL_{成功}=\sum_{i=1}^{n}{P_{i}C_{i}}=\sum_{i=1}^{n}{\frac{1}{n}\times l_{i}}=\frac{1\times 1+2\times 2+3\times 2^{2}+...+h\times 2^{h-1}}{n}=log_{2}(n+1)-1$

折半查找的时间复杂度时 $O(log_{2}n)$

**********************

## 分块查找

又称索引顺序查找，吸取了顺序查找和折半查找各自的有点，既有动态结构，又适用于快速查找

### 分块的方法

- 将查找表分为若干子块。块内的元素可以无序，但块间必须有序，即所有块有第i块的最大关键字小于第i+1块的最大关键字
- 建立索引表，索引表中的每个元素含有各块的最大关键字和各块第一个元素的地址，索引表按照关键字有序排列

块内无序，块间有序

### 查找的方法

- 在索引表中确定待查记录所在的块，可以使用顺序查找或者折半查找
- 在块内进行顺序查找

### 平均查找长度

分块查找的平均查找长度分为索引查找(LI)和块内查找(LS)之和

对于一个长度为n的查找表，均匀分为b块，每一块有s个记录：

$ASL_{成功}=L_{i}+L_{s}$

#### 块内和块间均采用顺序查找

$ASL_{成功}=L_{i}+L_{s}=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^{2}+2s+n}{2s}$

#### 块间采用折半查找时

$ASL_{成功}=L_{i}+L_{s}=\left [ log_{2}(b+2) \right ] \frac{s+1}{2}$
