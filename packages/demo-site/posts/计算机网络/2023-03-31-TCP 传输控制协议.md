---
title: 'TCP 传输控制协议'
tags: ['传输层', 'TCP']
recommend: 'network'
icon: '📮'
---

# TCP 传输控制协议

TCP 套接字由一个四元组来标识(源 IP 地址, 源端口号, 目的 IP 地址, 目的端口号)

与 UDP 不同，**具有不同的源 IP 地址或者源端口号的 TCP 报文段会被定向到不同的 TCP 套接字**

# TCP 连接指标以及测量方式

- MTU(Maximum Transmission Unit)，最大传输单元
    
    MTU (最大传输单元) 是指通信链路层上所能通过的最大数据包大小，以字节为单位。当发送端的数据包长度超过 MTU 时，发送端需要将数据分割成更小的数据包进行传输。接收端接收到这些数据包后，再将这些数据包组合成原来的数据包。
    
    MTU 的大小是由物理层技术、网络协议和网络设备等多种因素决定的。在 TCP/IP 中，MTU 大小一般是 1500 字节。当封包大小超过 MTU 时会发生分片，这可能会导致网络拥塞和丢包。因此，许多应用程序会将数据拆分成更小的块，以确保数据传输的可靠性和稳定性。
    
- MSS(Maximum Segment Size)，最大报文段长度
    
    MSS 是 TCP 报文段中数据部分的最大长度。这是由接收方的缓冲区大小和发送方和接收方之间网络连接的最大传输单位 (MTU) 确定的。在 TCP 连接建立时，发送方和接收方协商并选择最大报文段长度。发送方发送的数据报文段的大小不能超过 MSS，这有助于确保数据报文段能够成功传递并被接收方正确处理。如果一个数据报文段的大小超过了 MSS，则它将被分成多个数据报文段进行传输。
    
    由于 MTU 的大小通常是 1500 字节，而 TCP 报文段的首部大小是 40 字节，所以 MSS 典型值的 1460 字节。
    
- RTT(Round Trip Time)，连接往返时间
    
    从发送数据到接收到对应确认数据的时间，再将这个时间发送回发送方所需的时间。
    
    这个时间通常用于衡量 TCP 数据包在网络中的传输时间，包括数据包从发送端到接收端的传输时间以及确认数据包从接收端到发送端的传输时间。
    
    ### RTT 的估算方式
    
    TCP 会在任一时刻，为一个已经发送但是还未确认的报文段（不包括重发的报文段）计算 SampleRTT，并且采用加权平均的方式，维护内部对本连接 RTT 值的估算 EstimatedRTT，公式如下，其中 $\alpha$ 通常取 0.25：
    
    $$
    EstimatedRTT = (1-\alpha)EstimatedRTT + \alpha SampleRTT
    $$
    

# TCP 报文段结构

![Untitled](TCP%20%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%20ecfb9f024da747e4b7e842237bcee0c2/Untitled.png)

- 序号
    
    **报文段首个字节的序号，**而不是分组的序号
    
- 确认号
    
    接收方期望发送方下一个报文段发送的首个字节的序号。
    
- 接收窗口
    
    用于流量控制
    
- 首部长度
    
    TCP 首部长度字段是一个 4 位的二进制数，用于指示 TCP 报文段首部的长度，**单位是 4 字节**。因此，TCP 首部长度字段的取值范围是 0 到 15。TCP 报文段的首部长度必须是 32 比特的倍数。因此，TCP 首部长度字段的取值范围是 0 到 15，对应的 TCP 报文段首部的长度是 0 到 60 字节。
    
- 选项字段
    
    TCP 报文段中的选项字段提供了一些**额外的信息**，例如最大报文段长度 (MSS)、窗口扩大因子 (WScale)、时间戳 (TS)、选择确认 (SACK) 等等。这些选项字段的长度可以不同，但是它们都包含一个类型字段和一个长度字段。
    
    一些常见的 TCP 选项字段包括：
    
    - MSS (Maximum Segment Size)：表示发送方发送的 TCP 报文段中数据部分的最大长度。
    - SACK (Selective Acknowledgment)：表示接收方能够选择性地确认已经接收到的数据。
    - TS (Timestamp)：表示发送方的时间戳，用于计算往返时间 (RTT)。
    - NOP (No Operation)：表示不执行任何操作，仅用于填充选项字段的空间。
    
    选项字段的长度是由长度字段指定的，长度字段的值为选项字段的长度 (包括类型字段和长度字段本身)。
    
- 标志字段
    
    TCP 标志字段是 TCP 报文段中的一个 6 位字段，用于指示报文段的状态和控制信息。其中，URG、ACK、PSH、RST、SYN、FIN 分别代表紧急数据、确认、推送、复位、同步、结束。
    
    - URG (Urgent)：表示紧急数据的存在，通常与紧急数据指针一起使用。
    - ACK (Acknowledgment)：表示确认号有效，通知接收方已经成功接收到数据。
    - PSH (Push)：表示接收方应该立即将数据推送给应用程序，而不是等待缓冲区填满。
    - RST (Reset)：表示连接重置，用于中断连接。
    - SYN (Synchronize)：表示同步序号，用于建立连接。
    - FIN (Finish)：表示发送方已经发送完数据，用于关闭连接。
    
    在 TCP 报文段中，标志字段通常是通过二进制位来表示的。例如，URG=1，ACK=0，PSH=0，RST=0，SYN=1，FIN=0 可以表示 SYN 报文段。
    
- 紧急数据指针
    
    TCP 紧急数据指针是 TCP 报文段首部中的一个 16 位字段，它指示紧急数据的结束位置。当 URG 标志被设置为 1 时，紧急数据指针才有效。如果紧急数据指针的值为 N，则表示紧急数据的结束位置在报文段的第 N+1 个字节处。紧急数据指针通常用于传输优先级数据。
    

# 可靠数据传输

## TCP 确认 ACK 生成策略

### 发送方：累积确认

TCP 发送方在接收到接收方关于 y 的 ACK 后，会**确认 y 之前所有的字节都已经收到了**，即使还有序号小于 y 的已发送但是未被确认报文段，也不会再被重传。

### 产生 TCP ACK 的建议

| 事件 | TCP 接收方的动作 |
| --- | --- |
| 期望的报文段到达，此前期望的报文段的 ACK 还在等待发送 | 立即一个累积确认的 ACK（上一个没发的 ACK 就不发了） |
| 期望的报文段到达，此前期望的报文段都已经确认 | 等待 500ms 发送 ACK |
| 比期望的报文段序号大的报文段到达，检测出间隔 | 立即发送冗余 ACK，指示下一个期待的字节的序号 (间隔的低端序号) |
| 能部分或完全填充数据间隔的报文段到达 | 如果报文段位于间隔的低端，立即发送确认 ACK |

### 快速重传

接收方会在检测到数据间隔时，发送**冗余 ACK** 来向发送方指示。

发送方收到对于同一个序号的 3 个冗余 ACK 时，就会认为这个序号之后所有的报文段都已经丢失，触发**快速重传**

触发了快速重传之后，发送方会在定时器过期之前，重传丢失的报文段

# 流量控制

注意，流量控制和拥塞控制这两个属于所指的情况是不同的，主要区别是触发控制的原因不同。

**流量控制服务：**为了避免 TCP 发送方发送的数据过多或者过快，导致接收方接收缓存溢出，而对发送方的流量进行控制。

**拥塞控制：**TCP 发送方由于 IP 网络拥堵而被遏制

TCP 通过在发送方维护（实际上全双工通信，两方都可以作为发送方）一个**接收窗口（receive window）**，用于表示接收方还有多少接收缓存。

<aside>
💡 发送方如何知道接收方接收窗口的大小？

</aside>

TCP 报文段的**首部中有一个“接收窗口”字段**，就是用于同步接收窗口的。

接收方在向发送方发送 ACK 时（或者全双工通信里向发送方发送数据时），会在其首部种带上自己当前的接收缓存剩余大小，发送方收到后就会更新接收窗口。

<aside>
💡 接收方在自己的接收缓存可用空间从0增加时并没有特意通知发送方，那如果接收方在接收缓存满了之后，没有 ACK 或者新的数据要发送给发送方，发送方如何得知何时可以继续发送数据？

</aside>

在发送方得知接收方的接收窗口为0之后，**仍会继续向接收方发送只有一字节数据的报文段（这一个字节也是真正要发的数据，并不是占位的）**，如果这个报文段被接收方确认，发送方就可以得知接收方最新的接收窗口了。

# 拥塞控制

在实践中，可能会由于路由器的缓存溢出而导致 TCP 的报文段丢失，通常 TCP 会将报文段丢失视为 IP网络拥塞 的标志。TCP 在检测到网络拥塞之后，会通过拥塞控制来遏制发送方。

<aside>
💡 TCP 如何感知IP网络发生了拥塞？

</aside>

TCP 发送方在出现了下面的两种情况时就会认为出现了网络拥塞：

1. 已发送待确认的报文段出现超时
2. 收到3个对同一个序号的冗余ACK

<aside>
💡 TCP 发送方如何限制发送速率？

</aside>

TCP 发送方会维护一个拥塞窗口(congestion window)，限制发送方未被确认的数据量，达到控制发送方发送速率的目的。

<aside>
💡 TCP 如何维护拥塞窗口的大小？

</aside>

TCP 拥塞控制算法主要包括以下两种：

1. 慢开始（Slow Start）
    - 在开始时，拥塞窗口 cwnd 的大小为 1
    - 每当收到一个 ACK，cwnd 的大小就会加倍
    - 当 cwnd 的大小达到一个阈值 ssthresh 时，就进入拥塞避免状态
2. 拥塞避免（Congestion Avoidance）
    - 在拥塞避免状态下，cwnd 的大小每收到一个 ACK，就会增加 1/cwnd
    - 如果出现拥塞，将 ssthresh 设置为 cwnd 的一半，并将 cwnd 设置为 1，重新进入慢开始状态

此外，TCP 还有快重传和快恢复机制。当发送方收到多个重复的 ACK 时，就会认为某个报文段已经丢失，立即重传该报文段，而不必等待定时器过期。快恢复机制则是在重传该报文段之后，将 ssthresh 设置为当前 cwnd 的一半，并将 cwnd 设置为 ssthresh，重新进入拥塞避免状态。

# TCP 连接管理

## 三次握手

TCP 三次握手是建立 TCP 连接的过程，它由三个步骤组成：

1. 发送端向接收端发送一个 SYN 报文段，其中包含一个初始序号。在这个报文段中，SYN 标志被设置为 1，ACK 标志被设置为 0。这个初始序号用于表示发送端的首个数据字节的序号。
2. 接收端收到 SYN 报文段后，向发送端发送一个 SYN/ACK 报文段，其中包含一个确认序号和一个初始序号。在这个报文段中，SYN 标志被设置为 1，ACK 标志被设置为 1。确认序号等于接收到的初始序号加 1，用于表示接收端期望接收的下一个字节的序号。初始序号用于表示接收端的首个数据字节的序号。
    
    <aside>
    💡 SYN 洪泛攻击
    
    注意，如果此时服务端为这个 TCP 连接分配变量和缓存，并等待客户端的 ACK，如果超过一段时间（通常是1.5分钟）未收到客户端的ACK，服务端就会终止这个连接并收回资源。
    这一段时间的等待，SYN 洪泛攻击所利用的特征：
    
    [SYN 洪泛攻击](https://www.notion.so/SYN-02ea23321bfa40ce8bb0091289538227)
    
    </aside>
    
3. 发送端收到 SYN/ACK 报文段后，向接收端发送一个 ACK 报文段，其中包含一个确认序号。在这个报文段中，SYN 标志被设置为 0，ACK 标志被设置为 1。确认序号等于接收到的初始序号加 1，用于表示发送端期望接收的下一个字节的序号。

![Untitled](TCP%20%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%20ecfb9f024da747e4b7e842237bcee0c2/Untitled%201.png)

<aside>
💡 TCP 为什么要进行三次握手？只进行两次握手会有什么问题？

</aside>

如果只进行两次握手就建立连接，可能会有如下的问题：

1. 由于 IP网络提供的不是一个可靠的传输服务，不保证数据报的到达顺序，如果客户端发送了一个 SYN 报文段长时间未到达服务端，于是发起了重试，服务端可能会受到两个 SYN 报文段而建立两个 TCP 连接，也**不能防范 SYN 洪泛攻击**；
2. TCP 实现的是全双工通信，双方都需要确定自身的发送和接收数据是正常的，如果只进行两次握手，服务端是无法确认自己发送数据的能力的（三次握手时可以通过客户端发送的确认报文段来确认自己可以发送数据）。

## 四次挥手

TCP 四次挥手是关闭 TCP 连接的过程，它由四个步骤组成：

1. 发送端向接收端发送一个 FIN 报文段，其中包含一个序号。在这个报文段中，FIN 标志被设置为 1，ACK 标志被设置为 0。这个序号用于表示发送端的最后一个数据字节的序号。
2. 接收端收到 FIN 报文段后，向发送端发送一个 ACK 报文段，其中包含一个确认序号。在这个报文段中，FIN 标志被设置为 0，ACK 标志被设置为 1。确认序号等于接收到的序号加 1，用于表示接收端期望接收的下一个字节的序号。
3. 如果接收端还有数据需要发送，它可以在 ACK 报文段中包含一些数据，以便在发送端收到这些数据时进行处理。否则，接收端可以发送一个 FIN 报文段，以便在发送端收到这个报文段时关闭连接。
4. 发送端收到 FIN 报文段后，向接收端发送一个 ACK 报文段，其中包含一个确认序号。在这个报文段中，FIN 标志被设置为 0，ACK 标志被设置为 1。确认序号等于接收到的序号加 1，用于表示发送端期望接收的下一个字节的序号。

![Untitled](TCP%20%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%20ecfb9f024da747e4b7e842237bcee0c2/Untitled%202.png)

<aside>
💡 TCP 为什么要进行四次挥手？不可以只进行两次挥手吗？

</aside>

1. TCP 提供的是全双工通信，并且有半关闭状态：A发送 FIN 报文段只是代表A的数据发送完了，B回复 ACK 代表数据已经接收完毕同意断开，B可能还有数据要发送，此时B还是可以继续发送数据的，直到B的数据也发送完了，B向A发送 FIN 报文段，A回复 ACK 同意断开；
