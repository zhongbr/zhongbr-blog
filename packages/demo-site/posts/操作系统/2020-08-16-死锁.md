---
title: '死锁'
tags: ['操作系统','死锁']
---
# 死锁

## 死锁、饥饿和死循环

- 死锁：在并发的环境下，各个进程竞争资源造成一种互相等待对方手里资源，导致各个进程都无法向前推进的僵局就是“死锁”。

- 饥饿：进程长期无法得到自己想要的资源而产生的无法向前推进的现象。

- 死循环：某进程在执行过程中一直跳不出某个循环的现象，可能是因为BUG导致，也可能是程序员故意设计的。

共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外）。

差异：

- 死锁：至少发生在两个或者两个以上的进程上，**发生死锁的进程一定处于阻塞态**。
- 饥饿：可能只有一个进程发生饥饿，发生饥饿的进程可能处于阻塞态（长期得不到I/O设备），也可能处于就绪态（长期得不到处理机）
- 死循环：可能只有一个进程发生死循环，死循环的进程可以上处理机运行处于运行态，但是无法向前推进，死锁和饥饿是系统分配资源的策略不合理导致，而**死循环是由于代码的逻辑错误导致的**。

## 死锁产生的条件

1. 互斥条件：只有对必须互斥使用的资源产生争抢的时候才会导致死锁
2. 不可剥夺条件：进程获得的资源在自己未使用完之前，不能被其他进程剥夺，只能由进程主动释放
3. 请求和保持条件：进程已经保持了至少一个资源，但是提出了新的资源请求，但是该资源被其他进程持有，资源请求被阻塞，但是又对自己持有的资源保持不放。
4. 循环等待条件：存在一种循环等待链，链中每一个进程获得的资源正在被另一个进程请求。

满足上面的四个条件不一定会发生死锁，但是发生死锁的时候一定会满足上面的四个条件，满足上面的四个条件是产生死锁的**必要不充分条件**。

死锁发生在：

1. 对系统资源的竞争。各个进程对不可剥夺的资源的竞争可能会产生死锁，对可剥夺的资源的竞争不会产生死锁。
2. 推进顺序非法：请求和释放资源的顺序不当，也可能产生死锁。
3. 信号量使用不当：信号量使用不当的时候可能产生死锁

## 死锁的处理策略

1. 预防死锁：破坏产生死锁的四个必要条件的一个或者几个
2. 避免死锁：用某种算法避免系统进入不安全的状态，从而避免死锁（银行家算法）
3. 死锁的检测和解除：允许发生死锁，但是操作系统会检测死锁的发生，然后采取某种措施来解除死锁。

****

### 预防死锁

#### 破坏互斥条件

把只能互斥使用的资源改造为允许共享使用的资源，系统就不会进入死锁状态，比如：SPOOLing技术

缺点：不是所有得资源都可以改造为可共享使用得资源，并且可能为了系统安全，很多资源必须保护这种互斥性。**很多时候都无法破会互斥条件**。

#### 破坏不可剥夺条件

- 方案一：如果某个进程请求新资源得不到满足时，它必须释放保持的所有资源，以后需要这些资源的时候再重新申请，即使某些资源没有使用完，也要主动释放，破坏产生死锁的不可剥夺条件
- 方案二：如果某个进程请求新资源得不到满足时，由操作系统协助，将想要的资源强行剥夺。这种方案需要考虑到进程之间的优先级。

缺点：

1. 实现复杂
2. 释放已经获得的资源可能导致之前的工作失效，只能适用于易保存和恢复状态的资源，比如CPU。
3. 反复申请资源会导致系统开销增大，降低系统的吞吐量
4. 采用方案一时，暂时得不到某种资源，就要将之前获得的资源全部放弃，以后重新申请，如果每一次都有资源无法申请到，容易导致进程饥饿。

#### 破坏请求和保持条件

采用**静态分配的方法**，在进程运行前就分配给它所有需要的资源，在资源未得到满足之前，进程不会投入运行，进程一旦投入运行，这些资源就归它所有，直到进程运行结束，该进程在运行过程中不会请求别的任何资源。

优点：实现简单

缺点：有些资源，进程可能只会使用很短的时间，如果进程整个运行期间都保持着所有的资源，会造成艳照那个的资源浪费，资源利用率极低，导致其他的进程饥饿。

#### 破坏循环等待条件

采用顺序资源分配，给系统中所有的资源编号，每个进程必须按照编号递增的顺序请求资源，同类资源（编号相同的资源）依次申请完。

原理分析:一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源。按此规则,已持有大编号资源的进程不可能逆向地回来申请小编号的资源,从而就不会产生循环等待的现象。

缺点：

1. 不方便添加新的资源，可能需要重新分配所有的编号
2. 进程实际使用资源的顺序可能和编号递增的顺序不一致，导致系统资源浪费
3. 必须按照次序申请资源，编程麻烦

****

### 避免死锁



#### 安全序列

如果系统按照某种序列分配资源，则每个进程都可以顺利完成，只要能找出一个安全序列，系统就是安全状态，安全序列可能会有多个。

如果系统处于安全状态，就一定不会发生死锁，如果系统中找不到一个安全序列，而进入不安全状态，则**有可能会发生死锁**。

**系统处于不安全状态是发生死锁的必要不充分条件**。



#### 银行家算法

算法思想：分配资源之前，预先判断是否会导致系统进入不安全状态，决定是否答应资源分配请求

```c
int max[n][m]; // 各个进程资源最大需求量
int allocation[n][m]; // 各个进程已经获得的资源量
int need[n][m]; // 各个进程还需要的资源量
int avaliable[m]; // 系统中剩余的资源的量

bool request(int pid, int resource[m]){
    int i,j;
    for(i=0;i<m;i++) if(resources[i]>need[pid][i]) return false; // 申请的资源超过进程此前声明的最大需求，不分配
    for(i=0;i<m;i++) if(resources[i]>avaliable[i]) return false; // 系统中剩余资源不够，不能分配
    // 尝试把资源分配给这个进程，然后判断分配之后系统是否安全
    for(i=0;i<m;i++){
        avaliable[m] -= resource[m];
        allocation[pid][m] += resource[m];
        need[pid][m] -= resource[m];
    }
    // 检查系统当前是否安全
    bool safe = false;
    bool flags[n];
    for(i=0;i<n;i++) flags[i] = false;
    while(true){
        all_not_enough = true;
      	for(i=0;i<n;i++){
        	bool enough = true;
        	for(j=0;i<m;j++){
            	if(need[j][j] > avaliable[j]){
                	enough = false;
                	break;
            	}
        	}
        	if(!enough) continue; // 系统中的资源满足不了这个进程，跳过
        	// 系统中的资源可以满足这个进程，如果把资源分配给这个进程，让其运行完成
        	flags[i] = true;
            all_not_enough = true;
            // 模拟这个进程运行结束把持有的资源还给系统
            for(j=0;j<m;j++) avaliable[j] += allocation[i][j];
    	}
        bool all_enough = true;
        for(i=0;i<n;i++) all_enough = all_enough && flags[i];
        if(all_enough || all_not_enough){
            safe = all_enough;
            break;
        }
    }
    // 如果不安全，不分配资源，并把数据恢复
    if(!safe)
        for(i=0;i<m;i++){
            avaliable[m] += resource[m];
        	allocation[pid][m] -= resource[m];
        	need[pid][m] += resource[m];
        }
    return safe;
}
```



*****

### 死锁的检测和解除

#### 死锁的检测

1. 用某种数据结构来保存资源的请求和分配信息
2. 提供一种，利用上述信息来检测系统是否已经进入死锁状态

检测死锁的算法:

***依次消除与不阻塞进程相连的边，直到无边可消。***

1) 在资源分配图中,找出既不阻塞又不是孤点的进程Pi(即找出一条有向边与它相连,且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。

2) 进程Pi所释放的资源,可以唤醒某些因等待这些资源而阻塞的进程,原来的阻塞进程可能变为非阻塞进程。

死锁定理：如果某时刻不可以将系统资源分配图的所有边都消除（资源分配图**不可完全简化**），此时系统**死锁**。

#### 解除死锁

1. 资源剥夺法：挂起某些死锁进程，抢占它们的资源，把这些资源分配给其他的死锁进程，同时注意防止被挂起的进程长时间的得不到资源而饥饿。
2. 撤销进程法：强行撤销部分、甚至全部死锁的进程，剥夺这些进程的资源。实现简单，但是付出的成本大，这些进程可能已经运行了很长时间，马上就要结束了，被撤销就会功亏一篑。
3. 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步，要求系统巨鹿进程的历史信息，设置一些还原点。

可以根据：进程优先级、已经执行的时间、还有多久可以完成、进程使用的资源数量、进程的形式等因素决定剥夺那些进程的资源。