{"version":3,"file":"index.js","sources":["../../../src/utils/logger.ts","../../../src/core/proxy/index.ts"],"sourcesContent":["const isProd = import.meta.env.PROD;\n\nconst debugOnlyLevel: Array<keyof Console> = ['log', 'debug'];\n\nconst logger = debugOnlyLevel.reduce((pre, key) => {\n    return Object.assign(pre, {\n        [key]: (...args: unknown[]) => {\n            if (!isProd) {\n                return typeof console[key] === 'function' && (console[key] as Function)(...args);\n            }\n            return null;\n        }\n    });\n}, {} as Pick<Console, 'log' | 'info' | 'debug' | 'error' | 'warn'>);\n\nexport default logger;\n","import logger from '../../utils/logger';\n\nexport interface IMessageType {\n    id: string | number;\n    receiver?: string;\n    method?: string;\n    payload: unknown[];\n    error: boolean;\n    timeout?: number;\n    __proxy_internal: 'reply' | 'call' | 'wait' | 'wait-reply';\n}\n\nexport interface ICallOpt<T, M, P> {\n    timeout?: number;\n    win: WindowProxy | Worker;\n    serviceId: string;\n    method: M;\n    payload: P;\n}\n\n// 当前消息的id，每次自增\nlet MessageID = 0;\nconst getMessageId = () => MessageID++;\n\n// 已注册的服务\nconst services = new Set();\n// 等待服务注册的回调\nconst waitServiceCallbacks: Map<string, Function[]> = new Map();\n// 监听等待服务的消息\nself.addEventListener('message', e => {\n    const message = e.data as IMessageType;\n    // 不是代理的消息忽略\n    if (typeof message !== 'object' || Reflect.get(message, '__proxy_internal') !== 'wait') {\n        return;\n    }\n    // 去除等待服务id\n    const serviceId = message.receiver;\n    // 插入一个回调函数，回复消息，设置一个超时时间\n    const timeout_ = setTimeout(() => {\n        const callbacks = (waitServiceCallbacks.get(serviceId) || []).filter(c => c !== callback);\n        waitServiceCallbacks.set(serviceId, callbacks);\n        (e.source || self).postMessage({\n            __proxy_internal: 'wait-reply',\n            error: true,\n            id: message.id,\n            payload: [`[proxy]wait for service ${serviceId} timeout.`]\n        } as IMessageType, {\n            targetOrigin: '*'\n        });\n    }, message!.timeout);\n    const callback = () => {\n        clearTimeout(timeout_);\n        (e.source || self).postMessage({\n            __proxy_internal: 'wait-reply',\n            id: message.id,\n            error: false,\n            payload: []\n        } as IMessageType, {\n            targetOrigin: '*'\n        });\n        const callbacks = (waitServiceCallbacks.get(serviceId) || []).filter(c => c !== callback);\n        waitServiceCallbacks.set(serviceId, callbacks);\n    };\n    // 将回调函数加入队列\n    const callbacks = waitServiceCallbacks.get(serviceId) || [];\n    callbacks.push(callback);\n    waitServiceCallbacks.set(serviceId, callbacks);\n    // 如果服务已经注册过了，直接调用 callback\n    if (services.has(serviceId)) {\n        callback();\n    }\n});\n\n/**\n * 注册一个可以被其他 Window 通过 postMessage 调用的对象\n * @param serviceId 服务的名称\n * @param obj 要被代理的对象\n */\nexport function registerProxy<T extends Object>(serviceId: string, obj: T) {\n    // 如果有等待这个服务的回调，现在就可以调用了\n    const callbacks = waitServiceCallbacks.get(serviceId);\n    if (callbacks) callbacks.forEach(callback => callback());\n    // 监听事件\n    const serviceHandler = async e => {\n        const message = e.data as IMessageType;\n        // 不是代理的消息忽略\n        if (typeof message !== 'object' || Reflect.get(message, '__proxy_internal') !== 'call') {\n            return;\n        }\n        if (message.receiver === serviceId) {\n            const method = Reflect.get(obj, message.method) as unknown | ((...args: unknown[]) => unknown);\n            // 调用了不存在的方法，回复对方一个错误\n            if (!method) {\n                (e.source || self).postMessage({\n                    __proxy_internal: 'reply',\n                    id: message.id,\n                    error: true,\n                    payload: [`[proxy] method \\`${message.method}\\` does not exist on remote object ${message.receiver} or it is not a function.`]\n                } as IMessageType, {\n                    targetOrigin: '*'\n                });\n            }\n            let res: unknown = method;\n            if (typeof method === \"function\") {\n                // 调用方法回复结果\n                res = await method.call(obj, ...message.payload, e);\n            }\n            logger.debug('[proxy] reply', self?.location?.href || 'worker', e.source, message.receiver, message.method, (e.source || self));\n            (e.source || self).postMessage({\n                __proxy_internal: 'reply',\n                id: message.id,\n                error: false,\n                payload: [res]\n            } as IMessageType, {\n                targetOrigin: '*'\n            });\n        }\n    };\n    self.addEventListener('message', serviceHandler);\n    return () => {\n        self.removeEventListener('message', serviceHandler);\n    };\n}\n\n/**\n * 等待目标上下文的某个服务准备好\n * @param win 目标上下文\n * @param serviceId 要等待的服务\n * @param timeout 超时时间\n */\nexport async function waitProxy(win: WindowProxy | Worker, serviceId: string, timeout = 10000) {\n    return new Promise((resolve, reject) => {\n        const messageId = getMessageId();\n        // 监听的自己的事件，处理回复的消息\n        const timeout_ = setTimeout(() => {\n            self.removeEventListener('message', callback);\n            reject(`[proxy] wait for ${serviceId} timeout .`);\n        }, timeout);\n        const callback: EventListener = (e: MessageEvent) => {\n            if ((e.source || self) !== win) return;\n            const message = e.data as IMessageType;\n            if (typeof message !== 'object' || Reflect.get(message, '__proxy_internal') !== 'wait-reply' || message.id !== messageId) {\n                return;\n            }\n            resolve(null);\n            clearTimeout(timeout_);\n            self.removeEventListener('message', callback);\n        };\n        self.addEventListener('message', callback);\n        // 向目标上下文发送一个消息，表示自己在等待某个服务完成\n        win.postMessage({\n            __proxy_internal: 'wait',\n            receiver: serviceId,\n            payload: [],\n            error: false,\n            id: messageId\n        } as IMessageType, {\n            targetOrigin: '*'\n        });\n    });\n}\n\n/**\n * 调用 win 上下文中提供的服务\n * @param win 要调用的服务所在的上下文\n * @param serviceId 服务的名称\n * @param method 调用的方法\n * @param payload 要传递的参数\n * @param timeout 超时时间\n */\nexport async function callProxy<\n    T extends Object,\n    M extends keyof T = any,\n    P = T[M] extends (...args: unknown[]) => any ? Parameters<T[M]> : any\n>({ win, serviceId, method, payload, timeout = 10000 }: ICallOpt<T, M, P>) {\n    return new Promise<unknown>((resolve, reject) => {\n        const messageId = getMessageId();\n        // 如果调用的是 worker，需要在 worker 上监听\n        let handler: Pick<Window, 'removeEventListener' | 'addEventListener'> = self;\n        if (win instanceof Worker) {\n            handler = win;\n        }\n        // 注册等待回复的消息\n        let timeout_ = setTimeout(() => {\n            reject(`call remote object ${serviceId} method ${method.toString()} timeout`);\n            handler.removeEventListener('message', callback);\n        }, timeout);\n        const callback: EventListener = (e: MessageEvent) => {\n            if (!(win instanceof Worker) && (e.source || self) !== win) return;\n            const message = e.data as IMessageType;\n            if (typeof message !== 'object' || Reflect.get(message, '__proxy_internal') !== 'reply' || message.id !== messageId) return;\n            handler.removeEventListener('message', callback);\n            clearTimeout(timeout_);\n            logger.debug('[proxy] receive reply', self?.location?.href || 'worker', message.id);\n            if (message.error) {\n                reject(message.payload[0]);\n                return;\n            }\n            resolve(message.payload[0]);\n        };\n        handler.addEventListener('message', callback);\n        logger.debug('[proxy] call', self?.location?.href || 'worker', serviceId, method);\n        // 调用远程的方法\n        win.postMessage({\n            id: messageId,\n            __proxy_internal: 'call',\n            receiver: serviceId,\n            method,\n            payload,\n            error: false\n        } as IMessageType, {\n            targetOrigin: '*'\n        });\n    });\n}\n"],"names":["callbacks","_a"],"mappings":"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"}