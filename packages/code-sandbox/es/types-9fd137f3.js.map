{"version":3,"file":"types-9fd137f3.js","sources":["../src/plugins/types.ts"],"sourcesContent":["import { IRequireCtx } from '../core/amd/types';\nimport * as module from \"module\";\n\n/**\n * 依赖元数据\n */\nexport interface IResolveModuleMeta {\n    packageName: string;\n    version?: string;\n    file?: string;\n}\n\nexport interface IDefineModuleMeta {\n    name: string;\n    deps?: string[];\n    factory: string;\n}\n\nexport interface IPlugin {\n    pluginId: string;\n    /**\n     * 确定依赖的引用地址钩子\n     * @param meta 依赖的元数据信息\n     * @return result 元数据信息或者依赖的地址，返回地址时，会直接短路，后续插件的本钩子将不再执行\n     */\n    resolveModuleUrl: (meta: IResolveModuleMeta) => Promise<string | IResolveModuleMeta>;\n    /**\n     * 引用模块之前的钩子，可以用于将对 A 的 require 映射到 B 模块上\n     * @param ctx 调用 require 时的上下文\n     * @param modules 即将被 require 的模块名称\n     * @return modules 真正被 require 的名称\n     */\n    require: (ctx: IRequireCtx, modules: string[] | string) => Promise<string[] | string>;\n    /**\n     * 模块生成之前的钩子\n     * @param ctx 调用即将生成的模块的上下文\n     * @param meta 传入即将生成的模块的元数据\n     * @return meta 处理后的元数据\n     */\n    beforeModuleGenerate: (ctx: IRequireCtx, meta: IDefineModuleMeta) => Promise<Omit<IDefineModuleMeta, 'name'>>;\n}\n\nexport class BasePlugin implements IPlugin {\n    pluginId = 'base';\n    async resolveModuleUrl(meta: IResolveModuleMeta): Promise<IResolveModuleMeta | string> {\n        return meta;\n    }\n\n    async require(ctx: IRequireCtx, modules: string[] | string) {\n        return modules;\n    }\n\n    async beforeModuleGenerate(ctx: IRequireCtx, meta: IDefineModuleMeta) {\n        return meta;\n    }\n}\n"],"names":[],"mappings":"AA0CO,MAAM,WAA8B;AAAA,EAApC,cAAA;AACQ,SAAA,WAAA;AAAA,EAAA;AAAA,EACX,MAAM,iBAAiB,MAAgE;AAC5E,WAAA;AAAA,EACX;AAAA,EAEA,MAAM,QAAQ,KAAkB,SAA4B;AACjD,WAAA;AAAA,EACX;AAAA,EAEA,MAAM,qBAAqB,KAAkB,MAAyB;AAC3D,WAAA;AAAA,EACX;AACJ;"}