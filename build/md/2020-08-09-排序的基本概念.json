{"ast":{"type":"Document","children":[{"type":"Yaml","value":"title: '各种排序算法总结'\ntags: ['数据结构','排序']","loc":{"start":{"line":1,"column":0},"end":{"line":4,"column":3}},"range":[0,45],"raw":"---\ntitle: '各种排序算法总结'\ntags: ['数据结构','排序']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"排序的基本概念","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":9}},"range":[48,55],"raw":"排序的基本概念"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":9}},"range":[46,55],"raw":"# 排序的基本概念"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"各种排序算法汇总","loc":{"start":{"line":7,"column":3},"end":{"line":7,"column":11}},"range":[60,68],"raw":"各种排序算法汇总"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":11}},"range":[57,68],"raw":"## 各种排序算法汇总"},{"type":"Table","align":[null,null,null,null,null,null,null],"children":[{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"算法","loc":{"start":{"line":9,"column":1},"end":{"line":9,"column":3}},"range":[71,73],"raw":"算法"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":4}},"range":[70,74],"raw":"|算法|"},{"type":"TableCell","children":[{"type":"Str","value":"类别","loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":6}},"range":[74,76],"raw":"类别"}],"loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":7}},"range":[74,77],"raw":"类别|"},{"type":"TableCell","children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":9,"column":7},"end":{"line":9,"column":12}},"range":[77,82],"raw":"时间复杂度"}],"loc":{"start":{"line":9,"column":7},"end":{"line":9,"column":13}},"range":[77,83],"raw":"时间复杂度|"},{"type":"TableCell","children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":9,"column":13},"end":{"line":9,"column":18}},"range":[83,88],"raw":"空间复杂度"}],"loc":{"start":{"line":9,"column":13},"end":{"line":9,"column":19}},"range":[83,89],"raw":"空间复杂度|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":9,"column":19},"end":{"line":9,"column":22}},"range":[89,92],"raw":"稳定性"}],"loc":{"start":{"line":9,"column":19},"end":{"line":9,"column":23}},"range":[89,93],"raw":"稳定性|"},{"type":"TableCell","children":[{"type":"Str","value":"支持顺序存储结构","loc":{"start":{"line":9,"column":23},"end":{"line":9,"column":31}},"range":[93,101],"raw":"支持顺序存储结构"}],"loc":{"start":{"line":9,"column":23},"end":{"line":9,"column":32}},"range":[93,102],"raw":"支持顺序存储结构|"},{"type":"TableCell","children":[{"type":"Str","value":"支持链式存储结构","loc":{"start":{"line":9,"column":32},"end":{"line":9,"column":40}},"range":[102,110],"raw":"支持链式存储结构"}],"loc":{"start":{"line":9,"column":32},"end":{"line":9,"column":41}},"range":[102,111],"raw":"支持链式存储结构|"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":41}},"range":[70,111],"raw":"|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"直接插入排序","loc":{"start":{"line":11,"column":1},"end":{"line":11,"column":7}},"range":[129,135],"raw":"直接插入排序"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":8}},"range":[128,136],"raw":"|直接插入排序|"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":11,"column":8},"end":{"line":11,"column":12}},"range":[136,140],"raw":"插入排序"}],"loc":{"start":{"line":11,"column":8},"end":{"line":11,"column":13}},"range":[136,141],"raw":"插入排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n^{2})$","loc":{"start":{"line":11,"column":13},"end":{"line":11,"column":23}},"range":[141,151],"raw":"$O(n^{2})$"}],"loc":{"start":{"line":11,"column":13},"end":{"line":11,"column":24}},"range":[141,152],"raw":"$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":11,"column":24},"end":{"line":11,"column":30}},"range":[152,158],"raw":"$O(1)$"}],"loc":{"start":{"line":11,"column":24},"end":{"line":11,"column":31}},"range":[152,159],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":11,"column":31},"end":{"line":11,"column":33}},"range":[159,161],"raw":"稳定"}],"loc":{"start":{"line":11,"column":31},"end":{"line":11,"column":34}},"range":[159,162],"raw":"稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":11,"column":34},"end":{"line":11,"column":36}},"range":[162,164],"raw":"支持"}],"loc":{"start":{"line":11,"column":34},"end":{"line":11,"column":37}},"range":[162,165],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":11,"column":37},"end":{"line":11,"column":39}},"range":[165,167],"raw":"支持"}],"loc":{"start":{"line":11,"column":37},"end":{"line":11,"column":40}},"range":[165,168],"raw":"支持|"}],"loc":{"start":{"line":11,"column":0},"end":{"line":11,"column":40}},"range":[128,168],"raw":"|直接插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"折半插入排序","loc":{"start":{"line":12,"column":1},"end":{"line":12,"column":7}},"range":[170,176],"raw":"折半插入排序"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":8}},"range":[169,177],"raw":"|折半插入排序|"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":12,"column":8},"end":{"line":12,"column":12}},"range":[177,181],"raw":"插入排序"}],"loc":{"start":{"line":12,"column":8},"end":{"line":12,"column":13}},"range":[177,182],"raw":"插入排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n^{2})$","loc":{"start":{"line":12,"column":13},"end":{"line":12,"column":23}},"range":[182,192],"raw":"$O(n^{2})$"}],"loc":{"start":{"line":12,"column":13},"end":{"line":12,"column":24}},"range":[182,193],"raw":"$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":12,"column":24},"end":{"line":12,"column":30}},"range":[193,199],"raw":"$O(1)$"}],"loc":{"start":{"line":12,"column":24},"end":{"line":12,"column":31}},"range":[193,200],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":12,"column":31},"end":{"line":12,"column":33}},"range":[200,202],"raw":"稳定"}],"loc":{"start":{"line":12,"column":31},"end":{"line":12,"column":34}},"range":[200,203],"raw":"稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":12,"column":34},"end":{"line":12,"column":36}},"range":[203,205],"raw":"支持"}],"loc":{"start":{"line":12,"column":34},"end":{"line":12,"column":37}},"range":[203,206],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"不支持","loc":{"start":{"line":12,"column":37},"end":{"line":12,"column":40}},"range":[206,209],"raw":"不支持"}],"loc":{"start":{"line":12,"column":37},"end":{"line":12,"column":41}},"range":[206,210],"raw":"不支持|"}],"loc":{"start":{"line":12,"column":0},"end":{"line":12,"column":41}},"range":[169,210],"raw":"|折半插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|不支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"希尔排序","loc":{"start":{"line":13,"column":1},"end":{"line":13,"column":5}},"range":[212,216],"raw":"希尔排序"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":6}},"range":[211,217],"raw":"|希尔排序|"},{"type":"TableCell","children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":13,"column":6},"end":{"line":13,"column":10}},"range":[217,221],"raw":"插入排序"}],"loc":{"start":{"line":13,"column":6},"end":{"line":13,"column":11}},"range":[217,222],"raw":"插入排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n^{2})$","loc":{"start":{"line":13,"column":11},"end":{"line":13,"column":21}},"range":[222,232],"raw":"$O(n^{2})$"}],"loc":{"start":{"line":13,"column":11},"end":{"line":13,"column":22}},"range":[222,233],"raw":"$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":13,"column":22},"end":{"line":13,"column":28}},"range":[233,239],"raw":"$O(1)$"}],"loc":{"start":{"line":13,"column":22},"end":{"line":13,"column":29}},"range":[233,240],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":13,"column":29},"end":{"line":13,"column":32}},"range":[240,243],"raw":"不稳定"}],"loc":{"start":{"line":13,"column":29},"end":{"line":13,"column":33}},"range":[240,244],"raw":"不稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":13,"column":33},"end":{"line":13,"column":35}},"range":[244,246],"raw":"支持"}],"loc":{"start":{"line":13,"column":33},"end":{"line":13,"column":36}},"range":[244,247],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"不支持","loc":{"start":{"line":13,"column":36},"end":{"line":13,"column":39}},"range":[247,250],"raw":"不支持"}],"loc":{"start":{"line":13,"column":36},"end":{"line":13,"column":40}},"range":[247,251],"raw":"不支持|"}],"loc":{"start":{"line":13,"column":0},"end":{"line":13,"column":40}},"range":[211,251],"raw":"|希尔排序|插入排序|$O(n^{2})$|$O(1)$|不稳定|支持|不支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"冒泡排序","loc":{"start":{"line":14,"column":1},"end":{"line":14,"column":5}},"range":[253,257],"raw":"冒泡排序"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":6}},"range":[252,258],"raw":"|冒泡排序|"},{"type":"TableCell","children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":14,"column":6},"end":{"line":14,"column":10}},"range":[258,262],"raw":"交换排序"}],"loc":{"start":{"line":14,"column":6},"end":{"line":14,"column":11}},"range":[258,263],"raw":"交换排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n^{2})$","loc":{"start":{"line":14,"column":11},"end":{"line":14,"column":21}},"range":[263,273],"raw":"$O(n^{2})$"}],"loc":{"start":{"line":14,"column":11},"end":{"line":14,"column":22}},"range":[263,274],"raw":"$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":14,"column":22},"end":{"line":14,"column":28}},"range":[274,280],"raw":"$O(1)$"}],"loc":{"start":{"line":14,"column":22},"end":{"line":14,"column":29}},"range":[274,281],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":14,"column":29},"end":{"line":14,"column":31}},"range":[281,283],"raw":"稳定"}],"loc":{"start":{"line":14,"column":29},"end":{"line":14,"column":32}},"range":[281,284],"raw":"稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":14,"column":32},"end":{"line":14,"column":34}},"range":[284,286],"raw":"支持"}],"loc":{"start":{"line":14,"column":32},"end":{"line":14,"column":35}},"range":[284,287],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":14,"column":35},"end":{"line":14,"column":37}},"range":[287,289],"raw":"支持"}],"loc":{"start":{"line":14,"column":35},"end":{"line":14,"column":38}},"range":[287,290],"raw":"支持|"}],"loc":{"start":{"line":14,"column":0},"end":{"line":14,"column":38}},"range":[252,290],"raw":"|冒泡排序|交换排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"快速排序","loc":{"start":{"line":15,"column":1},"end":{"line":15,"column":5}},"range":[292,296],"raw":"快速排序"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":6}},"range":[291,297],"raw":"|快速排序|"},{"type":"TableCell","children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":15,"column":6},"end":{"line":15,"column":10}},"range":[297,301],"raw":"交换排序"}],"loc":{"start":{"line":15,"column":6},"end":{"line":15,"column":11}},"range":[297,302],"raw":"交换排序|"},{"type":"TableCell","children":[{"type":"Str","value":"最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$","loc":{"start":{"line":15,"column":11},"end":{"line":15,"column":47}},"range":[302,338],"raw":"最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$"}],"loc":{"start":{"line":15,"column":11},"end":{"line":15,"column":48}},"range":[302,339],"raw":"最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"最好、平均：$O(log_{2}(n))$，最坏：$O(n)$","loc":{"start":{"line":15,"column":48},"end":{"line":15,"column":79}},"range":[339,370],"raw":"最好、平均：$O(log_{2}(n))$，最坏：$O(n)$"}],"loc":{"start":{"line":15,"column":48},"end":{"line":15,"column":80}},"range":[339,371],"raw":"最好、平均：$O(log_{2}(n))$，最坏：$O(n)$|"},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":15,"column":80},"end":{"line":15,"column":83}},"range":[371,374],"raw":"不稳定"}],"loc":{"start":{"line":15,"column":80},"end":{"line":15,"column":84}},"range":[371,375],"raw":"不稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":15,"column":84},"end":{"line":15,"column":86}},"range":[375,377],"raw":"支持"}],"loc":{"start":{"line":15,"column":84},"end":{"line":15,"column":87}},"range":[375,378],"raw":"支持|"},{"type":"TableCell","children":[],"loc":{"start":{"line":15,"column":87},"end":{"line":15,"column":88}},"range":[378,379],"raw":"|"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":88}},"range":[291,379],"raw":"|快速排序|交换排序|最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$|最好、平均：$O(log_{2}(n))$，最坏：$O(n)$|不稳定|支持||"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"简单选择排序","loc":{"start":{"line":16,"column":1},"end":{"line":16,"column":7}},"range":[381,387],"raw":"简单选择排序"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":8}},"range":[380,388],"raw":"|简单选择排序|"},{"type":"TableCell","children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":16,"column":8},"end":{"line":16,"column":12}},"range":[388,392],"raw":"选择排序"}],"loc":{"start":{"line":16,"column":8},"end":{"line":16,"column":13}},"range":[388,393],"raw":"选择排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n^{2})$","loc":{"start":{"line":16,"column":13},"end":{"line":16,"column":23}},"range":[393,403],"raw":"$O(n^{2})$"}],"loc":{"start":{"line":16,"column":13},"end":{"line":16,"column":24}},"range":[393,404],"raw":"$O(n^{2})$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":16,"column":24},"end":{"line":16,"column":30}},"range":[404,410],"raw":"$O(1)$"}],"loc":{"start":{"line":16,"column":24},"end":{"line":16,"column":31}},"range":[404,411],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":16,"column":31},"end":{"line":16,"column":34}},"range":[411,414],"raw":"不稳定"}],"loc":{"start":{"line":16,"column":31},"end":{"line":16,"column":35}},"range":[411,415],"raw":"不稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":16,"column":35},"end":{"line":16,"column":37}},"range":[415,417],"raw":"支持"}],"loc":{"start":{"line":16,"column":35},"end":{"line":16,"column":38}},"range":[415,418],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":16,"column":38},"end":{"line":16,"column":40}},"range":[418,420],"raw":"支持"}],"loc":{"start":{"line":16,"column":38},"end":{"line":16,"column":41}},"range":[418,421],"raw":"支持|"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":41}},"range":[380,421],"raw":"|简单选择排序|选择排序|$O(n^{2})$|$O(1)$|不稳定|支持|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"堆排序","loc":{"start":{"line":17,"column":1},"end":{"line":17,"column":4}},"range":[423,426],"raw":"堆排序"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":5}},"range":[422,427],"raw":"|堆排序|"},{"type":"TableCell","children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":17,"column":5},"end":{"line":17,"column":9}},"range":[427,431],"raw":"选择排序"}],"loc":{"start":{"line":17,"column":5},"end":{"line":17,"column":10}},"range":[427,432],"raw":"选择排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(nlog_{2}(n))$","loc":{"start":{"line":17,"column":10},"end":{"line":17,"column":26}},"range":[432,448],"raw":"$O(nlog_{2}(n))$"}],"loc":{"start":{"line":17,"column":10},"end":{"line":17,"column":27}},"range":[432,449],"raw":"$O(nlog_{2}(n))$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(1)$","loc":{"start":{"line":17,"column":27},"end":{"line":17,"column":33}},"range":[449,455],"raw":"$O(1)$"}],"loc":{"start":{"line":17,"column":27},"end":{"line":17,"column":34}},"range":[449,456],"raw":"$O(1)$|"},{"type":"TableCell","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":17,"column":34},"end":{"line":17,"column":37}},"range":[456,459],"raw":"不稳定"}],"loc":{"start":{"line":17,"column":34},"end":{"line":17,"column":38}},"range":[456,460],"raw":"不稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":17,"column":38},"end":{"line":17,"column":40}},"range":[460,462],"raw":"支持"}],"loc":{"start":{"line":17,"column":38},"end":{"line":17,"column":41}},"range":[460,463],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":17,"column":41},"end":{"line":17,"column":43}},"range":[463,465],"raw":"支持"}],"loc":{"start":{"line":17,"column":41},"end":{"line":17,"column":44}},"range":[463,466],"raw":"支持|"}],"loc":{"start":{"line":17,"column":0},"end":{"line":17,"column":44}},"range":[422,466],"raw":"|堆排序|选择排序|$O(nlog_{2}(n))$|$O(1)$|不稳定|支持|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":18,"column":1},"end":{"line":18,"column":5}},"range":[468,472],"raw":"归并排序"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":6}},"range":[467,473],"raw":"|归并排序|"},{"type":"TableCell","children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":18,"column":6},"end":{"line":18,"column":10}},"range":[473,477],"raw":"归并排序"}],"loc":{"start":{"line":18,"column":6},"end":{"line":18,"column":11}},"range":[473,478],"raw":"归并排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(nlog_{2}(n))$","loc":{"start":{"line":18,"column":11},"end":{"line":18,"column":27}},"range":[478,494],"raw":"$O(nlog_{2}(n))$"}],"loc":{"start":{"line":18,"column":11},"end":{"line":18,"column":28}},"range":[478,495],"raw":"$O(nlog_{2}(n))$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(n)$","loc":{"start":{"line":18,"column":28},"end":{"line":18,"column":34}},"range":[495,501],"raw":"$O(n)$"}],"loc":{"start":{"line":18,"column":28},"end":{"line":18,"column":35}},"range":[495,502],"raw":"$O(n)$|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":18,"column":35},"end":{"line":18,"column":37}},"range":[502,504],"raw":"稳定"}],"loc":{"start":{"line":18,"column":35},"end":{"line":18,"column":38}},"range":[502,505],"raw":"稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":18,"column":38},"end":{"line":18,"column":40}},"range":[505,507],"raw":"支持"}],"loc":{"start":{"line":18,"column":38},"end":{"line":18,"column":41}},"range":[505,508],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":18,"column":41},"end":{"line":18,"column":43}},"range":[508,510],"raw":"支持"}],"loc":{"start":{"line":18,"column":41},"end":{"line":18,"column":44}},"range":[508,511],"raw":"支持|"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":44}},"range":[467,511],"raw":"|归并排序|归并排序|$O(nlog_{2}(n))$|$O(n)$|稳定|支持|支持|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":19,"column":1},"end":{"line":19,"column":5}},"range":[513,517],"raw":"基数排序"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":6}},"range":[512,518],"raw":"|基数排序|"},{"type":"TableCell","children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":19,"column":6},"end":{"line":19,"column":10}},"range":[518,522],"raw":"基数排序"}],"loc":{"start":{"line":19,"column":6},"end":{"line":19,"column":11}},"range":[518,523],"raw":"基数排序|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(d(n+r))$","loc":{"start":{"line":19,"column":11},"end":{"line":19,"column":22}},"range":[523,534],"raw":"$O(d(n+r))$"}],"loc":{"start":{"line":19,"column":11},"end":{"line":19,"column":23}},"range":[523,535],"raw":"$O(d(n+r))$|"},{"type":"TableCell","children":[{"type":"Str","value":"$O(r)$","loc":{"start":{"line":19,"column":23},"end":{"line":19,"column":29}},"range":[535,541],"raw":"$O(r)$"}],"loc":{"start":{"line":19,"column":23},"end":{"line":19,"column":30}},"range":[535,542],"raw":"$O(r)$|"},{"type":"TableCell","children":[{"type":"Str","value":"稳定","loc":{"start":{"line":19,"column":30},"end":{"line":19,"column":32}},"range":[542,544],"raw":"稳定"}],"loc":{"start":{"line":19,"column":30},"end":{"line":19,"column":33}},"range":[542,545],"raw":"稳定|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":19,"column":33},"end":{"line":19,"column":35}},"range":[545,547],"raw":"支持"}],"loc":{"start":{"line":19,"column":33},"end":{"line":19,"column":36}},"range":[545,548],"raw":"支持|"},{"type":"TableCell","children":[{"type":"Str","value":"支持","loc":{"start":{"line":19,"column":36},"end":{"line":19,"column":38}},"range":[548,550],"raw":"支持"}],"loc":{"start":{"line":19,"column":36},"end":{"line":19,"column":39}},"range":[548,551],"raw":"支持|"}],"loc":{"start":{"line":19,"column":0},"end":{"line":19,"column":39}},"range":[512,551],"raw":"|基数排序|基数排序|$O(d(n+r))$|$O(r)$|稳定|支持|支持|"}],"loc":{"start":{"line":9,"column":0},"end":{"line":19,"column":39}},"range":[70,551],"raw":"|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构|\n|-|-|-|-|-|-|-|\n|直接插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|\n|折半插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|不支持|\n|希尔排序|插入排序|$O(n^{2})$|$O(1)$|不稳定|支持|不支持|\n|冒泡排序|交换排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|\n|快速排序|交换排序|最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$|最好、平均：$O(log_{2}(n))$，最坏：$O(n)$|不稳定|支持||\n|简单选择排序|选择排序|$O(n^{2})$|$O(1)$|不稳定|支持|支持|\n|堆排序|选择排序|$O(nlog_{2}(n))$|$O(1)$|不稳定|支持|支持|\n|归并排序|归并排序|$O(nlog_{2}(n))$|$O(n)$|稳定|支持|支持|\n|基数排序|基数排序|$O(d(n+r))$|$O(r)$|稳定|支持|支持|"},{"type":"HorizontalRule","loc":{"start":{"line":21,"column":0},"end":{"line":21,"column":5}},"range":[553,558],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"基本概念","loc":{"start":{"line":23,"column":3},"end":{"line":23,"column":7}},"range":[563,567],"raw":"基本概念"}],"loc":{"start":{"line":23,"column":0},"end":{"line":23,"column":7}},"range":[560,567],"raw":"## 基本概念"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的定义","loc":{"start":{"line":25,"column":4},"end":{"line":25,"column":9}},"range":[573,578],"raw":"排序的定义"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":9}},"range":[569,578],"raw":"### 排序的定义"},{"type":"Paragraph","children":[{"type":"Str","value":"重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。","loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":38}},"range":[580,618],"raw":"重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":38}},"range":[580,618],"raw":"重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的时间复杂度和空间复杂度","loc":{"start":{"line":29,"column":4},"end":{"line":29,"column":18}},"range":[624,638],"raw":"排序的时间复杂度和空间复杂度"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":18}},"range":[620,638],"raw":"### 排序的时间复杂度和空间复杂度"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"排序的稳定性","loc":{"start":{"line":31,"column":4},"end":{"line":31,"column":10}},"range":[644,650],"raw":"排序的稳定性"}],"loc":{"start":{"line":31,"column":0},"end":{"line":31,"column":10}},"range":[640,650],"raw":"### 排序的稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"如果表中有两个元素$R_{i}$和$R_{j}$，其对应的关键字$key_{i}=key_{j}$，且$R_{i}$排在$R_{j}$前面，使用某一排序算法后，$R_{i}$仍排在$R_{j}$前面，就称这个算法是稳定的。","loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":111}},"range":[652,763],"raw":"如果表中有两个元素$R_{i}$和$R_{j}$，其对应的关键字$key_{i}=key_{j}$，且$R_{i}$排在$R_{j}$前面，使用某一排序算法后，$R_{i}$仍排在$R_{j}$前面，就称这个算法是稳定的。"}],"loc":{"start":{"line":33,"column":0},"end":{"line":33,"column":111}},"range":[652,763],"raw":"如果表中有两个元素$R_{i}$和$R_{j}$，其对应的关键字$key_{i}=key_{j}$，且$R_{i}$排在$R_{j}$前面，使用某一排序算法后，$R_{i}$仍排在$R_{j}$前面，就称这个算法是稳定的。"},{"type":"HorizontalRule","loc":{"start":{"line":35,"column":0},"end":{"line":35,"column":5}},"range":[765,770],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"内部排序","loc":{"start":{"line":37,"column":3},"end":{"line":37,"column":7}},"range":[775,779],"raw":"内部排序"}],"loc":{"start":{"line":37,"column":0},"end":{"line":37,"column":7}},"range":[772,779],"raw":"## 内部排序"},{"type":"Paragraph","children":[{"type":"Str","value":"排序过程中，所有的元素都存放在内存中的排序。","loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":22}},"range":[781,803],"raw":"排序过程中，所有的元素都存放在内存中的排序。"}],"loc":{"start":{"line":39,"column":0},"end":{"line":39,"column":22}},"range":[781,803],"raw":"排序过程中，所有的元素都存放在内存中的排序。"},{"type":"Paragraph","children":[{"type":"Str","value":"公式：对任意n个元素的列表进行排序的比较次数至少为 $\\lceil log_{2}{(n!)} \\rceil$ 。","loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":57}},"range":[805,862],"raw":"公式：对任意n个元素的列表进行排序的比较次数至少为 $\\lceil log_{2}{(n!)} \\rceil$ 。"}],"loc":{"start":{"line":41,"column":0},"end":{"line":41,"column":57}},"range":[805,862],"raw":"公式：对任意n个元素的列表进行排序的比较次数至少为 $\\lceil log_{2}{(n!)} \\rceil$ 。"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"插入排序","loc":{"start":{"line":43,"column":4},"end":{"line":43,"column":8}},"range":[868,872],"raw":"插入排序"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":8}},"range":[864,872],"raw":"### 插入排序"},{"type":"Paragraph","children":[{"type":"Str","value":"每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。","loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":49}},"range":[874,923],"raw":"每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。"}],"loc":{"start":{"line":45,"column":0},"end":{"line":45,"column":49}},"range":[874,923],"raw":"每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。"},{"type":"HorizontalRule","loc":{"start":{"line":47,"column":0},"end":{"line":47,"column":5}},"range":[925,930],"raw":"*****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"直接插入排序","loc":{"start":{"line":49,"column":5},"end":{"line":49,"column":11}},"range":[937,943],"raw":"直接插入排序"}],"loc":{"start":{"line":49,"column":0},"end":{"line":49,"column":11}},"range":[932,943],"raw":"#### 直接插入排序"},{"type":"Table","align":[null,null,null],"children":[{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"有序序列","loc":{"start":{"line":51,"column":1},"end":{"line":51,"column":5}},"range":[946,950],"raw":"有序序列"}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":6}},"range":[945,951],"raw":"|有序序列|"},{"type":"TableCell","children":[{"type":"Str","value":"要插入的","loc":{"start":{"line":51,"column":6},"end":{"line":51,"column":10}},"range":[951,955],"raw":"要插入的"}],"loc":{"start":{"line":51,"column":6},"end":{"line":51,"column":11}},"range":[951,956],"raw":"要插入的|"},{"type":"TableCell","children":[{"type":"Str","value":"无序序列","loc":{"start":{"line":51,"column":11},"end":{"line":51,"column":15}},"range":[956,960],"raw":"无序序列"}],"loc":{"start":{"line":51,"column":11},"end":{"line":51,"column":16}},"range":[956,961],"raw":"无序序列|"}],"loc":{"start":{"line":51,"column":0},"end":{"line":51,"column":16}},"range":[945,961],"raw":"|有序序列|要插入的|无序序列|"},{"type":"TableRow","children":[{"type":"TableCell","children":[{"type":"Str","value":"$L[1...i-1]$","loc":{"start":{"line":53,"column":1},"end":{"line":53,"column":13}},"range":[971,983],"raw":"$L[1...i-1]$"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":14}},"range":[970,984],"raw":"|$L[1...i-1]$|"},{"type":"TableCell","children":[{"type":"Str","value":"$L(i)$","loc":{"start":{"line":53,"column":14},"end":{"line":53,"column":20}},"range":[984,990],"raw":"$L(i)$"}],"loc":{"start":{"line":53,"column":14},"end":{"line":53,"column":21}},"range":[984,991],"raw":"$L(i)$|"},{"type":"TableCell","children":[{"type":"Str","value":"$L[i+1...n]$","loc":{"start":{"line":53,"column":21},"end":{"line":53,"column":33}},"range":[991,1003],"raw":"$L[i+1...n]$"}],"loc":{"start":{"line":53,"column":21},"end":{"line":53,"column":34}},"range":[991,1004],"raw":"$L[i+1...n]$|"}],"loc":{"start":{"line":53,"column":0},"end":{"line":53,"column":34}},"range":[970,1004],"raw":"|$L[1...i-1]$|$L(i)$|$L[i+1...n]$|"}],"loc":{"start":{"line":51,"column":0},"end":{"line":53,"column":34}},"range":[945,1004],"raw":"|有序序列|要插入的|无序序列|\n|-|-|-|\n|$L[1...i-1]$|$L(i)$|$L[i+1...n]$|"},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"查找$L(i)$的插入位置k；","loc":{"start":{"line":55,"column":3},"end":{"line":55,"column":18}},"range":[1009,1024],"raw":"查找$L(i)$的插入位置k；"}],"loc":{"start":{"line":55,"column":3},"end":{"line":55,"column":18}},"range":[1009,1024],"raw":"查找$L(i)$的插入位置k；"}],"loc":{"start":{"line":55,"column":0},"end":{"line":55,"column":18}},"range":[1006,1024],"raw":"1. 查找$L(i)$的插入位置k；"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"将$L[k...i-1]$所有的元素都向后移动一个位置；","loc":{"start":{"line":56,"column":3},"end":{"line":56,"column":31}},"range":[1028,1056],"raw":"将$L[k...i-1]$所有的元素都向后移动一个位置；"}],"loc":{"start":{"line":56,"column":3},"end":{"line":56,"column":31}},"range":[1028,1056],"raw":"将$L[k...i-1]$所有的元素都向后移动一个位置；"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":31}},"range":[1025,1056],"raw":"2. 将$L[k...i-1]$所有的元素都向后移动一个位置；"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"将$L(i)$复制到k的位置。","loc":{"start":{"line":57,"column":3},"end":{"line":57,"column":18}},"range":[1060,1075],"raw":"将$L(i)$复制到k的位置。"}],"loc":{"start":{"line":57,"column":3},"end":{"line":57,"column":18}},"range":[1060,1075],"raw":"将$L(i)$复制到k的位置。"}],"loc":{"start":{"line":57,"column":0},"end":{"line":57,"column":18}},"range":[1057,1075],"raw":"3. 将$L(i)$复制到k的位置。"}],"loc":{"start":{"line":55,"column":0},"end":{"line":57,"column":18}},"range":[1006,1075],"raw":"1. 查找$L(i)$的插入位置k；\n2. 将$L[k...i-1]$所有的元素都向后移动一个位置；\n3. 将$L(i)$复制到k的位置。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":59,"column":6},"end":{"line":59,"column":10}},"range":[1083,1087],"raw":"代码实现"}],"loc":{"start":{"line":59,"column":0},"end":{"line":59,"column":10}},"range":[1077,1087],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}","loc":{"start":{"line":61,"column":0},"end":{"line":70,"column":3}},"range":[1089,1305],"raw":"```c\nvoid InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":72,"column":6},"end":{"line":72,"column":11}},"range":[1313,1318],"raw":"时间复杂度"}],"loc":{"start":{"line":72,"column":0},"end":{"line":72,"column":11}},"range":[1307,1318],"raw":"##### 时间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为$O(n^{2})$。","loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":41}},"range":[1320,1361],"raw":"当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为$O(n^{2})$。"}],"loc":{"start":{"line":74,"column":0},"end":{"line":74,"column":41}},"range":[1320,1361],"raw":"当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为$O(n^{2})$。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":76,"column":6},"end":{"line":76,"column":11}},"range":[1369,1374],"raw":"空间复杂度"}],"loc":{"start":{"line":76,"column":0},"end":{"line":76,"column":11}},"range":[1363,1374],"raw":"##### 空间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"只用到一个用于赋值的临时变量，空间复杂度为O(1)。","loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":26}},"range":[1376,1402],"raw":"只用到一个用于赋值的临时变量，空间复杂度为O(1)。"}],"loc":{"start":{"line":78,"column":0},"end":{"line":78,"column":26}},"range":[1376,1402],"raw":"只用到一个用于赋值的临时变量，空间复杂度为O(1)。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":80,"column":6},"end":{"line":80,"column":9}},"range":[1410,1413],"raw":"稳定性"}],"loc":{"start":{"line":80,"column":0},"end":{"line":80,"column":9}},"range":[1404,1413],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。","loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":50}},"range":[1415,1465],"raw":"比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。"}],"loc":{"start":{"line":82,"column":0},"end":{"line":82,"column":50}},"range":[1415,1465],"raw":"比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":84,"column":6},"end":{"line":84,"column":10}},"range":[1473,1477],"raw":"存储结构"}],"loc":{"start":{"line":84,"column":0},"end":{"line":84,"column":10}},"range":[1467,1477],"raw":"##### 存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储","loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":36}},"range":[1479,1515],"raw":"排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储"}],"loc":{"start":{"line":86,"column":0},"end":{"line":86,"column":36}},"range":[1479,1515],"raw":"排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储"},{"type":"HorizontalRule","loc":{"start":{"line":88,"column":0},"end":{"line":88,"column":5}},"range":[1517,1522],"raw":"*****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"折半插入排序（二分插入排序）","loc":{"start":{"line":90,"column":5},"end":{"line":90,"column":19}},"range":[1529,1543],"raw":"折半插入排序（二分插入排序）"}],"loc":{"start":{"line":90,"column":0},"end":{"line":90,"column":19}},"range":[1524,1543],"raw":"#### 折半插入排序（二分插入排序）"},{"type":"Paragraph","children":[{"type":"Str","value":"使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。","loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":40}},"range":[1545,1585],"raw":"使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。"}],"loc":{"start":{"line":92,"column":0},"end":{"line":92,"column":40}},"range":[1545,1585],"raw":"使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":94,"column":6},"end":{"line":94,"column":10}},"range":[1593,1597],"raw":"代码实现"}],"loc":{"start":{"line":94,"column":0},"end":{"line":94,"column":10}},"range":[1587,1597],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}","loc":{"start":{"line":96,"column":0},"end":{"line":119,"column":3}},"range":[1599,2132],"raw":"```c\nvoid BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":121,"column":6},"end":{"line":121,"column":11}},"range":[2140,2145],"raw":"时间复杂度"}],"loc":{"start":{"line":121,"column":0},"end":{"line":121,"column":11}},"range":[2134,2145],"raw":"##### 时间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"由于查找过程使用了二分查找，所以其时间复杂度是$O(n","loc":{"start":{"line":123,"column":0},"end":{"line":123,"column":27}},"range":[2147,2174],"raw":"由于查找过程使用了二分查找，所以其时间复杂度是$O(n"},{"type":"Emphasis","children":[{"type":"Str","value":"n","loc":{"start":{"line":123,"column":28},"end":{"line":123,"column":29}},"range":[2175,2176],"raw":"n"}],"loc":{"start":{"line":123,"column":27},"end":{"line":123,"column":30}},"range":[2174,2177],"raw":"*n*"},{"type":"Str","value":"log_{2}(n))=O(n^{2})$。","loc":{"start":{"line":123,"column":30},"end":{"line":123,"column":52}},"range":[2177,2199],"raw":"log_{2}(n))=O(n^{2})$。"}],"loc":{"start":{"line":123,"column":0},"end":{"line":123,"column":52}},"range":[2147,2199],"raw":"由于查找过程使用了二分查找，所以其时间复杂度是$O(n*n*log_{2}(n))=O(n^{2})$。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":125,"column":6},"end":{"line":125,"column":11}},"range":[2207,2212],"raw":"空间复杂度"}],"loc":{"start":{"line":125,"column":0},"end":{"line":125,"column":11}},"range":[2201,2212],"raw":"##### 空间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"只是用到了常数个额外的内存空间，所以其空间复杂度是$O(1)$。","loc":{"start":{"line":127,"column":0},"end":{"line":127,"column":32}},"range":[2214,2246],"raw":"只是用到了常数个额外的内存空间，所以其空间复杂度是$O(1)$。"}],"loc":{"start":{"line":127,"column":0},"end":{"line":127,"column":32}},"range":[2214,2246],"raw":"只是用到了常数个额外的内存空间，所以其空间复杂度是$O(1)$。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"排序稳定性","loc":{"start":{"line":129,"column":6},"end":{"line":129,"column":11}},"range":[2254,2259],"raw":"排序稳定性"}],"loc":{"start":{"line":129,"column":0},"end":{"line":129,"column":11}},"range":[2248,2259],"raw":"##### 排序稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"与直接插入排序相同","loc":{"start":{"line":131,"column":0},"end":{"line":131,"column":9}},"range":[2261,2270],"raw":"与直接插入排序相同"}],"loc":{"start":{"line":131,"column":0},"end":{"line":131,"column":9}},"range":[2261,2270],"raw":"与直接插入排序相同"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":133,"column":6},"end":{"line":133,"column":10}},"range":[2278,2282],"raw":"存储结构"}],"loc":{"start":{"line":133,"column":0},"end":{"line":133,"column":10}},"range":[2272,2282],"raw":"##### 存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"由于使用了二分查找，所以只能适用于顺序存储的线性表","loc":{"start":{"line":135,"column":0},"end":{"line":135,"column":25}},"range":[2284,2309],"raw":"由于使用了二分查找，所以只能适用于顺序存储的线性表"}],"loc":{"start":{"line":135,"column":0},"end":{"line":135,"column":25}},"range":[2284,2309],"raw":"由于使用了二分查找，所以只能适用于顺序存储的线性表"},{"type":"HorizontalRule","loc":{"start":{"line":137,"column":0},"end":{"line":137,"column":5}},"range":[2311,2316],"raw":"*****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"希尔排序（缩小增量排序）","loc":{"start":{"line":139,"column":5},"end":{"line":139,"column":17}},"range":[2323,2335],"raw":"希尔排序（缩小增量排序）"}],"loc":{"start":{"line":139,"column":0},"end":{"line":139,"column":17}},"range":[2318,2335],"raw":"#### 希尔排序（缩小增量排序）"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列","loc":{"start":{"line":141,"column":2},"end":{"line":141,"column":55}},"range":[2339,2392],"raw":"先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列"}],"loc":{"start":{"line":141,"column":2},"end":{"line":141,"column":55}},"range":[2339,2392],"raw":"先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列"}],"loc":{"start":{"line":141,"column":0},"end":{"line":141,"column":55}},"range":[2337,2392],"raw":"- 先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"对各个子序列进行直接插入排序","loc":{"start":{"line":142,"column":2},"end":{"line":142,"column":16}},"range":[2395,2409],"raw":"对各个子序列进行直接插入排序"}],"loc":{"start":{"line":142,"column":2},"end":{"line":142,"column":16}},"range":[2395,2409],"raw":"对各个子序列进行直接插入排序"}],"loc":{"start":{"line":142,"column":0},"end":{"line":142,"column":16}},"range":[2393,2409],"raw":"- 对各个子序列进行直接插入排序"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成","loc":{"start":{"line":143,"column":2},"end":{"line":143,"column":34}},"range":[2412,2444],"raw":"令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成"}],"loc":{"start":{"line":143,"column":2},"end":{"line":143,"column":34}},"range":[2412,2444],"raw":"令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成"}],"loc":{"start":{"line":143,"column":0},"end":{"line":143,"column":34}},"range":[2410,2444],"raw":"- 令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成"}],"loc":{"start":{"line":141,"column":0},"end":{"line":143,"column":34}},"range":[2337,2444],"raw":"- 先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列\n- 对各个子序列进行直接插入排序\n- 令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成"},{"type":"Paragraph","children":[{"type":"Str","value":"$d_{1}=\\lfloor \\frac{n}{2} \\rfloor,; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,;...;,d_{n}=1$","loc":{"start":{"line":145,"column":0},"end":{"line":145,"column":92}},"range":[2446,2538],"raw":"$d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1$"}],"loc":{"start":{"line":145,"column":0},"end":{"line":145,"column":92}},"range":[2446,2538],"raw":"$d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":147,"column":6},"end":{"line":147,"column":10}},"range":[2546,2550],"raw":"代码实现"}],"loc":{"start":{"line":147,"column":0},"end":{"line":147,"column":10}},"range":[2540,2550],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}","loc":{"start":{"line":149,"column":0},"end":{"line":164,"column":3}},"range":[2552,2950],"raw":"```c\nvoid ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时间复杂度","loc":{"start":{"line":166,"column":6},"end":{"line":166,"column":11}},"range":[2958,2963],"raw":"时间复杂度"}],"loc":{"start":{"line":166,"column":0},"end":{"line":166,"column":11}},"range":[2952,2963],"raw":"##### 时间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"希尔排序的时间复杂度$O(n^{2})$，n在某一个范围之内的时候，希尔排序的时间复杂度可以到$O(n^{1.3})$","loc":{"start":{"line":168,"column":0},"end":{"line":168,"column":59}},"range":[2965,3024],"raw":"希尔排序的时间复杂度$O(n^{2})$，n在某一个范围之内的时候，希尔排序的时间复杂度可以到$O(n^{1.3})$"}],"loc":{"start":{"line":168,"column":0},"end":{"line":168,"column":59}},"range":[2965,3024],"raw":"希尔排序的时间复杂度$O(n^{2})$，n在某一个范围之内的时候，希尔排序的时间复杂度可以到$O(n^{1.3})$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"空间复杂度","loc":{"start":{"line":170,"column":6},"end":{"line":170,"column":11}},"range":[3032,3037],"raw":"空间复杂度"}],"loc":{"start":{"line":170,"column":0},"end":{"line":170,"column":11}},"range":[3026,3037],"raw":"##### 空间复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"辅助空间是常数级的，空间复杂度是$O(1)$。","loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":23}},"range":[3039,3062],"raw":"辅助空间是常数级的，空间复杂度是$O(1)$。"}],"loc":{"start":{"line":172,"column":0},"end":{"line":172,"column":23}},"range":[3039,3062],"raw":"辅助空间是常数级的，空间复杂度是$O(1)$。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"希尔排序的稳定性","loc":{"start":{"line":174,"column":6},"end":{"line":174,"column":14}},"range":[3070,3078],"raw":"希尔排序的稳定性"}],"loc":{"start":{"line":174,"column":0},"end":{"line":174,"column":14}},"range":[3064,3078],"raw":"##### 希尔排序的稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。","loc":{"start":{"line":176,"column":0},"end":{"line":176,"column":41}},"range":[3080,3121],"raw":"希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。"}],"loc":{"start":{"line":176,"column":0},"end":{"line":176,"column":41}},"range":[3080,3121],"raw":"希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"希尔排序的存储结构","loc":{"start":{"line":178,"column":6},"end":{"line":178,"column":15}},"range":[3129,3138],"raw":"希尔排序的存储结构"}],"loc":{"start":{"line":178,"column":0},"end":{"line":178,"column":15}},"range":[3123,3138],"raw":"##### 希尔排序的存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。","loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":31}},"range":[3140,3171],"raw":"用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。"}],"loc":{"start":{"line":180,"column":0},"end":{"line":180,"column":31}},"range":[3140,3171],"raw":"用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。"},{"type":"HorizontalRule","loc":{"start":{"line":182,"column":0},"end":{"line":182,"column":5}},"range":[3173,3178],"raw":"*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"交换排序","loc":{"start":{"line":184,"column":4},"end":{"line":184,"column":8}},"range":[3184,3188],"raw":"交换排序"}],"loc":{"start":{"line":184,"column":0},"end":{"line":184,"column":8}},"range":[3180,3188],"raw":"### 交换排序"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"冒泡排序","loc":{"start":{"line":186,"column":5},"end":{"line":186,"column":9}},"range":[3195,3199],"raw":"冒泡排序"}],"loc":{"start":{"line":186,"column":0},"end":{"line":186,"column":9}},"range":[3190,3199],"raw":"#### 冒泡排序"},{"type":"Paragraph","children":[{"type":"Str","value":"一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。","loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":88}},"range":[3201,3289],"raw":"一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。"}],"loc":{"start":{"line":188,"column":0},"end":{"line":188,"column":88}},"range":[3201,3289],"raw":"一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。"},{"type":"Paragraph","children":[{"type":"Str","value":"然后再对前面的n-1个元素进行一轮冒泡，依次类推。","loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":25}},"range":[3291,3316],"raw":"然后再对前面的n-1个元素进行一轮冒泡，依次类推。"}],"loc":{"start":{"line":190,"column":0},"end":{"line":190,"column":25}},"range":[3291,3316],"raw":"然后再对前面的n-1个元素进行一轮冒泡，依次类推。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":192,"column":6},"end":{"line":192,"column":10}},"range":[3324,3328],"raw":"代码实现"}],"loc":{"start":{"line":192,"column":0},"end":{"line":192,"column":10}},"range":[3318,3328],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}","loc":{"start":{"line":194,"column":0},"end":{"line":215,"column":3}},"range":[3330,3840],"raw":"```c\n#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":217,"column":6},"end":{"line":217,"column":11}},"range":[3848,3853],"raw":"时空复杂度"}],"loc":{"start":{"line":217,"column":0},"end":{"line":217,"column":11}},"range":[3842,3853],"raw":"##### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：O(n^{2})","loc":{"start":{"line":219,"column":0},"end":{"line":219,"column":14}},"range":[3855,3869],"raw":"时间复杂度：O(n^{2})"}],"loc":{"start":{"line":219,"column":0},"end":{"line":219,"column":14}},"range":[3855,3869],"raw":"时间复杂度：O(n^{2})"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：O(1)","loc":{"start":{"line":221,"column":0},"end":{"line":221,"column":10}},"range":[3871,3881],"raw":"空间复杂度：O(1)"}],"loc":{"start":{"line":221,"column":0},"end":{"line":221,"column":10}},"range":[3871,3881],"raw":"空间复杂度：O(1)"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":223,"column":6},"end":{"line":223,"column":9}},"range":[3889,3892],"raw":"稳定性"}],"loc":{"start":{"line":223,"column":0},"end":{"line":223,"column":9}},"range":[3883,3892],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"冒泡排序是稳定的","loc":{"start":{"line":225,"column":0},"end":{"line":225,"column":8}},"range":[3894,3902],"raw":"冒泡排序是稳定的"}],"loc":{"start":{"line":225,"column":0},"end":{"line":225,"column":8}},"range":[3894,3902],"raw":"冒泡排序是稳定的"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"快排排序","loc":{"start":{"line":227,"column":5},"end":{"line":227,"column":9}},"range":[3909,3913],"raw":"快排排序"}],"loc":{"start":{"line":227,"column":0},"end":{"line":227,"column":9}},"range":[3904,3913],"raw":"#### 快排排序"},{"type":"Paragraph","children":[{"type":"Str","value":"在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。","loc":{"start":{"line":229,"column":0},"end":{"line":229,"column":97}},"range":[3915,4012],"raw":"在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。"}],"loc":{"start":{"line":229,"column":0},"end":{"line":229,"column":97}},"range":[3915,4012],"raw":"在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。"},{"type":"Paragraph","children":[{"type":"Str","value":"然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。","loc":{"start":{"line":231,"column":0},"end":{"line":231,"column":53}},"range":[4014,4067],"raw":"然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。"}],"loc":{"start":{"line":231,"column":0},"end":{"line":231,"column":53}},"range":[4014,4067],"raw":"然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。"},{"type":"Paragraph","children":[{"type":"Str","value":"基本思路：","loc":{"start":{"line":233,"column":0},"end":{"line":233,"column":5}},"range":[4069,4074],"raw":"基本思路："}],"loc":{"start":{"line":233,"column":0},"end":{"line":233,"column":5}},"range":[4069,4074],"raw":"基本思路："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始化low指向要划分的第一个元素，high指向要划分的最后一个元素","loc":{"start":{"line":235,"column":3},"end":{"line":235,"column":37}},"range":[4079,4113],"raw":"初始化low指向要划分的第一个元素，high指向要划分的最后一个元素"}],"loc":{"start":{"line":235,"column":3},"end":{"line":235,"column":37}},"range":[4079,4113],"raw":"初始化low指向要划分的第一个元素，high指向要划分的最后一个元素"}],"loc":{"start":{"line":235,"column":0},"end":{"line":235,"column":37}},"range":[4076,4113],"raw":"1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元素"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素","loc":{"start":{"line":236,"column":3},"end":{"line":236,"column":49}},"range":[4117,4163],"raw":"向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素"}],"loc":{"start":{"line":236,"column":3},"end":{"line":236,"column":49}},"range":[4117,4163],"raw":"向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素"}],"loc":{"start":{"line":236,"column":0},"end":{"line":236,"column":49}},"range":[4114,4163],"raw":"2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"交换low和high指向的元素","loc":{"start":{"line":237,"column":3},"end":{"line":237,"column":18}},"range":[4167,4182],"raw":"交换low和high指向的元素"}],"loc":{"start":{"line":237,"column":3},"end":{"line":237,"column":18}},"range":[4167,4182],"raw":"交换low和high指向的元素"}],"loc":{"start":{"line":237,"column":0},"end":{"line":237,"column":18}},"range":[4164,4182],"raw":"3. 交换low和high指向的元素"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"继续移动low和high直到low>=high","loc":{"start":{"line":238,"column":3},"end":{"line":238,"column":26}},"range":[4186,4209],"raw":"继续移动low和high直到low>=high"}],"loc":{"start":{"line":238,"column":3},"end":{"line":238,"column":26}},"range":[4186,4209],"raw":"继续移动low和high直到low>=high"}],"loc":{"start":{"line":238,"column":0},"end":{"line":238,"column":26}},"range":[4183,4209],"raw":"4. 继续移动low和high直到low>=high"}],"loc":{"start":{"line":235,"column":0},"end":{"line":238,"column":26}},"range":[4076,4209],"raw":"1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元素\n2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素\n3. 交换low和high指向的元素\n4. 继续移动low和high直到low>=high"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":240,"column":6},"end":{"line":240,"column":10}},"range":[4217,4221],"raw":"代码实现"}],"loc":{"start":{"line":240,"column":0},"end":{"line":240,"column":10}},"range":[4211,4221],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}","loc":{"start":{"line":242,"column":0},"end":{"line":292,"column":3}},"range":[4223,5506],"raw":"```c\nint Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":294,"column":6},"end":{"line":294,"column":11}},"range":[5514,5519],"raw":"时空复杂度"}],"loc":{"start":{"line":294,"column":0},"end":{"line":294,"column":11}},"range":[5508,5519],"raw":"##### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"最好、平均时间复杂度：$O(nlog_{2}(n))$","loc":{"start":{"line":296,"column":0},"end":{"line":296,"column":27}},"range":[5521,5548],"raw":"最好、平均时间复杂度：$O(nlog_{2}(n))$"}],"loc":{"start":{"line":296,"column":0},"end":{"line":296,"column":27}},"range":[5521,5548],"raw":"最好、平均时间复杂度：$O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"最好、平均空间复杂度：$O(log_{2}(n))$","loc":{"start":{"line":298,"column":0},"end":{"line":298,"column":26}},"range":[5550,5576],"raw":"最好、平均空间复杂度：$O(log_{2}(n))$"}],"loc":{"start":{"line":298,"column":0},"end":{"line":298,"column":26}},"range":[5550,5576],"raw":"最好、平均空间复杂度：$O(log_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"最坏空间复杂度：$O(n)$","loc":{"start":{"line":300,"column":0},"end":{"line":300,"column":14}},"range":[5578,5592],"raw":"最坏空间复杂度：$O(n)$"}],"loc":{"start":{"line":300,"column":0},"end":{"line":300,"column":14}},"range":[5578,5592],"raw":"最坏空间复杂度：$O(n)$"},{"type":"Paragraph","children":[{"type":"Str","value":"最坏时间复杂度：$O(n^{2})$","loc":{"start":{"line":302,"column":0},"end":{"line":302,"column":18}},"range":[5594,5612],"raw":"最坏时间复杂度：$O(n^{2})$"}],"loc":{"start":{"line":302,"column":0},"end":{"line":302,"column":18}},"range":[5594,5612],"raw":"最坏时间复杂度：$O(n^{2})$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":304,"column":6},"end":{"line":304,"column":9}},"range":[5620,5623],"raw":"稳定性"}],"loc":{"start":{"line":304,"column":0},"end":{"line":304,"column":9}},"range":[5614,5623],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"快速排序是不稳定的","loc":{"start":{"line":306,"column":0},"end":{"line":306,"column":9}},"range":[5625,5634],"raw":"快速排序是不稳定的"}],"loc":{"start":{"line":306,"column":0},"end":{"line":306,"column":9}},"range":[5625,5634],"raw":"快速排序是不稳定的"},{"type":"HorizontalRule","loc":{"start":{"line":308,"column":0},"end":{"line":308,"column":6}},"range":[5636,5642],"raw":"******"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"选择排序","loc":{"start":{"line":310,"column":4},"end":{"line":310,"column":8}},"range":[5648,5652],"raw":"选择排序"}],"loc":{"start":{"line":310,"column":0},"end":{"line":310,"column":8}},"range":[5644,5652],"raw":"### 选择排序"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"简单选择排序","loc":{"start":{"line":312,"column":5},"end":{"line":312,"column":11}},"range":[5659,5665],"raw":"简单选择排序"}],"loc":{"start":{"line":312,"column":0},"end":{"line":312,"column":11}},"range":[5654,5665],"raw":"#### 简单选择排序"},{"type":"Paragraph","children":[{"type":"Str","value":"在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。","loc":{"start":{"line":314,"column":0},"end":{"line":314,"column":58}},"range":[5667,5725],"raw":"在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。"}],"loc":{"start":{"line":314,"column":0},"end":{"line":314,"column":58}},"range":[5667,5725],"raw":"在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":316,"column":6},"end":{"line":316,"column":10}},"range":[5733,5737],"raw":"代码实现"}],"loc":{"start":{"line":316,"column":0},"end":{"line":316,"column":10}},"range":[5727,5737],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}","loc":{"start":{"line":318,"column":0},"end":{"line":332,"column":3}},"range":[5739,6131],"raw":"```c\nvoid SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":334,"column":6},"end":{"line":334,"column":9}},"range":[6139,6142],"raw":"稳定性"}],"loc":{"start":{"line":334,"column":0},"end":{"line":334,"column":9}},"range":[6133,6142],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"选择排序是不稳定的","loc":{"start":{"line":336,"column":0},"end":{"line":336,"column":9}},"range":[6144,6153],"raw":"选择排序是不稳定的"}],"loc":{"start":{"line":336,"column":0},"end":{"line":336,"column":9}},"range":[6144,6153],"raw":"选择排序是不稳定的"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":338,"column":6},"end":{"line":338,"column":11}},"range":[6161,6166],"raw":"时空复杂度"}],"loc":{"start":{"line":338,"column":0},"end":{"line":338,"column":11}},"range":[6155,6166],"raw":"##### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：$O(n^{2})$","loc":{"start":{"line":340,"column":0},"end":{"line":340,"column":16}},"range":[6168,6184],"raw":"时间复杂度：$O(n^{2})$"}],"loc":{"start":{"line":340,"column":0},"end":{"line":340,"column":16}},"range":[6168,6184],"raw":"时间复杂度：$O(n^{2})$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：$O(1)$","loc":{"start":{"line":342,"column":0},"end":{"line":342,"column":12}},"range":[6186,6198],"raw":"空间复杂度：$O(1)$"}],"loc":{"start":{"line":342,"column":0},"end":{"line":342,"column":12}},"range":[6186,6198],"raw":"空间复杂度：$O(1)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":344,"column":6},"end":{"line":344,"column":10}},"range":[6206,6210],"raw":"存储结构"}],"loc":{"start":{"line":344,"column":0},"end":{"line":344,"column":10}},"range":[6200,6210],"raw":"##### 存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":346,"column":0},"end":{"line":346,"column":12}},"range":[6212,6224],"raw":"适用于顺序存储和链式存储"}],"loc":{"start":{"line":346,"column":0},"end":{"line":346,"column":12}},"range":[6212,6224],"raw":"适用于顺序存储和链式存储"},{"type":"HorizontalRule","loc":{"start":{"line":348,"column":0},"end":{"line":348,"column":5}},"range":[6226,6231],"raw":"*****"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"堆排序","loc":{"start":{"line":350,"column":5},"end":{"line":350,"column":8}},"range":[6238,6241],"raw":"堆排序"}],"loc":{"start":{"line":350,"column":0},"end":{"line":350,"column":8}},"range":[6233,6241],"raw":"#### 堆排序"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"堆：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足：","loc":{"start":{"line":352,"column":2},"end":{"line":352,"column":35}},"range":[6245,6278],"raw":"堆：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足："}],"loc":{"start":{"line":352,"column":2},"end":{"line":352,"column":35}},"range":[6245,6278],"raw":"堆：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足："},{"type":"List","ordered":true,"start":1,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆","loc":{"start":{"line":353,"column":5},"end":{"line":353,"column":51}},"range":[6284,6330],"raw":"若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆"}],"loc":{"start":{"line":353,"column":5},"end":{"line":353,"column":51}},"range":[6284,6330],"raw":"若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆"}],"loc":{"start":{"line":353,"column":2},"end":{"line":353,"column":51}},"range":[6281,6330],"raw":"1. 若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆","loc":{"start":{"line":354,"column":5},"end":{"line":354,"column":51}},"range":[6336,6382],"raw":"若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆"}],"loc":{"start":{"line":354,"column":5},"end":{"line":354,"column":51}},"range":[6336,6382],"raw":"若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆"}],"loc":{"start":{"line":354,"column":2},"end":{"line":354,"column":51}},"range":[6333,6382],"raw":"2. 若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆"}],"loc":{"start":{"line":353,"column":2},"end":{"line":355,"column":1}},"range":[6281,6384],"raw":"1. 若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆\n> 2. 若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆\n>"},{"type":"Paragraph","children":[{"type":"Str","value":"在排序得过程中，将序列$L[1...n]$视为一棵完全二叉树","loc":{"start":{"line":356,"column":2},"end":{"line":356,"column":32}},"range":[6387,6417],"raw":"在排序得过程中，将序列$L[1...n]$视为一棵完全二叉树"}],"loc":{"start":{"line":356,"column":2},"end":{"line":356,"column":32}},"range":[6387,6417],"raw":"在排序得过程中，将序列$L[1...n]$视为一棵完全二叉树"}],"loc":{"start":{"line":352,"column":0},"end":{"line":356,"column":32}},"range":[6243,6417],"raw":"> 堆：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足：\n> 1. 若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆\n> 2. 若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆\n>\n> 在排序得过程中，将序列$L[1...n]$视为一棵完全二叉树"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的","loc":{"start":{"line":358,"column":2},"end":{"line":358,"column":32}},"range":[6421,6451],"raw":"小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的"}],"loc":{"start":{"line":358,"column":2},"end":{"line":358,"column":32}},"range":[6421,6451],"raw":"小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的"}],"loc":{"start":{"line":358,"column":0},"end":{"line":358,"column":32}},"range":[6419,6451],"raw":"- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的","loc":{"start":{"line":359,"column":2},"end":{"line":359,"column":32}},"range":[6454,6484],"raw":"大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的"}],"loc":{"start":{"line":359,"column":2},"end":{"line":359,"column":32}},"range":[6454,6484],"raw":"大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的"}],"loc":{"start":{"line":359,"column":0},"end":{"line":359,"column":32}},"range":[6452,6484],"raw":"- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的"}],"loc":{"start":{"line":358,"column":0},"end":{"line":359,"column":32}},"range":[6419,6484],"raw":"- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的\n- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"堆的初始化","loc":{"start":{"line":361,"column":6},"end":{"line":361,"column":11}},"range":[6492,6497],"raw":"堆的初始化"}],"loc":{"start":{"line":361,"column":0},"end":{"line":361,"column":11}},"range":[6486,6497],"raw":"##### 堆的初始化"},{"type":"Paragraph","children":[{"type":"Str","value":"将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号$\\lfloor \\frac{n}{2} \\rfloor 到 1$做如下的调整：","loc":{"start":{"line":363,"column":0},"end":{"line":364,"column":54}},"range":[6499,6570],"raw":"将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号$\\lfloor \\frac{n}{2} \\rfloor 到 1$做如下的调整："}],"loc":{"start":{"line":363,"column":0},"end":{"line":364,"column":54}},"range":[6499,6570],"raw":"将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号$\\lfloor \\frac{n}{2} \\rfloor 到 1$做如下的调整："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整","loc":{"start":{"line":366,"column":2},"end":{"line":366,"column":52}},"range":[6574,6624],"raw":"如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整"}],"loc":{"start":{"line":366,"column":2},"end":{"line":366,"column":52}},"range":[6574,6624],"raw":"如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整"}],"loc":{"start":{"line":366,"column":0},"end":{"line":366,"column":52}},"range":[6572,6624],"raw":"- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果该节点的孩子结点的值均小于该节点，该节点的调整结束","loc":{"start":{"line":367,"column":2},"end":{"line":367,"column":29}},"range":[6627,6654],"raw":"如果该节点的孩子结点的值均小于该节点，该节点的调整结束"}],"loc":{"start":{"line":367,"column":2},"end":{"line":367,"column":29}},"range":[6627,6654],"raw":"如果该节点的孩子结点的值均小于该节点，该节点的调整结束"}],"loc":{"start":{"line":367,"column":0},"end":{"line":367,"column":29}},"range":[6625,6654],"raw":"- 如果该节点的孩子结点的值均小于该节点，该节点的调整结束"}],"loc":{"start":{"line":366,"column":0},"end":{"line":367,"column":29}},"range":[6572,6654],"raw":"- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整\n- 如果该节点的孩子结点的值均小于该节点，该节点的调整结束"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":369,"column":6},"end":{"line":369,"column":10}},"range":[6662,6666],"raw":"代码实现"}],"loc":{"start":{"line":369,"column":0},"end":{"line":369,"column":10}},"range":[6656,6666],"raw":"##### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}","loc":{"start":{"line":371,"column":0},"end":{"line":401,"column":3}},"range":[6668,7383],"raw":"```c\n// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":403,"column":6},"end":{"line":403,"column":11}},"range":[7391,7396],"raw":"时空复杂度"}],"loc":{"start":{"line":403,"column":0},"end":{"line":403,"column":11}},"range":[7385,7396],"raw":"##### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：$O(nlog_{2}(n))$","loc":{"start":{"line":405,"column":0},"end":{"line":405,"column":22}},"range":[7398,7420],"raw":"时间复杂度：$O(nlog_{2}(n))$"}],"loc":{"start":{"line":405,"column":0},"end":{"line":405,"column":22}},"range":[7398,7420],"raw":"时间复杂度：$O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：$O(1)$","loc":{"start":{"line":407,"column":0},"end":{"line":407,"column":12}},"range":[7422,7434],"raw":"空间复杂度：$O(1)$"}],"loc":{"start":{"line":407,"column":0},"end":{"line":407,"column":12}},"range":[7422,7434],"raw":"空间复杂度：$O(1)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":409,"column":6},"end":{"line":409,"column":9}},"range":[7442,7445],"raw":"稳定性"}],"loc":{"start":{"line":409,"column":0},"end":{"line":409,"column":9}},"range":[7436,7445],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"不稳定","loc":{"start":{"line":411,"column":0},"end":{"line":411,"column":3}},"range":[7447,7450],"raw":"不稳定"}],"loc":{"start":{"line":411,"column":0},"end":{"line":411,"column":3}},"range":[7447,7450],"raw":"不稳定"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":413,"column":6},"end":{"line":413,"column":10}},"range":[7458,7462],"raw":"存储结构"}],"loc":{"start":{"line":413,"column":0},"end":{"line":413,"column":10}},"range":[7452,7462],"raw":"##### 存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":415,"column":0},"end":{"line":415,"column":12}},"range":[7464,7476],"raw":"适用于顺序存储和链式存储"}],"loc":{"start":{"line":415,"column":0},"end":{"line":415,"column":12}},"range":[7464,7476],"raw":"适用于顺序存储和链式存储"},{"type":"HorizontalRule","loc":{"start":{"line":417,"column":0},"end":{"line":417,"column":5}},"range":[7478,7483],"raw":"*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"归并排序","loc":{"start":{"line":419,"column":4},"end":{"line":419,"column":8}},"range":[7489,7493],"raw":"归并排序"}],"loc":{"start":{"line":419,"column":0},"end":{"line":419,"column":8}},"range":[7485,7493],"raw":"### 归并排序"},{"type":"Paragraph","children":[{"type":"Str","value":"二路归并排序：","loc":{"start":{"line":421,"column":0},"end":{"line":421,"column":7}},"range":[7495,7502],"raw":"二路归并排序："}],"loc":{"start":{"line":421,"column":0},"end":{"line":421,"column":7}},"range":[7495,7502],"raw":"二路归并排序："},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png","alt":"quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png","loc":{"start":{"line":423,"column":0},"end":{"line":423,"column":102}},"range":[7504,7606],"raw":"![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png)"}],"loc":{"start":{"line":423,"column":0},"end":{"line":423,"column":102}},"range":[7504,7606],"raw":"![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png)"},{"type":"CodeBlock","lang":"c","meta":null,"value":"int *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}","loc":{"start":{"line":425,"column":0},"end":{"line":452,"column":3}},"range":[7608,8328],"raw":"```c\nint *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}\n```"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":454,"column":6},"end":{"line":454,"column":11}},"range":[8336,8341],"raw":"时空复杂度"}],"loc":{"start":{"line":454,"column":0},"end":{"line":454,"column":11}},"range":[8330,8341],"raw":"##### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：$O(nlog_{2}(n))$","loc":{"start":{"line":456,"column":0},"end":{"line":456,"column":22}},"range":[8343,8365],"raw":"时间复杂度：$O(nlog_{2}(n))$"}],"loc":{"start":{"line":456,"column":0},"end":{"line":456,"column":22}},"range":[8343,8365],"raw":"时间复杂度：$O(nlog_{2}(n))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：$O(n)$","loc":{"start":{"line":458,"column":0},"end":{"line":458,"column":12}},"range":[8367,8379],"raw":"空间复杂度：$O(n)$"}],"loc":{"start":{"line":458,"column":0},"end":{"line":458,"column":12}},"range":[8367,8379],"raw":"空间复杂度：$O(n)$"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":460,"column":6},"end":{"line":460,"column":9}},"range":[8387,8390],"raw":"稳定性"}],"loc":{"start":{"line":460,"column":0},"end":{"line":460,"column":9}},"range":[8381,8390],"raw":"##### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"归并排序是稳定的","loc":{"start":{"line":462,"column":0},"end":{"line":462,"column":8}},"range":[8392,8400],"raw":"归并排序是稳定的"}],"loc":{"start":{"line":462,"column":0},"end":{"line":462,"column":8}},"range":[8392,8400],"raw":"归并排序是稳定的"},{"type":"Header","depth":5,"children":[{"type":"Str","value":"存储结构","loc":{"start":{"line":464,"column":6},"end":{"line":464,"column":10}},"range":[8408,8412],"raw":"存储结构"}],"loc":{"start":{"line":464,"column":0},"end":{"line":464,"column":10}},"range":[8402,8412],"raw":"##### 存储结构"},{"type":"Paragraph","children":[{"type":"Str","value":"适用于顺序存储和链式存储","loc":{"start":{"line":466,"column":0},"end":{"line":466,"column":12}},"range":[8414,8426],"raw":"适用于顺序存储和链式存储"}],"loc":{"start":{"line":466,"column":0},"end":{"line":466,"column":12}},"range":[8414,8426],"raw":"适用于顺序存储和链式存储"},{"type":"HorizontalRule","loc":{"start":{"line":468,"column":0},"end":{"line":468,"column":5}},"range":[8428,8433],"raw":"*****"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"基数排序","loc":{"start":{"line":470,"column":4},"end":{"line":470,"column":8}},"range":[8439,8443],"raw":"基数排序"}],"loc":{"start":{"line":470,"column":0},"end":{"line":470,"column":8}},"range":[8435,8443],"raw":"### 基数排序"},{"type":"Paragraph","children":[{"type":"Str","value":"借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。","loc":{"start":{"line":472,"column":0},"end":{"line":472,"column":51}},"range":[8445,8496],"raw":"借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。"}],"loc":{"start":{"line":472,"column":0},"end":{"line":472,"column":51}},"range":[8445,8496],"raw":"借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。"},{"type":"Paragraph","children":[{"type":"Str","value":"LSD基数排序的过程：","loc":{"start":{"line":474,"column":0},"end":{"line":474,"column":11}},"range":[8498,8509],"raw":"LSD基数排序的过程："}],"loc":{"start":{"line":474,"column":0},"end":{"line":474,"column":11}},"range":[8498,8509],"raw":"LSD基数排序的过程："},{"type":"Paragraph","children":[{"type":"Str","value":"假设线性表由$a_{0}, a_{1},...,a_{n-1}$构成，每个结点$a_{j}$的关键字由d元组$(k^{(d-1)}","loc":{"start":{"line":476,"column":0},"end":{"line":476,"column":65}},"range":[8511,8576],"raw":"假设线性表由$a_{0}, a_{1},...,a_{n-1}$构成，每个结点$a_{j}$的关键字由d元组$(k^{(d-1)}"},{"type":"Emphasis","children":[{"type":"Str","value":"{j},k^{(d-2)}","loc":{"start":{"line":476,"column":66},"end":{"line":476,"column":79}},"range":[8577,8590],"raw":"{j},k^{(d-2)}"}],"loc":{"start":{"line":476,"column":65},"end":{"line":476,"column":80}},"range":[8576,8591],"raw":"_{j},k^{(d-2)}_"},{"type":"Str","value":"{j},...,k^{(0)}","loc":{"start":{"line":476,"column":80},"end":{"line":476,"column":95}},"range":[8591,8606],"raw":"{j},...,k^{(0)}"},{"type":"Emphasis","children":[{"type":"Str","value":"{j})$组成，其中$0 \\leq k","loc":{"start":{"line":476,"column":96},"end":{"line":476,"column":115}},"range":[8607,8626],"raw":"{j})$组成，其中$0 \\leq k"}],"loc":{"start":{"line":476,"column":95},"end":{"line":476,"column":116}},"range":[8606,8627],"raw":"_{j})$组成，其中$0 \\leq k_"},{"type":"Str","value":"{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$。","loc":{"start":{"line":476,"column":116},"end":{"line":476,"column":163}},"range":[8627,8674],"raw":"{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$。"}],"loc":{"start":{"line":476,"column":0},"end":{"line":476,"column":163}},"range":[8511,8674],"raw":"假设线性表由$a_{0}, a_{1},...,a_{n-1}$构成，每个结点$a_{j}$的关键字由d元组$(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})$组成，其中$0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$。"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$","loc":{"start":{"line":478,"column":2},"end":{"line":478,"column":38}},"range":[8678,8714],"raw":"使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$"}],"loc":{"start":{"line":478,"column":2},"end":{"line":478,"column":39}},"range":[8678,8715],"raw":"使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$ "}],"loc":{"start":{"line":478,"column":0},"end":{"line":478,"column":39}},"range":[8676,8715],"raw":"- 使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$ "},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"初始时将r个辅助队列置为空","loc":{"start":{"line":479,"column":2},"end":{"line":479,"column":15}},"range":[8718,8731],"raw":"初始时将r个辅助队列置为空"}],"loc":{"start":{"line":479,"column":2},"end":{"line":479,"column":15}},"range":[8718,8731],"raw":"初始时将r个辅助队列置为空"}],"loc":{"start":{"line":479,"column":0},"end":{"line":479,"column":15}},"range":[8716,8731],"raw":"- 初始时将r个辅助队列置为空"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。","loc":{"start":{"line":480,"column":2},"end":{"line":480,"column":91}},"range":[8734,8823],"raw":"分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。"}],"loc":{"start":{"line":480,"column":2},"end":{"line":480,"column":91}},"range":[8734,8823],"raw":"分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。"}],"loc":{"start":{"line":480,"column":0},"end":{"line":480,"column":91}},"range":[8732,8823],"raw":"- 分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。","loc":{"start":{"line":481,"column":2},"end":{"line":481,"column":68}},"range":[8826,8892],"raw":"收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。"}],"loc":{"start":{"line":481,"column":2},"end":{"line":481,"column":68}},"range":[8826,8892],"raw":"收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。"}],"loc":{"start":{"line":481,"column":0},"end":{"line":481,"column":68}},"range":[8824,8892],"raw":"- 收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。"}],"loc":{"start":{"line":478,"column":0},"end":{"line":481,"column":68}},"range":[8676,8892],"raw":"- 使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$ \n- 初始时将r个辅助队列置为空\n- 分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。\n- 收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"时空复杂度","loc":{"start":{"line":483,"column":5},"end":{"line":483,"column":10}},"range":[8899,8904],"raw":"时空复杂度"}],"loc":{"start":{"line":483,"column":0},"end":{"line":483,"column":10}},"range":[8894,8904],"raw":"#### 时空复杂度"},{"type":"Paragraph","children":[{"type":"Str","value":"时间复杂度：$O(d(n+r))$","loc":{"start":{"line":485,"column":0},"end":{"line":485,"column":17}},"range":[8906,8923],"raw":"时间复杂度：$O(d(n+r))$"}],"loc":{"start":{"line":485,"column":0},"end":{"line":485,"column":17}},"range":[8906,8923],"raw":"时间复杂度：$O(d(n+r))$"},{"type":"Paragraph","children":[{"type":"Str","value":"空间复杂度：$O(r)$","loc":{"start":{"line":487,"column":0},"end":{"line":487,"column":12}},"range":[8925,8937],"raw":"空间复杂度：$O(r)$"}],"loc":{"start":{"line":487,"column":0},"end":{"line":487,"column":12}},"range":[8925,8937],"raw":"空间复杂度：$O(r)$"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"稳定性","loc":{"start":{"line":489,"column":5},"end":{"line":489,"column":8}},"range":[8944,8947],"raw":"稳定性"}],"loc":{"start":{"line":489,"column":0},"end":{"line":489,"column":8}},"range":[8939,8947],"raw":"#### 稳定性"},{"type":"Paragraph","children":[{"type":"Str","value":"基数排序是稳定的","loc":{"start":{"line":491,"column":0},"end":{"line":491,"column":8}},"range":[8949,8957],"raw":"基数排序是稳定的"}],"loc":{"start":{"line":491,"column":0},"end":{"line":491,"column":8}},"range":[8949,8957],"raw":"基数排序是稳定的"},{"type":"HorizontalRule","loc":{"start":{"line":493,"column":0},"end":{"line":493,"column":5}},"range":[8959,8964],"raw":"*****"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"外部排序","loc":{"start":{"line":495,"column":3},"end":{"line":495,"column":7}},"range":[8969,8973],"raw":"外部排序"}],"loc":{"start":{"line":495,"column":0},"end":{"line":495,"column":7}},"range":[8966,8973],"raw":"## 外部排序"},{"type":"Paragraph","children":[{"type":"Str","value":"排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序","loc":{"start":{"line":497,"column":0},"end":{"line":497,"column":64}},"range":[8975,9039],"raw":"排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序"}],"loc":{"start":{"line":497,"column":0},"end":{"line":497,"column":64}},"range":[8975,9039],"raw":"排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序"}],"loc":{"start":{"line":1,"column":0},"end":{"line":498,"column":0}},"range":[0,9040],"raw":"---\ntitle: '各种排序算法总结'\ntags: ['数据结构','排序']\n---\n# 排序的基本概念\n\n## 各种排序算法汇总\n\n|算法|类别|时间复杂度|空间复杂度|稳定性|支持顺序存储结构|支持链式存储结构|\n|-|-|-|-|-|-|-|\n|直接插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|\n|折半插入排序|插入排序|$O(n^{2})$|$O(1)$|稳定|支持|不支持|\n|希尔排序|插入排序|$O(n^{2})$|$O(1)$|不稳定|支持|不支持|\n|冒泡排序|交换排序|$O(n^{2})$|$O(1)$|稳定|支持|支持|\n|快速排序|交换排序|最好、平均：$O(nlog_{2}(n))$，最坏：$O(n^{2})$|最好、平均：$O(log_{2}(n))$，最坏：$O(n)$|不稳定|支持||\n|简单选择排序|选择排序|$O(n^{2})$|$O(1)$|不稳定|支持|支持|\n|堆排序|选择排序|$O(nlog_{2}(n))$|$O(1)$|不稳定|支持|支持|\n|归并排序|归并排序|$O(nlog_{2}(n))$|$O(n)$|稳定|支持|支持|\n|基数排序|基数排序|$O(d(n+r))$|$O(r)$|稳定|支持|支持|\n\n*****\n\n## 基本概念\n\n### 排序的定义\n\n重新排列表中的元素，使表中的元素按照元素的关键字递增或者递减的过程称为排序。\n\n### 排序的时间复杂度和空间复杂度\n\n### 排序的稳定性\n\n如果表中有两个元素$R_{i}$和$R_{j}$，其对应的关键字$key_{i}=key_{j}$，且$R_{i}$排在$R_{j}$前面，使用某一排序算法后，$R_{i}$仍排在$R_{j}$前面，就称这个算法是稳定的。\n\n*****\n\n## 内部排序\n\n排序过程中，所有的元素都存放在内存中的排序。\n\n公式：对任意n个元素的列表进行排序的比较次数至少为 $\\lceil log_{2}{(n!)} \\rceil$ 。\n\n### 插入排序\n\n每次将一个待排序的序列，按照其关键字大小，插入到前面已经排好序的子序列中，直到全部的记录插入完成。\n\n*****\n\n#### 直接插入排序\n\n|有序序列|要插入的|无序序列|\n|-|-|-|\n|$L[1...i-1]$|$L(i)$|$L[i+1...n]$|\n\n1. 查找$L(i)$的插入位置k；\n2. 将$L[k...i-1]$所有的元素都向后移动一个位置；\n3. 将$L(i)$复制到k的位置。\n\n##### 代码实现\n\n```c\nvoid InsertSort(int values[], int size){\n    int i,j,tmp;\n    for(i=1;i<size;i++){\n        tmp = values[i];\n        for(j=i-1;values[j]>tmp&&j>0;j--) values[j+1] = values[j];\n        values[j] = tmp;\n    }\n}\n```\n\n##### 时间复杂度\n\n当要将一个升序的序列排序成降序时的比较次数最多，时间复杂度为$O(n^{2})$。\n\n##### 空间复杂度\n\n只用到一个用于赋值的临时变量，空间复杂度为O(1)。\n\n##### 稳定性\n\n比较时用的是'<'，如果关键字相等时就会跳出循环，不会影响原来的相对位置，所以直接插入排序时稳定的。\n\n##### 存储结构\n\n排序时只需要顺序访问表中的元素，既可以使用顺序存储结构也可以使用链表存储\n\n*****\n\n#### 折半插入排序（二分插入排序）\n\n使用折半查找的方式，寻找待插入元素的插入位置，其余的部分与直接插入排序是相同的。\n\n##### 代码实现\n\n```c\nvoid BInsertSort(int values[], int size){\n    int i, j, tmp;\n    int high, low, mid; // 二分查找需要的变量\n    for(i=0;i<size;i++){\n        tmp = values[i];\n        // 二分查找\n        high = i-1;\n        low = 0;\n        while(low<=high){\n            mid = (high+low)/2;\n            if(values[mid]>tmp){\n                high = mid - 1;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // 二分查找结束\n        for(j=i-1;j<high+1;j--) values[j+1] = values[j];\n        values[high+1] = tmp;\n    }\n}\n```\n\n##### 时间复杂度\n\n由于查找过程使用了二分查找，所以其时间复杂度是$O(n*n*log_{2}(n))=O(n^{2})$。\n\n##### 空间复杂度\n\n只是用到了常数个额外的内存空间，所以其空间复杂度是$O(1)$。\n\n##### 排序稳定性\n\n与直接插入排序相同\n\n##### 存储结构\n\n由于使用了二分查找，所以只能适用于顺序存储的线性表\n\n*****\n\n#### 希尔排序（缩小增量排序）\n\n- 先将要排序的序列分割成$d=d_{i}$个形如 $L[i,i+d,i+2d,...,i+kd]$ 的子序列\n- 对各个子序列进行直接插入排序\n- 令$d=d_{i+1}$，重复上面的两步，直到d=1时，排序完成\n\n$d_{1}=\\lfloor \\frac{n}{2} \\rfloor,\\; d_{2}=\\lfloor \\frac{d_{1}}{2} \\rfloor,\\;...\\;,d_{n}=1$\n\n##### 代码实现\n\n```c\nvoid ShellInsertSort(int values[], int size){\n    int i, j, tmp, dk;\n    // 实现dk序列\n    for(dk=size/2;dk>=1;dk/=2){\n        // 依次对每个子序列进行直接插入排序\n        for(i=dk;i<size;i++){\n            if(values[i-dk]>values[i]){\n                tmp = values[i];\n                for(j=i-dk;j>0&&tmp<values[j];j-=dk) values[j+dk] = values[j];\n                values[j] = tmp;\n            }\n        }\n    }\n}\n```\n\n##### 时间复杂度\n\n希尔排序的时间复杂度$O(n^{2})$，n在某一个范围之内的时候，希尔排序的时间复杂度可以到$O(n^{1.3})$\n\n##### 空间复杂度\n\n辅助空间是常数级的，空间复杂度是$O(1)$。\n\n##### 希尔排序的稳定性\n\n希尔排序是不稳定的，当两个相同的值被分到不同的子序列里的时候，不能保证其相对位置。\n\n##### 希尔排序的存储结构\n\n用到了数组的标号来访问元素，所以只能使用顺序结构存储的线性表。\n\n*****\n\n### 交换排序\n\n#### 冒泡排序\n\n一个长度为n的线性表，从后往前（从前往后）依次比较相邻元素的值，如果两个元素为逆序，则交换两个元素，直到所有的元素都比较完毕，则排序完一轮，一轮过后会把最大的一个元素放到最后。\n\n然后再对前面的n-1个元素进行一轮冒泡，依次类推。\n\n##### 代码实现\n\n```c\n#define true 1\n#define false 0\n#define boolean int\n\nvoid BubbleSort(int values[], int size){\n    int i,j,tmp;\n    boolean complete_flag;\n    for(i=0;i<size-1;i++){\n        complete_flag = true;\n        for(j=i;j<n-1;j++){\n            if(values[j]>values[j+1]){\n                tmp = values[j];\n                values[j] = values[j+1];\n                values[j+1] = tmp;\n                complete_flag = false;\n            }\n        }\n        if(complete_flag) return; // 代表整个序列中没有逆序的元素了，可以提前结束。\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度：O(n^{2})\n\n空间复杂度：O(1)\n\n##### 稳定性\n\n冒泡排序是稳定的\n\n#### 快排排序\n\n在待排序的序列中取一个元素pivot作为基准，通过一趟排序，将比pivot小的元素全都放在pivot的左边，大于等于pivot的元素全部放在pivot的右边，这样pivot就到达了它最终的位置。\n\n然后对pivot左右两边的两个子序列分别进行快速排序，以此类推，直到最终所有的元素都到自己最终的位置为止。\n\n基本思路：\n\n1. 初始化low指向要划分的第一个元素，high指向要划分的最后一个元素\n2. 向右移动low找到第一个比pivot大的元素，向左移动high指向第一个比pivot小的元素\n3. 交换low和high指向的元素\n4. 继续移动low和high直到low>=high\n\n##### 代码实现\n\n```c\nint Partition(int values[], int low, int high){\n    int pivot, tmp, i;\n    while(low < high){\n        while(low < high && values[low] <= pivot) low ++;\n        while(low < high && values[high] >= pivot) high --;\n        tmp = values[low];\n        values[low] = values[high];\n        values[high] = tmp;\n    }\n    for(int i=0;i<low;i++) values[i] = values[i+1];\n    values[low-1] = pivot;\n    return low-1;\n}\n\n// 使用递归实现\nvoid QuickSortRecursion(int values[], int low, int high){\n    int pivot_index;\n    if(low < high) {\n        pivot_index = Partition(values, low, high);\n        QuickSort(values, low, pivot_index - 1);\n        QuickSort(values, pivot_index + 1, high);\n    }\n}\n\n// 使用栈实现\ntypedef Task struct {\n    int low, int high;\n};\n// 栈\ntypedef TaskStack struct {\n    // 栈定义省略...\n}\nvoid QuickSortStack(int values[], int low, int high){\n    struct TaskStack stack;\n    InitStack(&stack);\n    struct Task task = {low, high};\n    Push(&stack,task);\n    int pivot_index;\n    while(!IsEmpty(&stack)){\n        task = Pop(&stack);\n        pivot_index = Partition(values, task.low, task.high);\n        task.low = low;\n        task.high = pivot_index - 1;\n        Push(&stack,task);\n        task.low = pivot_index + 1;\n        task.high = high;\n        Push(&stack,task);\n    }\n}\n```\n\n##### 时空复杂度\n\n最好、平均时间复杂度：$O(nlog_{2}(n))$\n\n最好、平均空间复杂度：$O(log_{2}(n))$\n\n最坏空间复杂度：$O(n)$\n\n最坏时间复杂度：$O(n^{2})$\n\n##### 稳定性\n\n快速排序是不稳定的\n\n******\n\n### 选择排序\n\n#### 简单选择排序\n\n在待排序的序列中选取一个最小的元素，放到已经排好序的有序序列的最后，重复上述过程，直到待排序的序列只有一个元素为止。\n\n##### 代码实现\n\n```c\nvoid SelectSort(int values[], int size){\n    int sorted_count = 0, i, j, tmp, min;\n    while(size - sorted_count > 1){\n        min = sorted_count;\n        for(i=sorted_count;i<size;i++){\n            if(values[i]<values[min]) min = i;\n        }\n        tmp = values[min];\n        values[min] = values[sorted_count];\n        values[sorted_count] = tmp;\n        sorted_count ++;\n    }\n}\n```\n\n##### 稳定性\n\n选择排序是不稳定的\n\n##### 时空复杂度\n\n时间复杂度：$O(n^{2})$\n\n空间复杂度：$O(1)$\n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n#### 堆排序\n\n> 堆：n个关键字序列$L[1...n]$称为堆，当且仅当该序列满足：\n> 1. 若$L(i) \\leq L(2i)$且$L(i) \\leq L(2i+1)$，称该堆为小根堆\n> 2. 若$L(i) \\geq L(2i)$且$L(i) \\geq L(2i+1)$，称该堆为大根堆\n>\n> 在排序得过程中，将序列$L[1...n]$视为一棵完全二叉树\n\n- 小根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最小的\n- 大根堆表示的二叉树中，双亲结点一定是与其两个孩子结点中最大的\n\n##### 堆的初始化\n\n将一个堆调整为一个大根堆的过程：\n将所有具有双亲结点含义的编号$\\lfloor \\frac{n}{2} \\rfloor 到 1$做如下的调整：\n\n- 如果该节点的孩子结点中存在值大于该节点的，将该节点与最大的孩子结点交换，然后对被交换的孩子结点做调整\n- 如果该节点的孩子结点的值均小于该节点，该节点的调整结束\n\n##### 代码实现\n\n```c\n// 交换元素\nvoid swap(int *a, int *b){\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n// 向下调整\nvoid ajustDown(int values[], int size, int i){\n    if(i*2>size) return;\n    maxChild = 2*i;\n    if(i*2+1<size&&values[maxChild-1]<values[maxChild]) maxChild = 2*i+1;\n    if(values[i-1]<values[maxChild-1]){\n        swap(&values[i-1], &values[maxChild-1]);\n        adjustDown(values, size, maxChild);\n    }\n}\n// 调整堆\nvoid buildBigHeap(int values[], int size){\n    int i;\n    for(i=0;i<size/2;i++) adjustDown(values, size, i);\n}\n// 堆排序\nvoid HeapSort(int values[], int size){\n    int sorted = 0;\n    while(size-sorted>1){\n        BuildBigHeap(values, size-sorted);\n        swap(&values[size-sorted-1],&values[0]);\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度：$O(nlog_{2}(n))$\n\n空间复杂度：$O(1)$\n\n##### 稳定性\n\n不稳定\n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n### 归并排序\n\n二路归并排序：\n\n![quicker_dd39c9f4-6a99-425c-afde-e8e46183fabf.png](https://i.loli.net/2020/08/09/tAV1jPfTZ7X2WSK.png)\n\n```c\nint *result = (*int)malloc(size*sizeof(int)); //辅助数组，放在堆上\n\n// 合并两个线性表 O(high-low+1)\nvoid Merge(int values[], int low, int mid, int high){\n    int i,j,k;\n    for(k=low;k<high;k++) result[k] = values[k];\n    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){\n        if(result[i]<=result[j]){\n            values[k] = result[i++];\n        }\n        else{\n            values[k] = result[j++];\n        }\n    }\n    while(i<=mid) values[k++] = result[i++];\n    while(j<=high) values[k++] = result[j++];\n}\n\nvoid MergeSort(int values, int low, int high){\n    if(low<high){\n        int mid = (low+high)/2;\n        MergeSort(values, low, mid);\n        MergeSort(values, mid+1, low);\n        Merge(values, low, mid, high);\n    }\n}\n```\n\n##### 时空复杂度\n\n时间复杂度：$O(nlog_{2}(n))$\n\n空间复杂度：$O(n)$\n\n##### 稳定性\n\n归并排序是稳定的\n\n##### 存储结构\n\n适用于顺序存储和链式存储\n\n*****\n\n### 基数排序\n\n借助“分配”和“收集”两种操作，对逻辑关键字进行排序，分为最高位优先(MSD)和最低位优先(LSD)。\n\nLSD基数排序的过程：\n\n假设线性表由$a_{0}, a_{1},...,a_{n-1}$构成，每个结点$a_{j}$的关键字由d元组$(k^{(d-1)}_{j},k^{(d-2)}_{j},...,k^{(0)}_{j})$组成，其中$0 \\leq k_{j}^{(i)} \\leq r-1(0 \\leq j <n,0\\leq i < d-1)$。\n\n- 使用r个辅助队列 $Q_{0}, Q_{1},..., Q_{r-1}$ \n- 初始时将r个辅助队列置为空\n- 分配：依次考察线性表中各个结点的$a_{j}(j=0,1,...,n-1)$，若结点$a_{j}$的关键字的$k_{j}^{i}=k$，就把$a_{j}$放进队列$Q_{k}$。\n- 收集：把 $Q_{0}, Q_{1},..., Q_{r-1}$ 各个队列的结点依次首尾相连，得到新的结点序列，从而组成新的线性表。\n\n#### 时空复杂度\n\n时间复杂度：$O(d(n+r))$\n\n空间复杂度：$O(r)$\n\n#### 稳定性\n\n基数排序是稳定的\n\n*****\n\n## 外部排序\n\n排序过程中，由于元素过大，无法全部放在内存中，有一部分元素存储在外存中，在排序过程中需要不断地在内存和外存之间移动数据元素的排序\n"},"catalogue":{"title":"各种排序算法总结","json-path":"2020-08-09-排序的基本概念.json","mdate":"2022-08-30T14:19:31.452Z","tags":["数据结构","排序"]}}