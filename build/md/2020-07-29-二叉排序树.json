{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','树']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','树']\n---"},{"type":"Header","depth":1,"children":[{"type":"Str","value":"二叉排序树","loc":{"start":{"line":5,"column":2},"end":{"line":5,"column":7}},"range":[30,35],"raw":"二叉排序树"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":7}},"range":[28,35],"raw":"# 二叉排序树"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"二叉排序树(BST)，也称二叉查找树\n可以为空，当其不为空时需要满足：","loc":{"start":{"line":7,"column":2},"end":{"line":8,"column":18}},"range":[39,76],"raw":"二叉排序树(BST)，也称二叉查找树\n> 可以为空，当其不为空时需要满足："}],"loc":{"start":{"line":7,"column":2},"end":{"line":8,"column":18}},"range":[39,76],"raw":"二叉排序树(BST)，也称二叉查找树\n> 可以为空，当其不为空时需要满足："},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果左子树非空，左子树上的结点均小于根结点","loc":{"start":{"line":10,"column":4},"end":{"line":10,"column":25}},"range":[83,104],"raw":"如果左子树非空，左子树上的结点均小于根结点"}],"loc":{"start":{"line":10,"column":4},"end":{"line":10,"column":25}},"range":[83,104],"raw":"如果左子树非空，左子树上的结点均小于根结点"}],"loc":{"start":{"line":10,"column":2},"end":{"line":10,"column":25}},"range":[81,104],"raw":"- 如果左子树非空，左子树上的结点均小于根结点"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"如果右子树非空，右子树上的结点均大于根结点","loc":{"start":{"line":11,"column":4},"end":{"line":11,"column":25}},"range":[109,130],"raw":"如果右子树非空，右子树上的结点均大于根结点"}],"loc":{"start":{"line":11,"column":4},"end":{"line":11,"column":25}},"range":[109,130],"raw":"如果右子树非空，右子树上的结点均大于根结点"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":25}},"range":[107,130],"raw":"- 如果右子树非空，右子树上的结点均大于根结点"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"左右子树本身也是二叉排序树","loc":{"start":{"line":12,"column":4},"end":{"line":12,"column":17}},"range":[135,148],"raw":"左右子树本身也是二叉排序树"}],"loc":{"start":{"line":12,"column":4},"end":{"line":12,"column":17}},"range":[135,148],"raw":"左右子树本身也是二叉排序树"}],"loc":{"start":{"line":12,"column":2},"end":{"line":12,"column":17}},"range":[133,148],"raw":"- 左右子树本身也是二叉排序树"}],"loc":{"start":{"line":10,"column":2},"end":{"line":13,"column":1}},"range":[81,150],"raw":"- 如果左子树非空，左子树上的结点均小于根结点\n> - 如果右子树非空，右子树上的结点均大于根结点\n> - 左右子树本身也是二叉排序树\n>"},{"type":"Paragraph","children":[{"type":"Str","value":"二叉排序树是一个递归的定义，二叉排序树中没有相同值的结点","loc":{"start":{"line":14,"column":2},"end":{"line":14,"column":30}},"range":[153,181],"raw":"二叉排序树是一个递归的定义，二叉排序树中没有相同值的结点"}],"loc":{"start":{"line":14,"column":2},"end":{"line":14,"column":30}},"range":[153,181],"raw":"二叉排序树是一个递归的定义，二叉排序树中没有相同值的结点"}],"loc":{"start":{"line":7,"column":0},"end":{"line":14,"column":30}},"range":[37,181],"raw":"> 二叉排序树(BST)，也称二叉查找树\n> 可以为空，当其不为空时需要满足：\n>\n> - 如果左子树非空，左子树上的结点均小于根结点\n> - 如果右子树非空，右子树上的结点均大于根结点\n> - 左右子树本身也是二叉排序树\n>\n> 二叉排序树是一个递归的定义，二叉排序树中没有相同值的结点"},{"type":"Paragraph","children":[{"type":"Str","value":"二叉排序树的中序遍历序列是一个递增的有序序列。","loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":23}},"range":[183,206],"raw":"二叉排序树的中序遍历序列是一个递增的有序序列。"}],"loc":{"start":{"line":16,"column":0},"end":{"line":16,"column":23}},"range":[183,206],"raw":"二叉排序树的中序遍历序列是一个递增的有序序列。"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"二叉排序树的常用操作","loc":{"start":{"line":18,"column":3},"end":{"line":18,"column":13}},"range":[211,221],"raw":"二叉排序树的常用操作"}],"loc":{"start":{"line":18,"column":0},"end":{"line":18,"column":13}},"range":[208,221],"raw":"## 二叉排序树的常用操作"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"查找","loc":{"start":{"line":20,"column":4},"end":{"line":20,"column":6}},"range":[227,229],"raw":"查找"}],"loc":{"start":{"line":20,"column":0},"end":{"line":20,"column":6}},"range":[223,229],"raw":"### 查找"},{"type":"Paragraph","children":[{"type":"Str","value":"二叉排序树非空，从根结点开始，如果","loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":17}},"range":[231,248],"raw":"二叉排序树非空，从根结点开始，如果"}],"loc":{"start":{"line":22,"column":0},"end":{"line":22,"column":17}},"range":[231,248],"raw":"二叉排序树非空，从根结点开始，如果"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若当前结点的值和要查找的值相等，查找成功","loc":{"start":{"line":24,"column":2},"end":{"line":24,"column":22}},"range":[252,272],"raw":"若当前结点的值和要查找的值相等，查找成功"}],"loc":{"start":{"line":24,"column":2},"end":{"line":24,"column":22}},"range":[252,272],"raw":"若当前结点的值和要查找的值相等，查找成功"}],"loc":{"start":{"line":24,"column":0},"end":{"line":24,"column":22}},"range":[250,272],"raw":"- 若当前结点的值和要查找的值相等，查找成功"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点","loc":{"start":{"line":25,"column":2},"end":{"line":25,"column":33}},"range":[275,306],"raw":"若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点"}],"loc":{"start":{"line":25,"column":2},"end":{"line":25,"column":33}},"range":[275,306],"raw":"若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点"}],"loc":{"start":{"line":25,"column":0},"end":{"line":25,"column":33}},"range":[273,306],"raw":"- 若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点","loc":{"start":{"line":26,"column":2},"end":{"line":26,"column":33}},"range":[309,340],"raw":"若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点"}],"loc":{"start":{"line":26,"column":2},"end":{"line":26,"column":33}},"range":[309,340],"raw":"若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点"}],"loc":{"start":{"line":26,"column":0},"end":{"line":26,"column":33}},"range":[307,340],"raw":"- 若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若查找到叶子结点仍然没有查找成功，则查找失败","loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":24}},"range":[343,365],"raw":"若查找到叶子结点仍然没有查找成功，则查找失败"}],"loc":{"start":{"line":27,"column":2},"end":{"line":27,"column":24}},"range":[343,365],"raw":"若查找到叶子结点仍然没有查找成功，则查找失败"}],"loc":{"start":{"line":27,"column":0},"end":{"line":27,"column":24}},"range":[341,365],"raw":"- 若查找到叶子结点仍然没有查找成功，则查找失败"}],"loc":{"start":{"line":24,"column":0},"end":{"line":27,"column":24}},"range":[250,365],"raw":"- 若当前结点的值和要查找的值相等，查找成功\n- 若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点\n- 若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点\n- 若查找到叶子结点仍然没有查找成功，则查找失败"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"递归实现","loc":{"start":{"line":29,"column":5},"end":{"line":29,"column":9}},"range":[372,376],"raw":"递归实现"}],"loc":{"start":{"line":29,"column":0},"end":{"line":29,"column":9}},"range":[367,376],"raw":"#### 递归实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"BSTNode* BST_Search(BiTree* T, ElemType key){\n    if(key == T->data) return T;\n    if(key > T->data && T->rchild != NULL) return BST_Search(T->rchild, key);\n    if(key < T->data && T->lchild != NULL) return BST_Search(T->lchild, key);\n    return NULL;\n}","loc":{"start":{"line":31,"column":0},"end":{"line":38,"column":3}},"range":[378,640],"raw":"```c\nBSTNode* BST_Search(BiTree* T, ElemType key){\n    if(key == T->data) return T;\n    if(key > T->data && T->rchild != NULL) return BST_Search(T->rchild, key);\n    if(key < T->data && T->lchild != NULL) return BST_Search(T->lchild, key);\n    return NULL;\n}\n```"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"非递归实现","loc":{"start":{"line":40,"column":5},"end":{"line":40,"column":10}},"range":[647,652],"raw":"非递归实现"}],"loc":{"start":{"line":40,"column":0},"end":{"line":40,"column":10}},"range":[642,652],"raw":"#### 非递归实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"BSTNode* BST_Search(BiTree* T, ElemType key){\n    while(T != NULL && key != T->data){\n        if(key > T->data) T = T->rchild;\n        if(key < T->data) T = T->lchild;\n    }\n    return T;\n}","loc":{"start":{"line":42,"column":0},"end":{"line":50,"column":3}},"range":[654,852],"raw":"```c\nBSTNode* BST_Search(BiTree* T, ElemType key){\n    while(T != NULL && key != T->data){\n        if(key > T->data) T = T->rchild;\n        if(key < T->data) T = T->lchild;\n    }\n    return T;\n}\n```"},{"type":"Paragraph","children":[{"type":"Str","value":"二叉排序树查找的时间复杂度是O(h)，其中h是二叉排序树的高度","loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":31}},"range":[854,885],"raw":"二叉排序树查找的时间复杂度是O(h)，其中h是二叉排序树的高度"}],"loc":{"start":{"line":52,"column":0},"end":{"line":52,"column":31}},"range":[854,885],"raw":"二叉排序树查找的时间复杂度是O(h)，其中h是二叉排序树的高度"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"插入","loc":{"start":{"line":54,"column":4},"end":{"line":54,"column":6}},"range":[891,893],"raw":"插入"}],"loc":{"start":{"line":54,"column":0},"end":{"line":54,"column":6}},"range":[887,893],"raw":"### 插入"},{"type":"Paragraph","children":[{"type":"Str","value":"有二叉排序树T，待插入的结点N","loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":15}},"range":[895,910],"raw":"有二叉排序树T，待插入的结点N"}],"loc":{"start":{"line":56,"column":0},"end":{"line":56,"column":15}},"range":[895,910],"raw":"有二叉排序树T，待插入的结点N"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若T为空，直接将N插入T","loc":{"start":{"line":58,"column":2},"end":{"line":58,"column":14}},"range":[914,926],"raw":"若T为空，直接将N插入T"}],"loc":{"start":{"line":58,"column":2},"end":{"line":58,"column":14}},"range":[914,926],"raw":"若T为空，直接将N插入T"}],"loc":{"start":{"line":58,"column":0},"end":{"line":58,"column":14}},"range":[912,926],"raw":"- 若T为空，直接将N插入T"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若T非空，","loc":{"start":{"line":59,"column":2},"end":{"line":59,"column":7}},"range":[929,934],"raw":"若T非空，"}],"loc":{"start":{"line":59,"column":2},"end":{"line":59,"column":7}},"range":[929,934],"raw":"若T非空，"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若T为空，直接进行插入","loc":{"start":{"line":60,"column":4},"end":{"line":60,"column":15}},"range":[939,950],"raw":"若T为空，直接进行插入"}],"loc":{"start":{"line":60,"column":4},"end":{"line":60,"column":15}},"range":[939,950],"raw":"若T为空，直接进行插入"}],"loc":{"start":{"line":60,"column":2},"end":{"line":60,"column":15}},"range":[937,950],"raw":"- 若T为空，直接进行插入"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若N大于T，将T的右子树赋值给T","loc":{"start":{"line":61,"column":4},"end":{"line":61,"column":20}},"range":[955,971],"raw":"若N大于T，将T的右子树赋值给T"}],"loc":{"start":{"line":61,"column":4},"end":{"line":61,"column":20}},"range":[955,971],"raw":"若N大于T，将T的右子树赋值给T"}],"loc":{"start":{"line":61,"column":2},"end":{"line":61,"column":20}},"range":[953,971],"raw":"- 若N大于T，将T的右子树赋值给T"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若N小于T，将T的左子树赋值给T","loc":{"start":{"line":62,"column":4},"end":{"line":62,"column":20}},"range":[976,992],"raw":"若N小于T，将T的左子树赋值给T"}],"loc":{"start":{"line":62,"column":4},"end":{"line":62,"column":20}},"range":[976,992],"raw":"若N小于T，将T的左子树赋值给T"}],"loc":{"start":{"line":62,"column":2},"end":{"line":62,"column":20}},"range":[974,992],"raw":"- 若N小于T，将T的左子树赋值给T"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若N等于T，不进行插入，插入失败","loc":{"start":{"line":63,"column":4},"end":{"line":63,"column":20}},"range":[997,1013],"raw":"若N等于T，不进行插入，插入失败"}],"loc":{"start":{"line":63,"column":4},"end":{"line":63,"column":20}},"range":[997,1013],"raw":"若N等于T，不进行插入，插入失败"}],"loc":{"start":{"line":63,"column":2},"end":{"line":63,"column":20}},"range":[995,1013],"raw":"- 若N等于T，不进行插入，插入失败"}],"loc":{"start":{"line":60,"column":2},"end":{"line":63,"column":20}},"range":[937,1013],"raw":"- 若T为空，直接进行插入\n  - 若N大于T，将T的右子树赋值给T\n  - 若N小于T，将T的左子树赋值给T\n  - 若N等于T，不进行插入，插入失败"}],"loc":{"start":{"line":59,"column":0},"end":{"line":63,"column":20}},"range":[927,1013],"raw":"- 若T非空，\n  - 若T为空，直接进行插入\n  - 若N大于T，将T的右子树赋值给T\n  - 若N小于T，将T的左子树赋值给T\n  - 若N等于T，不进行插入，插入失败"}],"loc":{"start":{"line":58,"column":0},"end":{"line":63,"column":20}},"range":[912,1013],"raw":"- 若T为空，直接将N插入T\n- 若T非空，\n  - 若T为空，直接进行插入\n  - 若N大于T，将T的右子树赋值给T\n  - 若N小于T，将T的左子树赋值给T\n  - 若N等于T，不进行插入，插入失败"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"递归实现","loc":{"start":{"line":65,"column":5},"end":{"line":65,"column":9}},"range":[1020,1024],"raw":"递归实现"}],"loc":{"start":{"line":65,"column":0},"end":{"line":65,"column":9}},"range":[1015,1024],"raw":"#### 递归实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    if(T == NULL){\n        T = (BiTree)malloc(sizeof(BSTNode));\n        T->data = key;\n        T->lchild = T->rchild = NULL;\n        return OK;\n    }\n    else if(key < T->data) BST_Insert(T->lchild, key);\n    else if(key > T->data) BST_Insert(T->rchild, key);\n    else return ERROR;\n}","loc":{"start":{"line":67,"column":0},"end":{"line":85,"column":3}},"range":[1026,1415],"raw":"```c\n#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    if(T == NULL){\n        T = (BiTree)malloc(sizeof(BSTNode));\n        T->data = key;\n        T->lchild = T->rchild = NULL;\n        return OK;\n    }\n    else if(key < T->data) BST_Insert(T->lchild, key);\n    else if(key > T->data) BST_Insert(T->rchild, key);\n    else return ERROR;\n}\n```"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"非递归实现","loc":{"start":{"line":87,"column":5},"end":{"line":87,"column":10}},"range":[1422,1427],"raw":"非递归实现"}],"loc":{"start":{"line":87,"column":0},"end":{"line":87,"column":10}},"range":[1417,1427],"raw":"#### 非递归实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    while(T != NULL){\n        if(T->data == key) return ERROR;\n        else if(T->data > key) T = T->lchild;\n        else T = T->rchild;\n    }\n    T = (BiTree)malloc(sizeof(BSTNode));\n    T->data = key;\n    T->lchild = T->rchild = NULL;\n    return OK;\n}","loc":{"start":{"line":89,"column":0},"end":{"line":107,"column":3}},"range":[1429,1787],"raw":"```c\n#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    while(T != NULL){\n        if(T->data == key) return ERROR;\n        else if(T->data > key) T = T->lchild;\n        else T = T->rchild;\n    }\n    T = (BiTree)malloc(sizeof(BSTNode));\n    T->data = key;\n    T->lchild = T->rchild = NULL;\n    return OK;\n}\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"构造","loc":{"start":{"line":109,"column":4},"end":{"line":109,"column":6}},"range":[1793,1795],"raw":"构造"}],"loc":{"start":{"line":109,"column":0},"end":{"line":109,"column":6}},"range":[1789,1795],"raw":"### 构造"},{"type":"Paragraph","children":[{"type":"Str","value":"读取一个元素并建立结点，如果二叉排序树为空，则将其作为根结点\n若二叉排序树非空，从根结点开始，如果值大于当前结点值，将其插入右子树，如果值小于当前结点的值，将其插入左子树，如果值与当前结点的值相等，不进行插入。","loc":{"start":{"line":111,"column":0},"end":{"line":112,"column":74}},"range":[1797,1902],"raw":"读取一个元素并建立结点，如果二叉排序树为空，则将其作为根结点\n若二叉排序树非空，从根结点开始，如果值大于当前结点值，将其插入右子树，如果值小于当前结点的值，将其插入左子树，如果值与当前结点的值相等，不进行插入。"}],"loc":{"start":{"line":111,"column":0},"end":{"line":112,"column":74}},"range":[1797,1902],"raw":"读取一个元素并建立结点，如果二叉排序树为空，则将其作为根结点\n若二叉排序树非空，从根结点开始，如果值大于当前结点值，将其插入右子树，如果值小于当前结点的值，将其插入左子树，如果值与当前结点的值相等，不进行插入。"},{"type":"Paragraph","children":[{"type":"Str","value":"本质上就是","loc":{"start":{"line":114,"column":0},"end":{"line":114,"column":5}},"range":[1904,1909],"raw":"本质上就是"},{"type":"Strong","children":[{"type":"Str","value":"不断调用二叉排序树的插入方法","loc":{"start":{"line":114,"column":7},"end":{"line":114,"column":21}},"range":[1911,1925],"raw":"不断调用二叉排序树的插入方法"}],"loc":{"start":{"line":114,"column":5},"end":{"line":114,"column":23}},"range":[1909,1927],"raw":"**不断调用二叉排序树的插入方法**"},{"type":"Str","value":"。","loc":{"start":{"line":114,"column":23},"end":{"line":114,"column":24}},"range":[1927,1928],"raw":"。"}],"loc":{"start":{"line":114,"column":0},"end":{"line":114,"column":24}},"range":[1904,1928],"raw":"本质上就是**不断调用二叉排序树的插入方法**。"},{"type":"Paragraph","children":[{"type":"Html","value":"<font color=\"red\">","loc":{"start":{"line":116,"column":0},"end":{"line":116,"column":18}},"range":[1930,1948],"raw":"<font color=\"red\">"},{"type":"Html","value":"<b>","loc":{"start":{"line":116,"column":18},"end":{"line":116,"column":21}},"range":[1948,1951],"raw":"<b>"},{"type":"Str","value":"即使使用相同的来构造二叉排序树，如果插入的顺序不同，得到的结果也不同。","loc":{"start":{"line":116,"column":21},"end":{"line":116,"column":56}},"range":[1951,1986],"raw":"即使使用相同的来构造二叉排序树，如果插入的顺序不同，得到的结果也不同。"},{"type":"Html","value":"</b>","loc":{"start":{"line":116,"column":56},"end":{"line":116,"column":60}},"range":[1986,1990],"raw":"</b>"},{"type":"Html","value":"</font>","loc":{"start":{"line":116,"column":60},"end":{"line":116,"column":67}},"range":[1990,1997],"raw":"</font>"}],"loc":{"start":{"line":116,"column":0},"end":{"line":116,"column":67}},"range":[1930,1997],"raw":"<font color=\"red\"><b>即使使用相同的来构造二叉排序树，如果插入的顺序不同，得到的结果也不同。</b></font>"},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/07/29/sQoSv4gUmclqAZ1.png","alt":"PNG??.png","loc":{"start":{"line":118,"column":0},"end":{"line":118,"column":63}},"range":[1999,2062],"raw":"![PNG??.png](https://i.loli.net/2020/07/29/sQoSv4gUmclqAZ1.png)"}],"loc":{"start":{"line":118,"column":0},"end":{"line":118,"column":63}},"range":[1999,2062],"raw":"![PNG??.png](https://i.loli.net/2020/07/29/sQoSv4gUmclqAZ1.png)"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":119,"column":5},"end":{"line":119,"column":9}},"range":[2068,2072],"raw":"代码实现"}],"loc":{"start":{"line":119,"column":0},"end":{"line":119,"column":9}},"range":[2063,2072],"raw":"#### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"void CreateBST(BiTree *T, ElemType elems[], int n){\n    for(int i = 0;i < n;i ++) BST_Insert(T, elems[i]);\n}","loc":{"start":{"line":121,"column":0},"end":{"line":125,"column":3}},"range":[2074,2191],"raw":"```c\nvoid CreateBST(BiTree *T, ElemType elems[], int n){\n    for(int i = 0;i < n;i ++) BST_Insert(T, elems[i]);\n}\n```"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"删除","loc":{"start":{"line":127,"column":4},"end":{"line":127,"column":6}},"range":[2197,2199],"raw":"删除"}],"loc":{"start":{"line":127,"column":0},"end":{"line":127,"column":6}},"range":[2193,2199],"raw":"### 删除"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若删除的结点是叶节点，直接删除","loc":{"start":{"line":129,"column":2},"end":{"line":129,"column":17}},"range":[2203,2218],"raw":"若删除的结点是叶节点，直接删除"}],"loc":{"start":{"line":129,"column":2},"end":{"line":129,"column":17}},"range":[2203,2218],"raw":"若删除的结点是叶节点，直接删除"}],"loc":{"start":{"line":129,"column":0},"end":{"line":129,"column":17}},"range":[2201,2218],"raw":"- 若删除的结点是叶节点，直接删除"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树","loc":{"start":{"line":130,"column":2},"end":{"line":130,"column":35}},"range":[2221,2254],"raw":"若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树"}],"loc":{"start":{"line":130,"column":2},"end":{"line":130,"column":35}},"range":[2221,2254],"raw":"若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树"}],"loc":{"start":{"line":130,"column":0},"end":{"line":130,"column":35}},"range":[2219,2254],"raw":"- 若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。","loc":{"start":{"line":131,"column":2},"end":{"line":131,"column":73}},"range":[2257,2328],"raw":"若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。"}],"loc":{"start":{"line":131,"column":2},"end":{"line":131,"column":73}},"range":[2257,2328],"raw":"若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。"}],"loc":{"start":{"line":131,"column":0},"end":{"line":131,"column":73}},"range":[2255,2328],"raw":"- 若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。"}],"loc":{"start":{"line":129,"column":0},"end":{"line":131,"column":73}},"range":[2201,2328],"raw":"- 若删除的结点是叶节点，直接删除\n- 若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树\n- 若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。"},{"type":"Header","depth":4,"children":[{"type":"Str","value":"代码实现","loc":{"start":{"line":133,"column":5},"end":{"line":133,"column":9}},"range":[2335,2339],"raw":"代码实现"}],"loc":{"start":{"line":133,"column":0},"end":{"line":133,"column":9}},"range":[2330,2339],"raw":"#### 代码实现"},{"type":"CodeBlock","lang":"c","meta":null,"value":"Status DeleteBST(BiTree *T, BSTNode* node){\n    if(node == NULL) return ERROR; // 要删除的结点本来就不存在\n    if(node->lchild == NULL && node->rchild == NULL) node = NULL; // 为叶子结点，直接删除\n    else if(node->lchild == NULL) node = node->rchild;\n    else if(node->rchild == NULL) node = node->lchild;\n    else{\n        // 需要被删除的结点有两棵子树，寻找其中序序列的直接后继\n        BSTNode* next = node->rchild;\n        while(next->lchild != NULL) next = next->lchild;\n        node = next; // 使用直接后继结点替代当前结点\n        DeleteBST(T, next);\n    }\n    return OK;\n}","loc":{"start":{"line":135,"column":0},"end":{"line":150,"column":3}},"range":[2341,2867],"raw":"```c\nStatus DeleteBST(BiTree *T, BSTNode* node){\n    if(node == NULL) return ERROR; // 要删除的结点本来就不存在\n    if(node->lchild == NULL && node->rchild == NULL) node = NULL; // 为叶子结点，直接删除\n    else if(node->lchild == NULL) node = node->rchild;\n    else if(node->rchild == NULL) node = node->lchild;\n    else{\n        // 需要被删除的结点有两棵子树，寻找其中序序列的直接后继\n        BSTNode* next = node->rchild;\n        while(next->lchild != NULL) next = next->lchild;\n        node = next; // 使用直接后继结点替代当前结点\n        DeleteBST(T, next);\n    }\n    return OK;\n}\n```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":151,"column":0}},"range":[0,2868],"raw":"---\ntags: ['数据结构','树']\n---\n\n# 二叉排序树\n\n> 二叉排序树(BST)，也称二叉查找树\n> 可以为空，当其不为空时需要满足：\n>\n> - 如果左子树非空，左子树上的结点均小于根结点\n> - 如果右子树非空，右子树上的结点均大于根结点\n> - 左右子树本身也是二叉排序树\n>\n> 二叉排序树是一个递归的定义，二叉排序树中没有相同值的结点\n\n二叉排序树的中序遍历序列是一个递增的有序序列。\n\n## 二叉排序树的常用操作\n\n### 查找\n\n二叉排序树非空，从根结点开始，如果\n\n- 若当前结点的值和要查找的值相等，查找成功\n- 若当前结点的值小于要查找的值，将当前结点的右孩子设置为当前结点\n- 若当前结点的值大于要查找的值，将当前结点的做孩子设置为当前结点\n- 若查找到叶子结点仍然没有查找成功，则查找失败\n\n#### 递归实现\n\n```c\nBSTNode* BST_Search(BiTree* T, ElemType key){\n    if(key == T->data) return T;\n    if(key > T->data && T->rchild != NULL) return BST_Search(T->rchild, key);\n    if(key < T->data && T->lchild != NULL) return BST_Search(T->lchild, key);\n    return NULL;\n}\n```\n\n#### 非递归实现\n\n```c\nBSTNode* BST_Search(BiTree* T, ElemType key){\n    while(T != NULL && key != T->data){\n        if(key > T->data) T = T->rchild;\n        if(key < T->data) T = T->lchild;\n    }\n    return T;\n}\n```\n\n二叉排序树查找的时间复杂度是O(h)，其中h是二叉排序树的高度\n\n### 插入\n\n有二叉排序树T，待插入的结点N\n\n- 若T为空，直接将N插入T\n- 若T非空，\n  - 若T为空，直接进行插入\n  - 若N大于T，将T的右子树赋值给T\n  - 若N小于T，将T的左子树赋值给T\n  - 若N等于T，不进行插入，插入失败\n\n#### 递归实现\n\n```c\n#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    if(T == NULL){\n        T = (BiTree)malloc(sizeof(BSTNode));\n        T->data = key;\n        T->lchild = T->rchild = NULL;\n        return OK;\n    }\n    else if(key < T->data) BST_Insert(T->lchild, key);\n    else if(key > T->data) BST_Insert(T->rchild, key);\n    else return ERROR;\n}\n```\n\n#### 非递归实现\n\n```c\n#define OK 1\n\n#define ERROR 0\n\ntypedef Status int;\n\nStatus BST_Insert(BiTree *T, ElemType key){\n    while(T != NULL){\n        if(T->data == key) return ERROR;\n        else if(T->data > key) T = T->lchild;\n        else T = T->rchild;\n    }\n    T = (BiTree)malloc(sizeof(BSTNode));\n    T->data = key;\n    T->lchild = T->rchild = NULL;\n    return OK;\n}\n```\n\n### 构造\n\n读取一个元素并建立结点，如果二叉排序树为空，则将其作为根结点\n若二叉排序树非空，从根结点开始，如果值大于当前结点值，将其插入右子树，如果值小于当前结点的值，将其插入左子树，如果值与当前结点的值相等，不进行插入。\n\n本质上就是**不断调用二叉排序树的插入方法**。\n\n<font color=\"red\"><b>即使使用相同的来构造二叉排序树，如果插入的顺序不同，得到的结果也不同。</b></font>\n\n![PNG??.png](https://i.loli.net/2020/07/29/sQoSv4gUmclqAZ1.png)\n#### 代码实现\n\n```c\nvoid CreateBST(BiTree *T, ElemType elems[], int n){\n    for(int i = 0;i < n;i ++) BST_Insert(T, elems[i]);\n}\n```\n\n### 删除\n\n- 若删除的结点是叶节点，直接删除\n- 若被删除的结点只有一棵子树，让子树直接替代该以该结点为根结点的子树\n- 若被删除的结点有两棵子树时，让该结点的中序序列直接后继（直接后继比该节点大，但是比该节点右子树中其他的结点小）代替该节点，并删除直接后继结点。\n\n#### 代码实现\n\n```c\nStatus DeleteBST(BiTree *T, BSTNode* node){\n    if(node == NULL) return ERROR; // 要删除的结点本来就不存在\n    if(node->lchild == NULL && node->rchild == NULL) node = NULL; // 为叶子结点，直接删除\n    else if(node->lchild == NULL) node = node->rchild;\n    else if(node->rchild == NULL) node = node->lchild;\n    else{\n        // 需要被删除的结点有两棵子树，寻找其中序序列的直接后继\n        BSTNode* next = node->rchild;\n        while(next->lchild != NULL) next = next->lchild;\n        node = next; // 使用直接后继结点替代当前结点\n        DeleteBST(T, next);\n    }\n    return OK;\n}\n```\n"},"catalogue":{"title":"2020-07-29-二叉排序树","json-path":"2020-07-29-二叉排序树.json","mdate":"2022-08-30T14:19:31.449Z","tags":["数据结构","树"]}}