{"ast":{"type":"Document","children":[{"type":"Yaml","value":"tags: ['数据结构','串']","loc":{"start":{"line":1,"column":0},"end":{"line":3,"column":3}},"range":[0,26],"raw":"---\ntags: ['数据结构','串']\n---"},{"type":"Header","depth":2,"children":[{"type":"Str","value":"KMP串匹配算法","loc":{"start":{"line":5,"column":3},"end":{"line":5,"column":11}},"range":[31,39],"raw":"KMP串匹配算法"}],"loc":{"start":{"line":5,"column":0},"end":{"line":5,"column":11}},"range":[28,39],"raw":"## KMP串匹配算法"},{"type":"Paragraph","children":[{"type":"Str","value":"在原始字符串T中查找模式串P出现的第一个位置","loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":22}},"range":[41,63],"raw":"在原始字符串T中查找模式串P出现的第一个位置"}],"loc":{"start":{"line":7,"column":0},"end":{"line":7,"column":22}},"range":[41,63],"raw":"在原始字符串T中查找模式串P出现的第一个位置"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"暴力搜索","loc":{"start":{"line":9,"column":4},"end":{"line":9,"column":8}},"range":[69,73],"raw":"暴力搜索"}],"loc":{"start":{"line":9,"column":0},"end":{"line":9,"column":8}},"range":[65,73],"raw":"### 暴力搜索"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"暴力搜索是最简单的匹配算法，将模式串与原始字符串的字符逐个比较，当遇到不匹配的字符的时候，将模式串向右移动一个字符串，然后将模式串与原始串内的字符逐个进行比较，知道模式串内所有的字符都可以匹配为止。","loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":101}},"range":[77,176],"raw":"暴力搜索是最简单的匹配算法，将模式串与原始字符串的字符逐个比较，当遇到不匹配的字符的时候，将模式串向右移动一个字符串，然后将模式串与原始串内的字符逐个进行比较，知道模式串内所有的字符都可以匹配为止。"}],"loc":{"start":{"line":11,"column":2},"end":{"line":11,"column":101}},"range":[77,176],"raw":"暴力搜索是最简单的匹配算法，将模式串与原始字符串的字符逐个比较，当遇到不匹配的字符的时候，将模式串向右移动一个字符串，然后将模式串与原始串内的字符逐个进行比较，知道模式串内所有的字符都可以匹配为止。"},{"type":"Paragraph","children":[{"type":"Emphasis","children":[{"type":"Str","value":"算法的时间复杂度：此算法的时间复杂度较高，效率较低","loc":{"start":{"line":13,"column":3},"end":{"line":13,"column":28}},"range":[182,207],"raw":"算法的时间复杂度：此算法的时间复杂度较高，效率较低"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":29}},"range":[181,208],"raw":"*算法的时间复杂度：此算法的时间复杂度较高，效率较低*"}],"loc":{"start":{"line":13,"column":2},"end":{"line":13,"column":29}},"range":[181,208],"raw":"*算法的时间复杂度：此算法的时间复杂度较高，效率较低*"}],"loc":{"start":{"line":11,"column":0},"end":{"line":13,"column":29}},"range":[75,208],"raw":"> 暴力搜索是最简单的匹配算法，将模式串与原始字符串的字符逐个比较，当遇到不匹配的字符的时候，将模式串向右移动一个字符串，然后将模式串与原始串内的字符逐个进行比较，知道模式串内所有的字符都可以匹配为止。\n>\n> *算法的时间复杂度：此算法的时间复杂度较高，效率较低*"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"KMP匹配","loc":{"start":{"line":15,"column":4},"end":{"line":15,"column":9}},"range":[214,219],"raw":"KMP匹配"}],"loc":{"start":{"line":15,"column":0},"end":{"line":15,"column":9}},"range":[210,219],"raw":"### KMP匹配"},{"type":"List","ordered":true,"start":1,"spread":true,"children":[{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"计算前缀表(Prefix Table)","loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":22}},"range":[224,243],"raw":"计算前缀表(Prefix Table)"}],"loc":{"start":{"line":17,"column":3},"end":{"line":17,"column":22}},"range":[224,243],"raw":"计算前缀表(Prefix Table)"},{"type":"BlockQuote","children":[{"type":"Paragraph","children":[{"type":"Str","value":"前缀：字符串的任意首部","loc":{"start":{"line":19,"column":5},"end":{"line":19,"column":16}},"range":[250,261],"raw":"前缀：字符串的任意首部"}],"loc":{"start":{"line":19,"column":5},"end":{"line":19,"column":16}},"range":[250,261],"raw":"前缀：字符串的任意首部"},{"type":"Paragraph","children":[{"type":"Str","value":"后缀：字符串的任意尾部","loc":{"start":{"line":21,"column":5},"end":{"line":21,"column":16}},"range":[272,283],"raw":"后缀：字符串的任意尾部"}],"loc":{"start":{"line":21,"column":5},"end":{"line":21,"column":16}},"range":[272,283],"raw":"后缀：字符串的任意尾部"},{"type":"Paragraph","children":[{"type":"Str","value":"真前（后）缀：不包含字符串本身","loc":{"start":{"line":23,"column":5},"end":{"line":23,"column":20}},"range":[294,309],"raw":"真前（后）缀：不包含字符串本身"}],"loc":{"start":{"line":23,"column":5},"end":{"line":23,"column":20}},"range":[294,309],"raw":"真前（后）缀：不包含字符串本身"}],"loc":{"start":{"line":19,"column":3},"end":{"line":23,"column":20}},"range":[248,309],"raw":"> 前缀：字符串的任意首部\n   >\n   > 后缀：字符串的任意尾部\n   >\n   > 真前（后）缀：不包含字符串本身"},{"type":"List","ordered":false,"start":null,"spread":true,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"先求出模式P的所有的真前缀","loc":{"start":{"line":25,"column":5},"end":{"line":25,"column":18}},"range":[316,329],"raw":"先求出模式P的所有的真前缀"}],"loc":{"start":{"line":25,"column":5},"end":{"line":25,"column":18}},"range":[316,329],"raw":"先求出模式P的所有的真前缀"}],"loc":{"start":{"line":25,"column":3},"end":{"line":25,"column":18}},"range":[314,329],"raw":"- 先求出模式P的所有的真前缀"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"求出上一步中每一个前缀的","loc":{"start":{"line":26,"column":5},"end":{"line":26,"column":17}},"range":[335,347],"raw":"求出上一步中每一个前缀的"},{"type":"Strong","children":[{"type":"Str","value":"最长公共真前后缀","loc":{"start":{"line":26,"column":19},"end":{"line":26,"column":27}},"range":[349,357],"raw":"最长公共真前后缀"}],"loc":{"start":{"line":26,"column":17},"end":{"line":26,"column":29}},"range":[347,359],"raw":"**最长公共真前后缀**"},{"type":"Str","value":"的长度","loc":{"start":{"line":26,"column":29},"end":{"line":26,"column":32}},"range":[359,362],"raw":"的长度"}],"loc":{"start":{"line":26,"column":5},"end":{"line":26,"column":32}},"range":[335,362],"raw":"求出上一步中每一个前缀的**最长公共真前后缀**的长度"}],"loc":{"start":{"line":26,"column":3},"end":{"line":26,"column":32}},"range":[333,362],"raw":"- 求出上一步中每一个前缀的**最长公共真前后缀**的长度"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"在上一步求出的表的头部插入-1，组成","loc":{"start":{"line":27,"column":5},"end":{"line":27,"column":23}},"range":[368,386],"raw":"在上一步求出的表的头部插入-1，组成"},{"type":"Strong","children":[{"type":"Str","value":"前缀表","loc":{"start":{"line":27,"column":25},"end":{"line":27,"column":28}},"range":[388,391],"raw":"前缀表"}],"loc":{"start":{"line":27,"column":23},"end":{"line":27,"column":30}},"range":[386,393],"raw":"**前缀表**"}],"loc":{"start":{"line":27,"column":5},"end":{"line":27,"column":30}},"range":[368,393],"raw":"在上一步求出的表的头部插入-1，组成**前缀表**"}],"loc":{"start":{"line":27,"column":3},"end":{"line":27,"column":30}},"range":[366,393],"raw":"- 在上一步求出的表的头部插入-1，组成**前缀表**"}],"loc":{"start":{"line":25,"column":3},"end":{"line":29,"column":3}},"range":[314,398],"raw":"- 先求出模式P的所有的真前缀\n   - 求出上一步中每一个前缀的**最长公共真前后缀**的长度\n   - 在上一步求出的表的头部插入-1，组成**前缀表**\n\n   "},{"type":"Paragraph","children":[{"type":"Str","value":"例如“ababc”的前缀表如下图所示：","loc":{"start":{"line":31,"column":3},"end":{"line":31,"column":22}},"range":[403,422],"raw":"例如“ababc”的前缀表如下图所示："}],"loc":{"start":{"line":31,"column":3},"end":{"line":31,"column":22}},"range":[403,422],"raw":"例如“ababc”的前缀表如下图所示："},{"type":"Paragraph","children":[{"type":"Image","title":null,"url":"https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png","alt":"quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png","loc":{"start":{"line":33,"column":3},"end":{"line":33,"column":105}},"range":[427,529],"raw":"![quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png](https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png)"}],"loc":{"start":{"line":33,"column":3},"end":{"line":33,"column":105}},"range":[427,529],"raw":"![quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png](https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png)"}],"loc":{"start":{"line":17,"column":0},"end":{"line":33,"column":105}},"range":[221,529],"raw":"1. 计算前缀表(Prefix Table)\n\n   > 前缀：字符串的任意首部\n   >\n   > 后缀：字符串的任意尾部\n   >\n   > 真前（后）缀：不包含字符串本身\n\n   - 先求出模式P的所有的真前缀\n   - 求出上一步中每一个前缀的**最长公共真前后缀**的长度\n   - 在上一步求出的表的头部插入-1，组成**前缀表**\n\n   \n\n   例如“ababc”的前缀表如下图所示：\n\n   ![quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png](https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png)"},{"type":"ListItem","spread":true,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"根据刚刚求出的","loc":{"start":{"line":35,"column":3},"end":{"line":35,"column":10}},"range":[534,541],"raw":"根据刚刚求出的"},{"type":"Strong","children":[{"type":"Str","value":"前缀表","loc":{"start":{"line":35,"column":12},"end":{"line":35,"column":15}},"range":[543,546],"raw":"前缀表"}],"loc":{"start":{"line":35,"column":10},"end":{"line":35,"column":17}},"range":[541,548],"raw":"**前缀表**"},{"type":"Str","value":"，开始匹配","loc":{"start":{"line":35,"column":17},"end":{"line":35,"column":22}},"range":[548,553],"raw":"，开始匹配"}],"loc":{"start":{"line":35,"column":3},"end":{"line":35,"column":22}},"range":[534,553],"raw":"根据刚刚求出的**前缀表**，开始匹配"},{"type":"List","ordered":false,"start":null,"spread":false,"children":[{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"a. 将模式串的第一个字符与原始串的第一个字符对齐","loc":{"start":{"line":37,"column":5},"end":{"line":37,"column":30}},"range":[560,585],"raw":"a. 将模式串的第一个字符与原始串的第一个字符对齐"}],"loc":{"start":{"line":37,"column":5},"end":{"line":37,"column":30}},"range":[560,585],"raw":"a. 将模式串的第一个字符与原始串的第一个字符对齐"}],"loc":{"start":{"line":37,"column":3},"end":{"line":37,"column":30}},"range":[558,585],"raw":"- a. 将模式串的第一个字符与原始串的第一个字符对齐"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"b. 逐个字符向后匹配，直到匹配到第i个字符时失配","loc":{"start":{"line":38,"column":5},"end":{"line":38,"column":30}},"range":[591,616],"raw":"b. 逐个字符向后匹配，直到匹配到第i个字符时失配"}],"loc":{"start":{"line":38,"column":5},"end":{"line":38,"column":30}},"range":[591,616],"raw":"b. 逐个字符向后匹配，直到匹配到第i个字符时失配"}],"loc":{"start":{"line":38,"column":3},"end":{"line":38,"column":30}},"range":[589,616],"raw":"- b. 逐个字符向后匹配，直到匹配到第i个字符时失配"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"c. 查询前缀表中第i个值j","loc":{"start":{"line":39,"column":5},"end":{"line":39,"column":19}},"range":[622,636],"raw":"c. 查询前缀表中第i个值j"}],"loc":{"start":{"line":39,"column":5},"end":{"line":39,"column":19}},"range":[622,636],"raw":"c. 查询前缀表中第i个值j"}],"loc":{"start":{"line":39,"column":3},"end":{"line":39,"column":19}},"range":[620,636],"raw":"- c. 查询前缀表中第i个值j"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始","loc":{"start":{"line":40,"column":5},"end":{"line":40,"column":40}},"range":[642,677],"raw":"d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始"}],"loc":{"start":{"line":40,"column":5},"end":{"line":40,"column":40}},"range":[642,677],"raw":"d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始"}],"loc":{"start":{"line":40,"column":3},"end":{"line":40,"column":40}},"range":[640,677],"raw":"- d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始"},{"type":"ListItem","spread":false,"checked":null,"children":[{"type":"Paragraph","children":[{"type":"Str","value":"重复 b-d 步骤，直到匹配成功","loc":{"start":{"line":41,"column":5},"end":{"line":41,"column":21}},"range":[683,699],"raw":"重复 b-d 步骤，直到匹配成功"}],"loc":{"start":{"line":41,"column":5},"end":{"line":41,"column":21}},"range":[683,699],"raw":"重复 b-d 步骤，直到匹配成功"}],"loc":{"start":{"line":41,"column":3},"end":{"line":41,"column":21}},"range":[681,699],"raw":"- 重复 b-d 步骤，直到匹配成功"}],"loc":{"start":{"line":37,"column":3},"end":{"line":41,"column":21}},"range":[558,699],"raw":"- a. 将模式串的第一个字符与原始串的第一个字符对齐\n   - b. 逐个字符向后匹配，直到匹配到第i个字符时失配\n   - c. 查询前缀表中第i个值j\n   - d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始\n   - 重复 b-d 步骤，直到匹配成功"}],"loc":{"start":{"line":35,"column":0},"end":{"line":41,"column":21}},"range":[531,699],"raw":"2. 根据刚刚求出的**前缀表**，开始匹配\n\n   - a. 将模式串的第一个字符与原始串的第一个字符对齐\n   - b. 逐个字符向后匹配，直到匹配到第i个字符时失配\n   - c. 查询前缀表中第i个值j\n   - d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始\n   - 重复 b-d 步骤，直到匹配成功"}],"loc":{"start":{"line":17,"column":0},"end":{"line":41,"column":21}},"range":[221,699],"raw":"1. 计算前缀表(Prefix Table)\n\n   > 前缀：字符串的任意首部\n   >\n   > 后缀：字符串的任意尾部\n   >\n   > 真前（后）缀：不包含字符串本身\n\n   - 先求出模式P的所有的真前缀\n   - 求出上一步中每一个前缀的**最长公共真前后缀**的长度\n   - 在上一步求出的表的头部插入-1，组成**前缀表**\n\n   \n\n   例如“ababc”的前缀表如下图所示：\n\n   ![quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png](https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png)\n\n2. 根据刚刚求出的**前缀表**，开始匹配\n\n   - a. 将模式串的第一个字符与原始串的第一个字符对齐\n   - b. 逐个字符向后匹配，直到匹配到第i个字符时失配\n   - c. 查询前缀表中第i个值j\n   - d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始\n   - 重复 b-d 步骤，直到匹配成功"},{"type":"Header","depth":3,"children":[{"type":"Str","value":"使用js实现的Kmp算法Demo","loc":{"start":{"line":43,"column":4},"end":{"line":43,"column":20}},"range":[705,721],"raw":"使用js实现的Kmp算法Demo"}],"loc":{"start":{"line":43,"column":0},"end":{"line":43,"column":20}},"range":[701,721],"raw":"### 使用js实现的Kmp算法Demo"},{"type":"CodeBlock","lang":"javascript","meta":null,"value":"//leetcode submit region begin(Prohibit modification and deletion)\n/**\n * 求next表\n * @param {string} needle\n * @returns {[number]}\n */\nfunction nextTable (needle) {\n    /**\n     * 最长公共真前后缀的长度\n     * @param {string} s\n     */\n    let maxPrefixSuffix = function(s){\n        let result = 0;\n        for(let i=s.length-1;i>0;i--){\n            if(s.slice(0,i)===s.slice(s.length-i, s.length)) {\n                result = i;\n                break;\n            }\n        }\n        // console.log(s, result);\n        return result;\n    }\n    let results = [-1];\n    for(let i=1;i<needle.length;i++){\n        results.push(maxPrefixSuffix(needle.slice(0,i)));\n    }\n    return results;\n}\n/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    let next = nextTable(needle);\n    // console.log(next);\n    let haystackCursor = 0, needleCursor = 0;\n    while (haystackCursor<=haystack.length-needle.length&&needleCursor<needle.length){\n        // console.log(haystackCursor, needleCursor);\n        if(haystack[haystackCursor+needleCursor]===needle[needleCursor]){\n            needleCursor++;\n        }\n        else {\n            // console.log(needleCursor-next[needleCursor]);\n            haystackCursor += needleCursor-next[needleCursor];\n            needleCursor = next[needleCursor]>0?next[needleCursor]:0;\n        }\n    }\n    if(haystack.slice(haystackCursor, haystackCursor+needle.length)===needle) return haystackCursor;\n    else return -1;\n};\n//leetcode submit region end(Prohibit modification and deletion)\nlet h = 'aabaaabaaac',\n    n = 'aabaaac';\nlet res = strStr(h,n);\nconsole.log('results ', h.length, res, h.slice(res, res+n.length));","loc":{"start":{"line":45,"column":0},"end":{"line":102,"column":3}},"range":[723,2446],"raw":"```javascript\n//leetcode submit region begin(Prohibit modification and deletion)\n/**\n * 求next表\n * @param {string} needle\n * @returns {[number]}\n */\nfunction nextTable (needle) {\n    /**\n     * 最长公共真前后缀的长度\n     * @param {string} s\n     */\n    let maxPrefixSuffix = function(s){\n        let result = 0;\n        for(let i=s.length-1;i>0;i--){\n            if(s.slice(0,i)===s.slice(s.length-i, s.length)) {\n                result = i;\n                break;\n            }\n        }\n        // console.log(s, result);\n        return result;\n    }\n    let results = [-1];\n    for(let i=1;i<needle.length;i++){\n        results.push(maxPrefixSuffix(needle.slice(0,i)));\n    }\n    return results;\n}\n/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    let next = nextTable(needle);\n    // console.log(next);\n    let haystackCursor = 0, needleCursor = 0;\n    while (haystackCursor<=haystack.length-needle.length&&needleCursor<needle.length){\n        // console.log(haystackCursor, needleCursor);\n        if(haystack[haystackCursor+needleCursor]===needle[needleCursor]){\n            needleCursor++;\n        }\n        else {\n            // console.log(needleCursor-next[needleCursor]);\n            haystackCursor += needleCursor-next[needleCursor];\n            needleCursor = next[needleCursor]>0?next[needleCursor]:0;\n        }\n    }\n    if(haystack.slice(haystackCursor, haystackCursor+needle.length)===needle) return haystackCursor;\n    else return -1;\n};\n//leetcode submit region end(Prohibit modification and deletion)\nlet h = 'aabaaabaaac',\n    n = 'aabaaac';\nlet res = strStr(h,n);\nconsole.log('results ', h.length, res, h.slice(res, res+n.length));\n```"}],"loc":{"start":{"line":1,"column":0},"end":{"line":106,"column":0}},"range":[0,2450],"raw":"---\ntags: ['数据结构','串']\n---\n\n## KMP串匹配算法\n\n在原始字符串T中查找模式串P出现的第一个位置\n\n### 暴力搜索\n\n> 暴力搜索是最简单的匹配算法，将模式串与原始字符串的字符逐个比较，当遇到不匹配的字符的时候，将模式串向右移动一个字符串，然后将模式串与原始串内的字符逐个进行比较，知道模式串内所有的字符都可以匹配为止。\n>\n> *算法的时间复杂度：此算法的时间复杂度较高，效率较低*\n\n### KMP匹配\n\n1. 计算前缀表(Prefix Table)\n\n   > 前缀：字符串的任意首部\n   >\n   > 后缀：字符串的任意尾部\n   >\n   > 真前（后）缀：不包含字符串本身\n\n   - 先求出模式P的所有的真前缀\n   - 求出上一步中每一个前缀的**最长公共真前后缀**的长度\n   - 在上一步求出的表的头部插入-1，组成**前缀表**\n\n   \n\n   例如“ababc”的前缀表如下图所示：\n\n   ![quicker_079f4b00-475d-4458-a1b6-3df070f1ba5b.png](https://i.loli.net/2020/07/23/pA6k2REDibvLyxC.png)\n\n2. 根据刚刚求出的**前缀表**，开始匹配\n\n   - a. 将模式串的第一个字符与原始串的第一个字符对齐\n   - b. 逐个字符向后匹配，直到匹配到第i个字符时失配\n   - c. 查询前缀表中第i个值j\n   - d. 将模式串的第j个字符与原始串中失配的字符对齐，然后从这个字符开始\n   - 重复 b-d 步骤，直到匹配成功\n\n### 使用js实现的Kmp算法Demo\n\n```javascript\n//leetcode submit region begin(Prohibit modification and deletion)\n/**\n * 求next表\n * @param {string} needle\n * @returns {[number]}\n */\nfunction nextTable (needle) {\n    /**\n     * 最长公共真前后缀的长度\n     * @param {string} s\n     */\n    let maxPrefixSuffix = function(s){\n        let result = 0;\n        for(let i=s.length-1;i>0;i--){\n            if(s.slice(0,i)===s.slice(s.length-i, s.length)) {\n                result = i;\n                break;\n            }\n        }\n        // console.log(s, result);\n        return result;\n    }\n    let results = [-1];\n    for(let i=1;i<needle.length;i++){\n        results.push(maxPrefixSuffix(needle.slice(0,i)));\n    }\n    return results;\n}\n/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\nvar strStr = function(haystack, needle) {\n    let next = nextTable(needle);\n    // console.log(next);\n    let haystackCursor = 0, needleCursor = 0;\n    while (haystackCursor<=haystack.length-needle.length&&needleCursor<needle.length){\n        // console.log(haystackCursor, needleCursor);\n        if(haystack[haystackCursor+needleCursor]===needle[needleCursor]){\n            needleCursor++;\n        }\n        else {\n            // console.log(needleCursor-next[needleCursor]);\n            haystackCursor += needleCursor-next[needleCursor];\n            needleCursor = next[needleCursor]>0?next[needleCursor]:0;\n        }\n    }\n    if(haystack.slice(haystackCursor, haystackCursor+needle.length)===needle) return haystackCursor;\n    else return -1;\n};\n//leetcode submit region end(Prohibit modification and deletion)\nlet h = 'aabaaabaaac',\n    n = 'aabaaac';\nlet res = strStr(h,n);\nconsole.log('results ', h.length, res, h.slice(res, res+n.length));\n```\n\n\n\n"},"catalogue":{"title":"2020-07-23-KMP串匹配算法","json-path":"2020-07-23-KMP串匹配算法.json","mdate":"2022-08-30T14:19:31.447Z","tags":["数据结构","串"]}}